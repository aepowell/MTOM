# RiverWare_Ruleset 6.6.3 Patch
# Created 10:41 May 27, 2015
# 
RULESET
AGENDA_ORDER ASCENDING;
DESCRIPTION "";
PRECISION   8;
VIEW_DOC_INFO
  DOC_INFO_LOC_PART2 "MTOM_Rules_2013-DocTemplate.html";
  DOC_INFO_FORMAT "Auto";
BEGIN

  POLICY_GROUP   "Calculate Final State Use and Overruns";
  DESCRIPTION    "This policy group contains rules that compute the projected annual water use for the Lower Division States and large junior priority users in each state (i.e. MWD, CAP, and SNWA). It also computes any projected over- or under-runs after all water schedule adjustments have been made. <br><br>The slots containing the state adjusted apportionments do not get changed when shortage or surplus is declared. They also do not get changed for Lower Basin demand variability. So, the difference in the schedules will appear as an overrun or underrun.";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Final SNWP Diversion";
    DESCRIPTION          "Calculates projected annual water use for SNWA after all schedule adjustments. Adjustments may be made to get Nevada to their projected annual apportionment, lower basin demand variability, shortage, or surplus.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    BEGIN

      $ "ForecastUse.SNWPAnnualFC" [@"24:00:00 December Max DayOfMonth, Current Year"] := "Annual Volume"( $ "PumpingFromLakeMead:SNWP.Diversion Requested" );

    END;

    RULE                 "Final CAP Diversion";
    DESCRIPTION          "Calculates projected annual water use for CAP after all schedule adjustments. Adjustments may be made to get Arizona to their projected annual apportionment, lower basin demand variability, shortage, or surplus.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    BEGIN

      $ "ForecastUse.CAPAnnualFC" [@"24:00:00 December Max DayOfMonth, Current Year"] := "Annual Volume"( $ "CAPDiversion.Total Diversion Requested" );

    END;

    RULE                 "Final MWD Diversion";
    DESCRIPTION          "Calculates projected annual water use for MWD after all schedule adjustments. Adjustments may be made to get California to their projected annual apportionment, lower basin demand variability, shortage, or surplus.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    BEGIN

      $ "ForecastUse.MWDDiversionAnnualFC" [@"24:00:00 December Max DayOfMonth, Current Year"] := "Annual Volume"( $ "MWDDiversion:MWD.Diversion Requested" );

      $ "ForecastUse.MWDAnnualFC" [@"24:00:00 December Max DayOfMonth, Current Year"] := IF ( "GetYear"( @"t" ) == "GetYear"( @"Start Timestep" ) AND "GetMonth"( @"Start Timestep" ) > 1.00000000 )
   THEN
      "SumSlot"( $ "California_CU_Actual.MWD", @"24:00:00 January Max DayOfMonth, Current Year", @"Start Timestep - 1" ) + ( "SumFlowsToVolume"( $ "MWDDiversion:MWD.Diversion Requested", @"Start Timestep", @"24:00:00 December Max DayOfMonth, Current Year" ) - "SumSlot"( $ "California_CU_Schedules.MWDReturns", @"Start Timestep", @"24:00:00 December Max DayOfMonth, Current Year" ) )
   ELSE
      "Annual Volume"( $ "MWDDiversion:MWD.Diversion Requested" ) - "AnnualVolumeSlot"( $ "California_CU_Schedules.MWDReturns" )
   ENDIF;

    END;

    RULE                 "Final CA Overrun - Div Req";
    DESCRIPTION          "Calculates projected overrun or underrun for California after all schedule adjustments. ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    BEGIN

      $ "AnnualWaterUse.CaOverrun" [@"24:00:00 December 31, Current Year"] := $ "AnnualWaterUse.CaTotalAnnual" [@"24:00:00 December 31, Current Year"] - $ "AnnualWaterUse.California_Apportionment" [@"24:00:00 December 31, Current Year"];

    END;

    RULE                 "Final CA Annual Use - Div Req";
    DESCRIPTION          "Calculates projected annual water use for California after all schedule adjustments. ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    BEGIN

      $ "AnnualWaterUse.CaTotalAnnual" [@"24:00:00 December 31, Current Year"] := $ "California_CU_Forecast1.IID" [@"24:00:00 December 31, Current Year"] + $ "AnnualWaterUse.P123bTotalAnnual" [@"24:00:00 December 31, Current Year"] + $ "AnnualWaterUse.CaNoPVYPIIDTotalAnnual" [@"24:00:00 December 31, Current Year"];

    END;

    RULE                 "Final AZ Overrun - Div Req";
    DESCRIPTION          "Calculates projected overrun or underrun for Arizona after all schedule adjustments. ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    BEGIN

      $ "AnnualWaterUse.AzOverrun" [@"24:00:00 December 31, Current Year"] := $ "AnnualWaterUse.AzTotalAnnual" [@"24:00:00 December 31, Current Year"] - $ "AnnualWaterUse.Arizona_Apportionment" [@"24:00:00 December 31, Current Year"];

    END;

    RULE                 "Final AZ Annual Use - Div Req";
    DESCRIPTION          "Calculates projected annual water use for Arizona after all schedule adjustments. ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    BEGIN

      $ "AnnualWaterUse.AzTotalAnnual" [@"24:00:00 December 31, Current Year"] := $ "ForecastUse.CAPAnnualFC" [@"24:00:00 December 31, Current Year"] + $ "AnnualWaterUse.AzNoCAPTotalAnnual" [@"24:00:00 December 31, Current Year"];

    END;

    RULE                 "Final NV Overrun - Div Req";
    DESCRIPTION          "Calculates projected overrun or underrun for Nevada after all schedule adjustments. ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    BEGIN

      $ "AnnualWaterUse.NVOverrun" [@"24:00:00 December 31, Current Year"] := $ "AnnualWaterUse.NvTotalAnnual" [@"24:00:00 December 31, Current Year"] - $ "AnnualWaterUse.Nevada_Apportionment" [@"24:00:00 December 31, Current Year"];

    END;

    RULE                 "Compute Lower Basin Energy";
    DESCRIPTION          "This rule must fire after all schedule adjustments have been made, which is why it is in the highest priority polict group.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    BEGIN

      $ "Lower Basin Energy.Computed Davis Energy Using Input Eff" [] := $ "Lower Basin Energy.Input Davis Efficiency" [] * "FlowToVolume"( $ "Mohave.Turbine Release" [], @"t" ) * "Compute Head as a Function of Turbine Release"( $ "Mohave.Turbine Release" [] ) * 9789.00000000 "newton" / ( ( 1.00000000 "m" * 1.00000000 "m" ) * 1.00000000 "m" );

      $ "Lower Basin Energy.Computed Davis Head using Turbine Release" [] := "Compute Head as a Function of Turbine Release"( $ "Mohave.Turbine Release" [] );

      $ "Lower Basin Energy.Davis KWH per AF" [] := $ "Lower Basin Energy.Input Davis Efficiency" [] * "FlowToVolume"( $ "Mohave.Turbine Release" [], @"t" ) * "Compute Head as a Function of Turbine Release"( $ "Mohave.Turbine Release" [] ) * 9789.00000000 "newton" / ( ( 1.00000000 "m" * 1.00000000 "m" ) * 1.00000000 "m" ) / "FlowToVolume"( $ "Mohave.Turbine Release" [], @"t" ) * 1.00000000 "ft" * 1.00000000 "ft";

      $ "Lower Basin Energy.Computed Parker Energy Using Input Eff" [] := $ "Lower Basin Energy.Input Parker Efficiency" [] * "FlowToVolume"( $ "Havasu.Turbine Release" [], @"t" ) * $ "Havasu.Operating Head" [] * 9789.00000000 "newton" / ( ( 1.00000000 "m" * 1.00000000 "m" ) * 1.00000000 "m" );

      $ "Lower Basin Energy.Computed PD Project Energy Using Peak Base Power Calc" [] := $ "Mohave.Energy" [] + $ "Havasu.Energy" [] / 2.00000000;

      $ "Lower Basin Energy.Computed PD Project Energy Using Input Eff" [] := $ "Lower Basin Energy.Input Davis Efficiency" [] * "FlowToVolume"( $ "Mohave.Turbine Release" [], @"t" ) * $ "Mohave.Operating Head" [] * 9789.00000000 "newton" / ( ( 1.00000000 "m" * 1.00000000 "m" ) * 1.00000000 "m" ) + $ "Lower Basin Energy.Input Parker Efficiency" [] * "FlowToVolume"( $ "Havasu.Turbine Release" [], @"t" ) * $ "Havasu.Operating Head" [] * 9789.00000000 "newton" / ( ( 1.00000000 "m" * 1.00000000 "m" ) * 1.00000000 "m" ) / 2.00000000;

    END;

  END;

  POLICY_GROUP   "FloodControl";
  DESCRIPTION    "This policy group contains all the rules required to simulate Lake Mead/Hoover Dam flood control operations. Flood control operations are based on the USACE Water Control Manual for Flood Control: Hoover Dam and Lake Mead Colorado River, December 1982 (Flood Control Manual)";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Compute LC Dam Capacity";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 4.00000000;
    BEGIN

      $ "Mead.Power" [] := $ "EnergyInfo.EffectiveHooverCapacity" [] * $ "Mead.Power Plant Cap Fraction" [];

      $ "Mohave.Power" [] := $ "Lower Basin Energy.Davis_Power_Capacity" [] * $ "Mohave.Power Plant Cap Fraction" [];

      $ "Havasu.Power" [] := $ "Lower Basin Energy.Parker_Power_Capacity" [] * $ "Havasu.Power Plant Cap Fraction" [];

    END;

    RULE                 "Compute Effective Hoover Capacity Regression";
    DESCRIPTION          "This Rule is used to set the EnergyInfo.EffectiveHooverCapacity so that it can go out to 60 weeks.  The regression equation provided is from the LC BoR office and can be adjusted using this rule.  ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    BEGIN

      IF_STATEMENT (( NOT "IsMRM"(  ) ) COMMENTED_BY "This check determines if a run is a deterministic run or an MRM run and the data comes<br>out of the Ensemble Forecast Sheet. TP 3/28/2013") THEN
            IF_STATEMENT ("IsInput"( $ "EnergyInfo.EffectiveHooverCapacityInput", @"t" )) THEN
            $ "EnergyInfo.EffectiveHooverCapacity" [@"t"] := $ "EnergyInfo.EffectiveHooverCapacityInput" [@"t"];

      ELSE
            WITH_STATEMENT (NUMERIC elevMead = $ "Mead.Pool Elevation" [@"t"]) DO
            $ "EnergyInfo.EffectiveHooverCapacity" [@"t"] := IF ( elevMead >= 1170.00000000 "feet" )
   THEN
      2074.00000000 "MW"
   ELSE
      ( elevMead * ( 5.64540000 "MW" / 1.00000000 "foot" ) - 4530.50000000 "MW" )
   ENDIF;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      ELSE
            WITH_STATEMENT (NUMERIC elevMead = $ "Mead.Pool Elevation" [@"t"]) DO
            $ "EnergyInfo.EffectiveHooverCapacity" [@"t"] := IF ( elevMead >= 1170.00000000 "feet" )
   THEN
      2074.00000000 "MW"
   ELSE
      ( elevMead * ( 5.64540000 "MW" / 1.00000000 "foot" ) - 4530.50000000 "MW" )
   ENDIF;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      IF_STATEMENT (NOT "IsInput"( $ "Mead.Power Plant Cap Fraction", @"t" )) THEN
            $ "Mead.Power Plant Cap Fraction" [@"t"] := $ "Mead.Power Plant Cap Fraction" [@"t - 12"];

      END_IF_STATEMENT;

    END;

    RULE                 "Mead Space Building";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND NOT IsNaN $ "Mead.Storage" [] AND @"t" > @"24:00:00 July Max DayOfMonth, Current Year";
    BEGIN

      IF_STATEMENT ($ "Mead.Storage" [] > "ComputeTargetStorage"(  )) THEN
            $ "Mead.Outflow" [] := "Max"( "ComputeOutflowAtGivenStorage"( % "Mead", "ComputeTargetStorage"(  ) ), $ "Mead.Outflow" [] );

      END_IF_STATEMENT;

      $ "FloodControlOutput.Flood Control Flag" [] := IF ( IsNaN $ "FloodControlOutput.Flood Control Flag" [] )
   THEN
      IF ( $ "Mead.Storage" [] > "ComputeTargetStorage"(  ) )
      THEN
         1.00000000
      ELSE
         0.00000000
      ENDIF
   ENDIF;

    END;

    RULE                 "Mead Flood Control Release";
    DESCRIPTION          "This rule checks that the release from Mead computed for downstream demands is large<br>enough to satisfy flood control during the runoff season. If not, Mead Outflow is reset to the <br>required flood control release which was previously calculated in the <Set Flood Control Release> <br>rule and stored as FloodControlOutput.FCrelease. The flood control flag is also set to 1 : <br>this will cause the system to solve downstream and eventually force more water out of Havasu<br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" AND NOT IsNaN $ "Mead.Outflow" [] AND "GetRunCycleIndex"(  ) >= 3.00000000;
    BEGIN

      IF_STATEMENT ($ "Mead.Outflow" [] < $ "FloodControlOutput.FCrelease" []) THEN
            $ "Mead.Outflow" [] := "Max"( $ "FloodControlOutput.FCrelease" [], $ "Mead.Outflow" [] );

      END_IF_STATEMENT;

      $ "FloodControlOutput.Flood Control Flag" [] := IF ( $ "Mead.Outflow" [] < $ "FloodControlOutput.FCrelease" [] )
   THEN
      1.00000000
   ELSE
      0.00000000
   ENDIF;

    END;

    RULE                 "Mead Exclusive Flood Control Space";
    DESCRIPTION          "<br>  This rule ensures that Mead can not violate the 1.5 maf space requirement at any time of the year<br>  Although this is the highest priority rule, we don't want it to fire until the other flood control procedures<br>  have had their shot<br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT IsNaN $ "FloodControlOutput.Flood Control Flag" [] AND NOT IsNaN $ "Mead.Storage" [] AND "GetRunCycleIndex"(  ) >= 3.00000000;
    BEGIN

      IF_STATEMENT ($ "Mead.Storage" [] >= "ComputeMinimumSpace"( % "Mead" )) THEN
            $ "Mead.Outflow" [] := "ComputeOutflowAtGivenStorage"( % "Mead", "ComputeMinimumSpace"( % "Mead" ) );

      END_IF_STATEMENT;

      $ "FloodControlOutput.Exclusive Space Flag" [] := IF ( $ "Mead.Storage" [] >= "ComputeMinimumSpace"( % "Mead" ) )
   THEN
      1.00000000
   ELSE
      0.00000000
   ENDIF;

      PRINT "Flood Control due to violating Exclusive Flood Control Space: Mead Storage reset";

    END;

    RULE                 "Set Flood Control Release";
    DESCRIPTION          "<br> This rule computes the Mead release required by runoff based flood control<br> and stores the value on the FloodControlOutput data object as FCrelease. <br> The rule applies during year round.<br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "FloodControlOutput.FCrelease" [] AND "GetRunCycleIndex"(  ) >= 3.00000000;
    BEGIN

      $ "FloodControlOutput.FCrelease" [] := IF ( @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" )
   THEN
      GET @INDEX 0.00000000 FROM "ForecastRunoffSeason "(  )
   ELSE
      "ComputeTargetStorageRelease"(  )
   ENDIF;

      PRINT IF ( @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" )
   THEN
      "entering Runoff Forecast Season routine for" CONCAT "GetMonthAsString"( @"t" )
   ELSE
      "Mead Flood Control Release is not computed in" CONCAT "GetMonthAsString"( @"t" )
   ENDIF;

    END;

    RULE                 "Set Without Release";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" AND IsNaN $ "FloodControlOutput.Withoutrel" [] AND "GetRunCycleIndex"(  ) >= 3.00000000;
    BEGIN

      $ "FloodControlOutput.Forecas" [] := "ForecastMeadInflow"(  );

      $ "FloodControlOutput.Withoutrel" [] := "ForecastMeadInflow"(  ) - "AvailableSpace"( % "Mead" ) - "AvailableSpace"( % "Powell" ) + $ "MeadFloodControlData.MinSpace" [0.00000000, 0.00000000] - "DeltaBankStorage"(  ) - "FloodControlEvap"( % "Mead" ) - "FloodControlEvap"( % "Powell" ) - $ "FloodControlOutput.Consnev" [];

    END;

    RULE                 "Set Effective Space";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "FloodControlOutput.UBEffective" [];
    BEGIN

      $ "FloodControlOutput.UBEffective" [] := IF ( @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" )
   THEN
      "Min"( $ "FloodControlOutput.FGuse" [], $ "FloodControlOutput.FGpred" [] ) + "Min"( $ "FloodControlOutput.BMuse" [], $ "FloodControlOutput.BMpred" [] ) + "Min"( $ "FloodControlOutput.NAVuse" [], $ "FloodControlOutput.NAVpred" [] )
   ELSE
      0.00000000 "acre-feet"
   ENDIF;

    END;

    RULE                 "Set Consnev";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" AND IsNaN $ "FloodControlOutput.Withoutrel" [];
    BEGIN

      $ "FloodControlOutput.Consnev" [] := "SouthernNevConsumed"( "GetMonthlyDatelist"( @"t", @"24:00:00 July Max DayOfMonth, Current Year" ) );

    END;

    RULE                 "Set Forecast Data";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "FloodControlOutput.Withoutrel" [];
    BEGIN

      $ "FloodControlOutput.FGuse" [] := IF ( @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" )
   THEN
      "SumSlotVolume"( $ "FlamingGorgeInflow.Unregulated", "GetMonthlyDatelist"( @"t", @"24:00:00 July Max DayOfMonth, Current Year" ) ) - "SumSlotVolume"( $ "FlamingGorge.Outflow", "GetMonthlyDatelist"( @"t", @"24:00:00 July Max DayOfMonth, Current Year" ) )
   ELSE
      0.00000000 "acre-feet"
   ENDIF;

      $ "FloodControlOutput.FGpred" [] := "GetLiveCapacity"( % "FlamingGorge" ) - $ "FlamingGorge.Storage" [@"t - 1"] + ( "GetLiveCapacity"( % "Fontenelle" ) - $ "Fontenelle.Storage" [@"t - 1"] );

      $ "FloodControlOutput.BMuse" [] := IF ( @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" )
   THEN
      "SumSlotVolume"( $ "BlueMesaInflow.Unregulated", "GetMonthlyDatelist"( @"t", @"24:00:00 July Max DayOfMonth, Current Year" ) ) - "SumSlotVolume"( $ "BlueMesa.Outflow", "GetMonthlyDatelist"( @"t", @"24:00:00 July Max DayOfMonth, Current Year" ) )
   ELSE
      0.00000000 "acre-feet"
   ENDIF;

      $ "FloodControlOutput.BMpred" [] := "GetLiveCapacity"( % "BlueMesa" ) - $ "BlueMesa.Storage" [@"t - 1"];

      $ "FloodControlOutput.NAVuse" [] := IF ( @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" )
   THEN
      "SumSlotVolume"( $ "Navajo.Inflow", "GetMonthlyDatelist"( @"t", @"24:00:00 July Max DayOfMonth, Current Year" ) ) - "SumSlotVolume"( $ "Navajo.Outflow", "GetMonthlyDatelist"( @"t", @"24:00:00 July Max DayOfMonth, Current Year" ) )
   ELSE
      0.00000000 "acre-feet"
   ENDIF;

      $ "FloodControlOutput.NAVpred" [] := "GetLiveCapacity"( % "Navajo" ) - $ "Navajo.Storage" [@"t - 1"];

      $ "FloodControlOutput.MeadPred" [] := "AvailableSpace"( % "Mead" );

      $ "FloodControlOutput.MeadCredEff" [] := "AvailableSpace"( % "Mead" );

      $ "FloodControlOutput.PowellPred" [] := "AvailableSpace"( % "Powell" );

      $ "FloodControlOutput.PowellCredEff" [] := "AvailableSpace"( % "Powell" );

      $ "FloodControlOutput.Deltabs" [] := "DeltaBankStorage"(  );

      $ "FloodControlOutput.Evapmd" [] := "FloodControlEvap"( % "Mead" );

      $ "FloodControlOutput.Evapow" [] := "FloodControlEvap"( % "Powell" );

    END;

    RULE                 "Set Schedule Release";
    DESCRIPTION          "<br> This rule copies the initial Mead release needed to meet downstream demands<br> to the FloodControlOutput data object in slot schdrel. <br> The value should only be reported the first time Mead calculates its outflow <br> based on downstream demands. It should never be overwritten by another rule. <br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "Lower Basin Output.MeadSchedRel" [] AND NOT IsNaN $ "Mead.Outflow" [] AND "GetRunCycleIndex"(  ) == 3.00000000;
    BEGIN

      $ "Lower Basin Output.MeadSchedRel" [] := $ "Mead.Outflow" [];

    END;

  END;

  POLICY_GROUP   "ICS Accounting and Releases";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Flood Control ICS Reduction";
    DESCRIPTION          "This rule will use the Flood Control Volume to reduce the amount of Extraordinary Conservation ICS for each state. If the Flood Control Volume is greater than the volume of EC ICS water for all of the states and EC Delivery for each state, the balance of EC water is taken to 0 AF for each state. If the volume of FC water is less than the total EC volume, then the volume reduced from each state will be proportional to the volume that each state has when the Flood Control occurs. This rule assigns the new values of EC ICS water for California, Nevada, and Arizona and also re calculates and assignes the Total ICS Volumes for each state. TP 11/4/2014";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND NaNToZero ( $ "FloodControlOutput.Flood Control Flag" [@"t"] ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" );
    BEGIN

      WITH_STATEMENT (NUMERIC floodControlVol = $ "FloodControlOutput.FCrelease" [@"t"]) DO
            WITH_STATEMENT (LIST stateECBalances = "FloodControlECICSBalance"( "FlowToVolume"( floodControlVol, @"t" ) )) DO
            $ "ICS Credits.ExtraordinaryConservationICS_CA" ["Dec31ofYear"( @"t" )] := GET @INDEX 3.00000000 FROM stateECBalances;

            $ "ICS Credits.ExtraordinaryConservationICS_NV" ["Dec31ofYear"( @"t" )] := GET @INDEX 4.00000000 FROM stateECBalances;

            $ "ICS Credits.ExtraordinaryConservationICS_AZ" ["Dec31ofYear"( @"t" )] := GET @INDEX 5.00000000 FROM stateECBalances;

            $ "ICS Credits.TotalICS_CA" ["Dec31ofYear"( @"t" )] := GET @INDEX 6.00000000 FROM stateECBalances;

            $ "ICS Credits.TotalICS_NV" ["Dec31ofYear"( @"t" )] := GET @INDEX 7.00000000 FROM stateECBalances;

            $ "ICS Credits.TotalICS_AZ" ["Dec31ofYear"( @"t" )] := GET @INDEX 8.00000000 FROM stateECBalances;

            $ "ICS Credits.AnnualDeliveryEC_CA" ["Dec31ofYear"( @"t" )] := GET @INDEX 0.00000000 FROM stateECBalances;

            $ "ICS Credits.AnnualDeliveryEC_NV" ["Dec31ofYear"( @"t" )] := GET @INDEX 1.00000000 FROM stateECBalances;

            $ "ICS Credits.AnnualDeliveryEC_AZ" ["Dec31ofYear"( @"t" )] := GET @INDEX 2.00000000 FROM stateECBalances;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "California ICS Accounting and Releases";
    DESCRIPTION          "This Rule assigns the values for the California ICS.  The function &quot;ICSAccountingForCA&quot; calculates the delivery and annual values based on input<br>creation values, and assigns the appropriate slots for California ICS.  The rule also re-sets the MWD Diversion request each  month to the percentage<br>that is applied each month to an average Shortage delivery pattern for a year.  The rule only fires in January or the Start timestep. TP 9/10/2014";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year" OR @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" );
    BEGIN

      WITH_STATEMENT (LIST caICSValues = "ICSAccountingForCA"(  )) DO
          DESCRIPTION          "CA Extraordinary Conservation ICS Delivery";
      $ "ICS Credits.AnnualDeliveryEC_CA" ["Dec31ofYear"( @"t" )] := GET @INDEX 0.00000000 FROM caICSValues;

          DESCRIPTION          "CA System Efficiency ICS Delivery";
      $ "ICS Credits.AnnualDeliverySysEff_CA" ["Dec31ofYear"( @"t" )] := GET @INDEX 1.00000000 FROM caICSValues;

          DESCRIPTION          "CA Bi National ICS Delivery";
      $ "ICS Credits.AnnualDeliveryBiNat_CA" ["Dec31ofYear"( @"t" )] := GET @INDEX 2.00000000 FROM caICSValues;

          DESCRIPTION          "CA Extraordinary Conservation ICS Creation";
      $ "ICS Credits.AnnualCreationEC_CA" ["Dec31ofYear"( @"t" )] := GET @INDEX 3.00000000 FROM caICSValues;

          DESCRIPTION          "CA Extraordinary Conservation ICS";
      $ "ICS Credits.ExtraordinaryConservationICS_CA" ["Dec31ofYear"( @"t" )] := GET @INDEX 4.00000000 FROM caICSValues;

          DESCRIPTION          "CA System Efficiency ICS";
      $ "ICS Credits.SystemEfficiencyICS_CA" ["Dec31ofYear"( @"t" )] := GET @INDEX 5.00000000 FROM caICSValues;

          DESCRIPTION          "CA Bi National ICS";
      $ "ICS Credits.BiNationalICS_CA" ["Dec31ofYear"( @"t" )] := GET @INDEX 6.00000000 FROM caICSValues;

          DESCRIPTION          "CA Total ICS";
      $ "ICS Credits.TotalICS_CA" ["Dec31ofYear"( @"t" )] := GET @INDEX 7.00000000 FROM caICSValues;

          INACTIVE    DESCRIPTION          "Adjust the MWD Diversion Request to get more or less release out of Lake Mead <br>that matches the values that were just set for ICS. ";
      FOREACH (DATETIME date IN "DateMax"( @"24:00:00 January Max DayOfMonth, Current Year", @"t" ) TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            $ "MWDDiversion:MWD.Diversion Requested" [date] := $ "MWDDiversion:MWD.Diversion Requested" [date] + ( - GET @INDEX 10.00000000 FROM caICSValues ) COMMENTED_BY "Over Delivery " * $ "Shortage.MonthlyPercents" ["GetMonth"( date ) - 1.00000000, "Average"] / 1.00000000 "month";

      ENDFOREACH;

      END_WITH_STATEMENT;

    END;

    RULE                 "Nevada Banking";
    DESCRIPTION          "This rule assigns the Banked Storage from NV in CA and AZ for each year.  As of implementation Unbanked water from CA and AZ is 0 af<br>and will continue to be for the foreseable future.  The values of 0 af are input on those slots.  If logic is used to solve for those, then<br>logic will have to go into this rule where appropriate. <br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year" OR @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" );
    BEGIN

      WITH_STATEMENT (NUMERIC unusedNV = IF ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 )
   THEN
      0.00000000 "acre-ft"
   ELSE
      300000.00000000 "acre-ft" - $ "AnnualWaterUse.Nevada_Apportionment" ["Dec31ofYear"( @"t" )]
   ENDIF) DO
          DESCRIPTION          "Right now, all unused NV water is going to CA Banking, more logic will  have to go <br>In the following to With Statements to get that figured out. ";
      WITH_STATEMENT (NUMERIC nvBankedCA = IF ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 )
   THEN
      0.00000000 "acre-ft"
   ELSE
      unusedNV
   ENDIF) DO
            WITH_STATEMENT (NUMERIC nvBankedAZ = IF ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 )
   THEN
      0.00000000 "acre-ft"
   ELSE
      0.00000000 "acre-ft"
   ENDIF) DO
          DESCRIPTION          "When the NV unbanked to CA logic needs to be improved, the next two<br>with statements is where that should happen, currently the values for<br>unbanked to CA and NV will be 0 af";
      WITH_STATEMENT (NUMERIC nvUnbankedCA = 0.00000000 "acre-ft") DO
            WITH_STATEMENT (NUMERIC nvUnbankedAZ = 0.00000000 "acre-ft") DO
          DESCRIPTION          "Annual Nevada Water not Used";
      $ "ICS Credits.AnnualNevadaUnused" ["Dec31ofYear"( @"t" )] := unusedNV;

            $ "ICS Credits.CumulativeNVBankedinCA" ["Dec31ofYear"( @"t" )] := $ "ICS Credits.CumulativeNVBankedinCA" [@"24:00:00 December Max DayOfMonth, Previous Year"] + nvBankedCA - nvUnbankedCA;

            $ "ICS Credits.CumulativeNVBankedinAZ" ["Dec31ofYear"( @"t" )] := $ "ICS Credits.CumulativeNVBankedinAZ" [@"24:00:00 December Max DayOfMonth, Previous Year"] + nvBankedAZ - nvUnbankedAZ;

            $ "ICS Credits.AnnualNVBankedinCA" ["Dec31ofYear"( @"t" )] := nvBankedCA;

            $ "ICS Credits.AnnualNVBankedinAZ" ["Dec31ofYear"( @"t" )] := nvBankedAZ;

            $ "ICS Credits.AnnualNVRecoverableCA" ["Dec31ofYear"( @"t" )] := nvBankedCA * 0.66666600;

            $ "ICS Credits.AnnualNVRecoverableAZ" ["Dec31ofYear"( @"t" )] := nvBankedAZ;

            $ "ICS Credits.AnnualNVUnBankedFromCA" ["Dec31ofYear"( @"t" )] := nvUnbankedCA;

            $ "ICS Credits.AnnualNVUnbankedFromAZ" ["Dec31ofYear"( @"t" )] := nvUnbankedAZ;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "Nevada ICS Accounting and Releases";
    DESCRIPTION          "This Rule assigns the values for the Nevada ICS.  The function &quot;ICSAccountingForNV&quot; calculates the annual values based on input<br>creation values, delivery values, and assigns the appropriate slots for Nevada ICS.  The rule also re-sets the SNWP Diversion request each  month to the percentage that is applied each month to an average Shortage delivery pattern for a year.  The rule only fires in January or the Start timestep. TP 9/11/2014";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year" OR @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" );
    BEGIN

      WITH_STATEMENT (LIST nvICSValues = "ICSAccountingForNV"(  )) DO
          DESCRIPTION          "Creation of Trib ICS";
      $ "ICS Credits.AnnualCreationTribICS_NV" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 0.00000000 FROM nvICSValues );

          DESCRIPTION          "Creation of Trib DSS";
      $ "ICS Credits.AnnualCreationTribDSS_NV" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 1.00000000 FROM nvICSValues );

          DESCRIPTION          "NV System Efficiency ICS";
      $ "ICS Credits.SystemEfficiencyICS_NV" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 2.00000000 FROM nvICSValues );

          DESCRIPTION          "NV Extraordinary Conservation ICS";
      $ "ICS Credits.ExtraordinaryConservationICS_NV" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 3.00000000 FROM nvICSValues );

          DESCRIPTION          "NV Tributary DSS ICS";
      $ "ICS Credits.TributaryDSS_NV" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 4.00000000 FROM nvICSValues );

          DESCRIPTION          "NV Imported DSS ICS";
      $ "ICS Credits.ImportedDSS_NV" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 5.00000000 FROM nvICSValues );

          DESCRIPTION          "NV Bi National ICS";
      $ "ICS Credits.BiNationalICS_NV" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 6.00000000 FROM nvICSValues );

          DESCRIPTION          "NV Total ICS";
      $ "ICS Credits.TotalICS_NV" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 7.00000000 FROM nvICSValues );

          DESCRIPTION          "Delivery of Trib DSS NV";
      $ "ICS Credits.AnnualDeliveryTribDSS_NV" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 8.00000000 FROM nvICSValues );

          DESCRIPTION          "Delivery of Imp DSS NV";
      $ "ICS Credits.AnnualDeliveryImpDSS_NV" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 9.00000000 FROM nvICSValues );

          DESCRIPTION          "Creation of Imp ICS ";
      $ "ICS Credits.AnnualCreationImpICS_NV" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 10.00000000 FROM nvICSValues );

          DESCRIPTION          "Creation of IMP DSS";
      $ "ICS Credits.AnnualCreationImpDSS_NV" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 11.00000000 FROM nvICSValues );

          DESCRIPTION          "Imported ICS NV";
      $ "ICS Credits.ImportedICS_NV" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 12.00000000 FROM nvICSValues );

          DESCRIPTION          "Tributary ICS NV";
      $ "ICS Credits.TributaryICS_NV" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 13.00000000 FROM nvICSValues );

          INACTIVE    DESCRIPTION          "Adjust the Diversion and Depletion Request from Lake Mead that is appropriate<br>for the deliveries of ICS to Nevada that match the set Logic above. ";
      FOREACH (DATETIME date IN "DateMax"( @"24:00:00 January Max DayOfMonth, Current Year", @"t" ) TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            FOREACH (SLOT slot IN { $ "PumpingFromLakeMead:SNWP.Diversion Requested" , $ "PumpingFromLakeMead:SNWP.Depletion Requested" }) DO
            slot [date] := $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date] + ( ( GET @INDEX 8.00000000 FROM nvICSValues ) - ( GET @INDEX 9.00000000 FROM nvICSValues ) ) * $ "Shortage.MonthlyPercents" ["GetMonth"( date ) - 1.00000000, "Average"] / 1.00000000 "month";

      ENDFOREACH;

      ENDFOREACH;

      END_WITH_STATEMENT;

    END;

    RULE                 "Arizona ICS Accounting and Releases";
    DESCRIPTION          "This Rule assigns the values for the Arizona ICS.  The function &quot;ICSAccountingForAZ&quot; calculates the delivery and annual values based on input<br>creation values, and assigns the appropriate slots for Arizona ICS.  The rule also re-sets the CAP Diversion request each  month to the percentage<br>that is applied each month to an average Shortage delivery pattern for a year.  The rule only fires in January or the Start timestep. TP 9/10/2014";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year" OR @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" );
    BEGIN

      WITH_STATEMENT (LIST azICSValues = "ICSAccountingForAZ"(  )) DO
          DESCRIPTION          "AZ Extraordinary Conservation ICS Delivery";
      $ "ICS Credits.AnnualDeliveryEC_AZ" ["Dec31ofYear"( @"t" )] := GET @INDEX 0.00000000 FROM azICSValues;

          DESCRIPTION          "AZ System Efficiency ICS Delivery";
      $ "ICS Credits.AnnualDeliverySysEff_AZ" ["Dec31ofYear"( @"t" )] := GET @INDEX 1.00000000 FROM azICSValues;

          DESCRIPTION          "AZ Bi National ICS Delivery";
      $ "ICS Credits.AnnualDeliveryBiNat_AZ" ["Dec31ofYear"( @"t" )] := GET @INDEX 2.00000000 FROM azICSValues;

          DESCRIPTION          "AZ Extraordinary Conservation ICS";
      $ "ICS Credits.ExtraordinaryConservationICS_AZ" ["Dec31ofYear"( @"t" )] := GET @INDEX 3.00000000 FROM azICSValues;

          DESCRIPTION          "AZ System Efficiency ICS";
      $ "ICS Credits.SystemEfficiencyICS_AZ" ["Dec31ofYear"( @"t" )] := GET @INDEX 4.00000000 FROM azICSValues;

          DESCRIPTION          "AZ Bi National ICS";
      $ "ICS Credits.BiNationalICS_AZ" ["Dec31ofYear"( @"t" )] := GET @INDEX 5.00000000 FROM azICSValues;

          DESCRIPTION          "AZ Total ICS";
      $ "ICS Credits.TotalICS_AZ" ["Dec31ofYear"( @"t" )] := GET @INDEX 6.00000000 FROM azICSValues;

          DESCRIPTION          "Adjust the CAP Diversion Request to get more water out of Lake Mead <br>that matches the values that were just set for ICS. ";
      FOREACH (DATETIME date IN "DateMax"( @"24:00:00 January Max DayOfMonth, Current Year", @"t" ) TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            $ "CAPDiversion.Total Diversion Requested" [date] := $ "CAPDiversion.Total Diversion Requested" [date] + "VolumeToFlow"( ( ( GET @INDEX 7.00000000 FROM azICSValues ) - ( GET @INDEX 8.00000000 FROM azICSValues ) ) COMMENTED_BY "Deliveries minus creations" * $ "Shortage.MonthlyPercents" ["GetMonth"( date ) - 1.00000000, "Average"], date );

      ENDFOREACH;

      END_WITH_STATEMENT;

    END;

  END;

  POLICY_GROUP   "Lower Basin Demand Variability";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Reset Monthly Forecast SNWP LC Demand Variability";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) AND NaNToZero ( $ "Surplus.Surplus Flag" ["Dec31ofYear"( @"t" )] ) == 0.00000000 AND NaNToZero ( $ "Surplus.Quantified Surplus Flag" ["Dec31ofYear"( @"t" )] ) == 0.00000000 AND NaNToZero ( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) == 0.00000000 AND NaNToZero ( $ "Surplus.Domestic Surplus Flag" ["Dec31ofYear"( @"t" )] ) == 0.00000000 AND NaNToZero ( $ "Surplus.Flood Control Surplus Flag" ["Dec31ofYear"( @"t" )] ) == 0.00000000;
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            FOREACH (SLOT slot IN { $ "PumpingFromLakeMead:SNWP.Diversion Requested" , $ "PumpingFromLakeMead:SNWP.Depletion Requested" }) DO
            slot [date] := $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date] * "MeadPumpingDemandVariabilityFactor"( date );

      ENDFOREACH;

            $ "LowerBasinDemandVariability.AbvHooverTriggerSet" ["Dec31ofYear"( date )] := IF ( "MeadPumpingDemandVariabilityFactor"( date ) == 1.00000000 )
   THEN
      0.00000000
   ELSE
      IF ( "MeadPumpingDemandVariabilityFactor"( date ) == 0.95000000 )
      THEN
         1.00000000
      ELSE
         - 1.00000000
      ENDIF
   ENDIF;

      ENDFOREACH;

    END;

    RULE                 "Reset Monthly Forecast CAP LC Demand Variability";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) AND NaNToZero ( $ "Surplus.Surplus Flag" ["Dec31ofYear"( @"t" )] ) == 0.00000000 AND NaNToZero ( $ "Surplus.Quantified Surplus Flag" ["Dec31ofYear"( @"t" )] ) == 0.00000000 AND NaNToZero ( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) == 0.00000000 AND NaNToZero ( $ "Surplus.Domestic Surplus Flag" ["Dec31ofYear"( @"t" )] ) == 0.00000000 AND NaNToZero ( $ "Surplus.Flood Control Surplus Flag" ["Dec31ofYear"( @"t" )] ) == 0.00000000;
    BEGIN

      FOREACH (DATETIME date IN "GetFirstDate"( @"t" ) TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            $ "CAPDiversion.Total Diversion Requested" [date] := $ "CAPDiversion.Total Diversion Requested" [date] * "CAPDemandVariabilityFactor"( date );

          INACTIVE      $ "LowerBasinDemandVariability.AbvHooverTriggerSet" ["Dec31ofYear"( date )] := IF ( "CAPDemandVariabilityFactor"( date ) == 1.00000000 )
   THEN
      0.00000000
   ELSE
      IF ( "CAPDemandVariabilityFactor"( date ) == 0.90000000 )
      THEN
         1.00000000
      ELSE
         - 1.00000000
      ENDIF
   ENDIF;

      ENDFOREACH;

    END;

    RULE                 "Reset Monthly Forecast MWD LC Demand Variability";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) AND NaNToZero ( $ "Surplus.Surplus Flag" ["Dec31ofYear"( @"t" )] ) == 0.00000000 AND NaNToZero ( $ "Surplus.Quantified Surplus Flag" ["Dec31ofYear"( @"t" )] ) == 0.00000000 AND NaNToZero ( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) == 0.00000000 AND NaNToZero ( $ "Surplus.Domestic Surplus Flag" ["Dec31ofYear"( @"t" )] ) == 0.00000000 AND NaNToZero ( $ "Surplus.Flood Control Surplus Flag" ["Dec31ofYear"( @"t" )] ) == 0.00000000;
    BEGIN

      FOREACH (DATETIME date IN "GetFirstDate"( @"t" ) TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            IF_STATEMENT (NOT date IN "GetDates"( "GetFirstDate"( @"Start Timestep" ), "Dec31ofYear"( @"Start Timestep" ), "1 Months" )) THEN
            $ "MWDDiversion:MWD.Diversion Requested" [date] := IF ( "IsMRM"(  ) AND NOT "IsSurplusOrShortage"(  ) )
   THEN
      IF ( ( $ "LowerBasinDemandVariability.PowellUnregulatedInflowTrigger" ["Dec31ofYear"( date )] > $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "PowellUnregInflow75"] ) )
      THEN
         "VolumeToFlow"( 700000.00000000 "acre-ft" * $ "Shortage.MonthlyPercents" ["GetMonth"( date ) - 1.00000000, "Equal"], date )
      ELSE
         IF ( ( $ "LowerBasinDemandVariability.PowellUnregulatedInflowTrigger" ["Dec31ofYear"( date )] < $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "PowellUnregInflow25"] ) )
         THEN
            WITH NUMERIC yearBaseMWDSchedVol = "FlowToVolume"( "SumSlot"( $ "MWDDiversion:MWD.Diversion Requested", "OffsetDate"( "Dec31ofYear"( date ), - 11.00000000, "1 Months" ), "Dec31ofYear"( date ) ), "Dec31ofYear"( date ) ) DO
               WITH NUMERIC availCalICSCredWater = $ "ICS Credits.TotalICS_CA" ["OffsetDate"( "Dec31ofYear"( date ), - 12.00000000, "1 Months" )] + yearBaseMWDSchedVol DO
                  "VolumeToFlow"( "Min"( 1100000.00000000 "acre-ft", availCalICSCredWater ) * $ "Shortage.MonthlyPercents" ["GetMonth"( date ) - 1.00000000, "Equal"], date )
               ENDWITH
            ENDWITH
         ELSE
            $ "MWDDiversion:MWD.Diversion Requested" [date]
         ENDIF
      ENDIF
   ELSE
      $ "MWDDiversion:MWD.Diversion Requested" [date]
   ENDIF;

            $ "LowerBasinDemandVariability.PowellUnregTrigSet" ["Dec31ofYear"( date )] := IF ( "IsMRM"(  ) AND NOT "IsSurplusOrShortage"(  ) )
   THEN
      IF ( ( $ "LowerBasinDemandVariability.PowellUnregulatedInflowTrigger" ["Dec31ofYear"( date )] > $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "PowellUnregInflow75"] ) )
      THEN
         1.00000000
      ELSE
         IF ( ( $ "LowerBasinDemandVariability.PowellUnregulatedInflowTrigger" ["Dec31ofYear"( date )] < $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "PowellUnregInflow25"] ) )
         THEN
            WITH NUMERIC yearBaseMWDSchedVol = "FlowToVolume"( "SumSlot"( $ "MWDDiversion:MWD.Diversion Requested", "OffsetDate"( "Dec31ofYear"( @"t" ), - 11.00000000, "1 Months" ), "Dec31ofYear"( @"t" ) ), "Dec31ofYear"( @"t" ) ) DO
               - 1.00000000
            ENDWITH
         ELSE
            0.00000000
         ENDIF
      ENDIF
   ELSE
      0.00000000
   ENDIF;

      END_IF_STATEMENT;

      ENDFOREACH;

      $ "LowerBasinDemandVariability.MWDLBDVDifference" ["Dec31ofYear"( @"t" )] := WITH NUMERIC yearBaseMWDSchedVol = "FlowToVolume"( "SumSlot"( $ "MWDDiversion:MWD.Diversion Requested", "OffsetDate"( "Dec31ofYear"( @"t" ), - 11.00000000, "1 Months" ), "Dec31ofYear"( @"t" ) ), "Dec31ofYear"( @"t" ) ) DO
      IF ( "IsMRM"(  ) AND NOT "IsSurplusOrShortage"(  ) )
      THEN
         IF ( ( $ "LowerBasinDemandVariability.PowellUnregulatedInflowTrigger" ["Dec31ofYear"( @"t" )] > $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "PowellUnregInflow75"] ) )
         THEN
            700000.00000000 "acre-ft" - yearBaseMWDSchedVol
         ELSE
            IF ( ( $ "LowerBasinDemandVariability.PowellUnregulatedInflowTrigger" ["Dec31ofYear"( @"t" )] < $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "PowellUnregInflow25"] ) )
            THEN
               WITH NUMERIC availTotalCAICSCredWater = $ "ICS Credits.TotalICS_CA" ["OffsetDate"( "Dec31ofYear"( @"t" ), - 12.00000000, "1 Months" )] + yearBaseMWDSchedVol DO
                  "Min"( 1100000.00000000 "acre-ft", availTotalCAICSCredWater ) - yearBaseMWDSchedVol
               ENDWITH
            ELSE
               0.00000000 "acre-ft"
            ENDIF
         ENDIF
      ELSE
         0.00000000 "acre-ft"
      ENDIF
   ENDWITH;

    END;

    RULE                 "LowerBasinDemandVariability 10-50-90";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) AND NaNToZero ( $ "Surplus.Surplus Flag" ["Dec31ofYear"( @"t" )] ) == 0.00000000 AND NaNToZero ( $ "Surplus.Quantified Surplus Flag" ["Dec31ofYear"( @"t" )] ) == 0.00000000 AND NaNToZero ( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) == 0.00000000 AND NaNToZero ( $ "Surplus.Domestic Surplus Flag" ["Dec31ofYear"( @"t" )] ) == 0.00000000 AND NaNToZero ( $ "Surplus.Flood Control Surplus Flag" ["Dec31ofYear"( @"t" )] ) == 0.00000000;
    BEGIN

      FOREACH (DATETIME date IN "DateMax"( @"24:00:00 January Max DayOfMonth, Current Year", @"Start Timestep" ) TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            $ "PaloVerde.Total Diversion Requested" [date] := "VolumeToFlow"( $ "California_CU_Schedules.PaloVerde" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "PVID" );

            $ "CRIR:CRIRAz.Diversion Requested" [date] := "VolumeToFlow"( $ "Arizona_CU_Schedules.CRIRAz" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "CRIRaz" );

            $ "AAC:IID.Diversion Requested" [date] := "VolumeToFlow"( $ "California_CU_Schedules.IID" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "IID" );

            $ "AAC:Coachella.Diversion Requested" [date] := "VolumeToFlow"( $ "California_CU_Schedules.Coachella" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "CVWD" );

            $ "GilaGravityMainCanal:WMIDD.Diversion Requested" [date] := "VolumeToFlow"( $ "Arizona_CU_Schedules.WMIDD" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "WMIDD" );

            $ "GilaGravityMainCanal:YCWUA.Diversion Requested" [date] := "VolumeToFlow"( $ "Arizona_CU_Schedules.YCWUA" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "YCWUA" );

            $ "GilaGravityMainCanal:YMIDD.Diversion Requested" [date] := "VolumeToFlow"( $ "Arizona_CU_Schedules.YMIDD" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "YMIDD" );

            IF_STATEMENT ("IsMRM"(  ) AND NOT "IsSurplusOrShortage"(  )) THEN
            IF_STATEMENT ($ "LowerBasinDemandVariability.LocalInflowAboveHooverTrigger" ["Dec31ofYear"( date )] > $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "SideInflowAboveHoover90"]) THEN
            $ "BelowImperialDam:GainsImpToNIB.Local Inflow" [date] := $ "LowerBasinDemandVariability.ImperialToNIBLocalInflows" [date, "Ninety"];

            $ "BelowImperialDam:Gila River.Local Inflow" [date] := $ "LowerBasinDemandVariability.GilaRiverLocalInflow" [date];

            $ "CoRivMeadToMohave:GainsAboveDavis.Local Inflow" [date] := $ "LowerBasinDemandVariability.HooverToDavisLocalInflows" [date, "Ninety"];

            $ "HavasuToImperial:GainsPkrToImp.Local Inflow" [date] := $ "LowerBasinDemandVariability.ParkerToImperialLocalInflows" [date, "Ninety"];

            $ "MWDAndCAPReach:GainsAboveParker.Local Inflow" [date] := $ "LowerBasinDemandVariability.DavisToParkerLocalInflows" [date, "Ninety"];

      ELSE
            IF_STATEMENT ($ "LowerBasinDemandVariability.LocalInflowAboveHooverTrigger" ["Dec31ofYear"( date )] < $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "SideInflowAboveHoover10"]) THEN
            $ "BelowImperialDam:GainsImpToNIB.Local Inflow" [date] := $ "LowerBasinDemandVariability.ImperialToNIBLocalInflows" [date, "Ten"];

            $ "BelowImperialDam:Gila River.Local Inflow" [date] := $ "LowerBasinDemandVariability.GilaRiverLocalInflow" [date];

            $ "CoRivMeadToMohave:GainsAboveDavis.Local Inflow" [date] := $ "LowerBasinDemandVariability.HooverToDavisLocalInflows" [date, "Ten"];

            $ "HavasuToImperial:GainsPkrToImp.Local Inflow" [date] := $ "LowerBasinDemandVariability.ParkerToImperialLocalInflows" [date, "Ten"];

            $ "MWDAndCAPReach:GainsAboveParker.Local Inflow" [date] := $ "LowerBasinDemandVariability.DavisToParkerLocalInflows" [date, "Ten"];

      ELSE
            $ "BelowImperialDam:GainsImpToNIB.Local Inflow" [date] := $ "LowerBasinDemandVariability.ImperialToNIBLocalInflows" [date, "Fifty"];

            $ "BelowImperialDam:Gila River.Local Inflow" [date] := $ "LowerBasinDemandVariability.GilaRiverLocalInflow" [date];

            $ "CoRivMeadToMohave:GainsAboveDavis.Local Inflow" [date] := $ "LowerBasinDemandVariability.HooverToDavisLocalInflows" [date, "Fifty"];

            $ "HavasuToImperial:GainsPkrToImp.Local Inflow" [date] := $ "LowerBasinDemandVariability.ParkerToImperialLocalInflows" [date, "Fifty"];

            $ "MWDAndCAPReach:GainsAboveParker.Local Inflow" [date] := $ "LowerBasinDemandVariability.DavisToParkerLocalInflows" [date, "Fifty"];

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ELSE
            $ "BelowImperialDam:GainsImpToNIB.Local Inflow" [date] := $ "LowerBasinDemandVariability.GainsImpToNIBLocalInflow" [date];

            $ "BelowImperialDam:Gila River.Local Inflow" [date] := $ "LowerBasinDemandVariability.GilaRiverLocalInflow" [date];

            $ "CoRivMeadToMohave:GainsAboveDavis.Local Inflow" [date] := $ "LowerBasinDemandVariability.GainsAboveDavisLocalInflow" [date];

            $ "HavasuToImperial:GainsPkrToImp.Local Inflow" [date] := $ "LowerBasinDemandVariability.GainsPkrToImpLocalInflow" [date];

            $ "MWDAndCAPReach:GainsAboveParker.Local Inflow" [date] := $ "LowerBasinDemandVariability.GainsAboveParkerLocalInflow" [date];

      END_IF_STATEMENT;

      ENDFOREACH;

    END;

    RULE                 "LowerBasinDemandVariability";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" );
    BEGIN

      FOREACH (DATETIME date IN "DateMax"( @"24:00:00 January Max DayOfMonth, Current Year", @"Start Timestep" ) TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            IF_STATEMENT (NOT "IsSurplusOrShortage"(  )) THEN
            $ "PaloVerde.Total Diversion Requested" [date] := "VolumeToFlow"( $ "California_CU_Schedules.PaloVerde" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "PVID" );

            $ "CRIR:CRIRAz.Diversion Requested" [date] := "VolumeToFlow"( $ "Arizona_CU_Schedules.CRIRAz" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "CRIRaz" );

            $ "AAC:IID.Diversion Requested" [date] := "VolumeToFlow"( $ "California_CU_Schedules.IID" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "IID" );

            $ "AAC:Coachella.Diversion Requested" [date] := "VolumeToFlow"( $ "California_CU_Schedules.Coachella" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "CVWD" );

            $ "GilaGravityMainCanal:WMIDD.Diversion Requested" [date] := "VolumeToFlow"( $ "Arizona_CU_Schedules.WMIDD" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "WMIDD" );

            $ "GilaGravityMainCanal:YCWUA.Diversion Requested" [date] := "VolumeToFlow"( $ "Arizona_CU_Schedules.YCWUA" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "YCWUA" );

            $ "GilaGravityMainCanal:YMIDD.Diversion Requested" [date] := "VolumeToFlow"( $ "Arizona_CU_Schedules.YMIDD" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "YMIDD" );

      END_IF_STATEMENT;

            IF_STATEMENT ("IsMRM"(  )) THEN
          DESCRIPTION          "Set Locals to Traces of Historical Side Inflows";
      $ "BelowImperialDam:GainsImpToNIB.Local Inflow" [date] := $ "LowerBasinDemandVariability.Trace_GainsImpToNIBLocalInflow" [date];

            $ "BelowImperialDam:Gila River.Local Inflow" [date] := $ "LowerBasinDemandVariability.GilaRiverLocalInflow" [date];

            $ "CoRivMeadToMohave:GainsAboveDavis.Local Inflow" [date] := $ "LowerBasinDemandVariability.Trace_GainsAboveDavisLocalInflow" [date];

            $ "HavasuToImperial:GainsPkrToImp.Local Inflow" [date] := $ "LowerBasinDemandVariability.Trace_GainsPkrToImpLocalInflow" [date];

            $ "MWDAndCAPReach:GainsAboveParker.Local Inflow" [date] := $ "LowerBasinDemandVariability.Trace_GainsAboveParkerLocalInflow" [date];

      ELSE
          DESCRIPTION          "Set Locals to 24MS Input value<br>";
      $ "BelowImperialDam:GainsImpToNIB.Local Inflow" [date] := $ "LowerBasinDemandVariability.GainsImpToNIBLocalInflow" [date];

            $ "BelowImperialDam:Gila River.Local Inflow" [date] := $ "LowerBasinDemandVariability.GilaRiverLocalInflow" [date];

            $ "CoRivMeadToMohave:GainsAboveDavis.Local Inflow" [date] := $ "LowerBasinDemandVariability.GainsAboveDavisLocalInflow" [date];

            $ "HavasuToImperial:GainsPkrToImp.Local Inflow" [date] := $ "LowerBasinDemandVariability.GainsPkrToImpLocalInflow" [date];

            $ "MWDAndCAPReach:GainsAboveParker.Local Inflow" [date] := $ "LowerBasinDemandVariability.GainsAboveParkerLocalInflow" [date];

      END_IF_STATEMENT;

      ENDFOREACH;

    END;

  END;

  POLICY_GROUP   "LB Surplus";
  DESCRIPTION    "This policy group contains the rules required to simulate Lower Basin Surplus operations. Lower Basin Surplus operations are based on the 2007 Interim Guidelines as well as IBWC Minute 319. Surplus volume entitlements are based on contracts between Reclamation and the various water users, as well as the 2007 Interim Guidelines and Minute 319.";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "FC Surplus Schedules Data Volume to Simulation Flow";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( $ "FloodControlOutput.Flood Control Flag" [] > 0.00000000 OR $ "FloodControlOutput.Exclusive Space Flag" [] > 0.00000000 ) AND IsNaN $ "Surplus.Flood Control Surplus Flag" [] AND "GetRunCycleIndex"(  ) >= 3.00000000;
    BEGIN

      FOREACH (DATETIME date IN @"24:00:00 January 31, Current Year" TO @"24:00:00 December 31, Current Year") DO
            $ "Surplus.Surplus Flag" [date] := 3.00000000;

            $ "Surplus.Flood Control Surplus Flag" [date] := 1.00000000;

            $ "LowerBasinDemandVariability.AbvHooverTriggerSet" ["Dec31ofYear"( date )] := 2.00000000;

            $ "OthersBlwImp:AzPumpersBlwImp.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "AzPumpersBlwImp" ), date );

            $ "AzPkrToImp:CibolaValleyIID.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "CibolaValleyIID" ), date );

            $ "AzPkrToImp:Parker.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "City of Parker" ), date );

            $ "GilaAndYumaUsers:GilaMonsterFarms.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "Gila Monster Farms" ), date );

            $ "CAPDiversion.Total Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "CAP" ), date );

            $ "MWDDiversion:MWD.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "MWD" ), date );

            $ "AAC:Coachella.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "Coachella" ), date );

            $ "AAC:IID.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "IID" ), date );

            $ "CaPkrToImp:CaPumpersAbvImp.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "CaPumpersAbvImp" ), date );

            $ "CaDvsToPkr:Needles.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "Needles" ), date );

            $ "MexicanTreatyDelivery:MexicoSched.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "Mexico" ), date );

            $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date] := IF ( $ "Surplus Total Annual Schedules.SNWA" [@"24:00:00 December 31, Current Year"] > $ "Nevada_CU_Forecast1.SNWP" [@"24:00:00 December 31, Current Year"] )
   THEN
      "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "SNWA" ), date )
   ENDIF;

      ENDFOREACH;

    END;

    RULE                 "Quantified Surplus Schedules Data Volume to Simulation Flow";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND @"t" == @"24:00:00 January 31, Current Year" AND IsNaN $ "Surplus.Surplus Flag" [] AND $ "Surplus.Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] > 0.00000000 "acre-feet";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "Surplus.Surplus Flag" [date] := 2.00000000;

            $ "Surplus.Quantified Surplus Flag" [date] := 1.00000000;

            $ "LowerBasinDemandVariability.AbvHooverTriggerSet" ["Dec31ofYear"( date )] := 2.00000000;

            $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date] := IF ( $ "Surplus Total Annual Schedules.SNWA" [@"24:00:00 December 31, Current Year"] > $ "Nevada_CU_Forecast1.SNWP" [@"24:00:00 December 31, Current Year"] )
   THEN
      "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "SNWA" ), date )
   ENDIF;

            $ "MWDDiversion:MWD.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "MWD" ), date );

            $ "AAC:Coachella.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "Coachella" ), date );

            $ "AAC:IID.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "IID" ), date );

            $ "OthersBlwImp:AzPumpersBlwImp.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "AzPumpersBlwImp" ), date );

            $ "GilaAndYumaUsers:GilaMonsterFarms.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "Gila Monster Farms" ), date );

            $ "AzPkrToImp:CibolaValleyIID.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "CibolaValleyIID" ), date );

            $ "AzPkrToImp:Parker.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "City of Parker" ), date );

            $ "CAPDiversion.Total Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "CAP" ), date );

      ENDFOREACH;

    END;

    RULE                 "Domestic Surplus Schedules Data Volume to Simulation Flow";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND $ "Mead.Pool Elevation" [@"24:00:00 December 31, Previous Year"] >= $ "Surplus.Domestic Surplus Trigger Elevation" [] AND IsNaN $ "Surplus.Surplus Flag" [];
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "Surplus.Surplus Flag" [date] := 1.00000000;

            $ "Surplus.Domestic Surplus Flag" [date] := 1.00000000;

            $ "LowerBasinDemandVariability.AbvHooverTriggerSet" ["Dec31ofYear"( date )] := 2.00000000;

            $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date] := IF ( $ "Surplus Total Annual Schedules.SNWA" [@"24:00:00 December 31, Current Year"] > $ "Nevada_CU_Forecast1.SNWP" [@"24:00:00 December 31, Current Year"] )
   THEN
      "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "SNWA" ), date )
   ENDIF;

            $ "MWDDiversion:MWD.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "MWD" ), date );

            $ "GilaAndYumaUsers:GilaMonsterFarms.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "Gila Monster Farms" ), date );

            $ "OthersBlwImp:AzPumpersBlwImp.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "AzPumpersBlwImp" ), date );

            $ "CAPDiversion.Total Diversion Requested" [date] := IF ( $ "Surplus Total Annual Schedules.CAP" [@"24:00:00 December 31, Current Year"] > $ "Arizona_CU_Forecast1.CAP" [@"24:00:00 December 31, Current Year"] )
   THEN
      "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "CAP" ), date )
   ENDIF;

      ENDFOREACH;

    END;

    RULE                 "Set Flood Control Surplus Schedules";
    DESCRIPTION          "If a the Flood Control or Exclusive Space Flag is on (greater than 0) this rule will fire and set the Surplus Schedules for all water users impacted by Flood Control Surplus. The computed schedules are the Total Annual Schedules for each water user, meaning Normal and Surplus schedules.  <br><br>Flood Control Surplus is in priority over Quantified Surplus Volumes. -HMG 8/2/11<br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT $ "FloodControlOutput.Flood Control Flag" [] > 0.00000000 OR $ "FloodControlOutput.Exclusive Space Flag" [] > 0.00000000 AND "GetRunCycleIndex"(  ) >= 3.00000000;
    BEGIN

      $ "Surplus Total Annual Schedules.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.CAP" [@"24:00:00 December 31, Current Year"] := 1835000.00000000 "acre-ft";

      $ "Surplus Total Annual Schedules.CibolaValleyIID" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.CibolaValleyIID" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.CibolaValleyIID" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.City of Parker" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.City of Parker" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.City of Parker" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.Gila Monster Farms" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.Gila Monster Farms" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.Gila Monster Farms" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.SNWA" [@"24:00:00 December 31, Current Year"] := $ "Nevada_CU_Forecast1.SNWP" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.SNWA Quantified and FC" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.MWD" [@"24:00:00 December 31, Current Year"] := 1250000.00000000 "acre-ft";

      $ "Surplus Total Annual Schedules.Coachella" [@"24:00:00 December 31, Current Year"] := $ "California_CU_Forecast1.Coachella" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.CA Ag" [@"24:00:00 December 31, Current Year"] * $ "Surplus.Share of CA Ag Surplus" [0.00000000, 0.00000000] + 100000.00000000 "acre-ft";

      $ "Surplus Total Annual Schedules.IID" [@"24:00:00 December 31, Current Year"] := $ "California_CU_Forecast1.IID" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.CA Ag" [@"24:00:00 December 31, Current Year"] * $ "Surplus.Share of CA Ag Surplus" [0.00000000, 1.00000000];

      $ "Surplus Total Annual Schedules.Needles" [@"24:00:00 December 31, Current Year"] := $ "California_CU_Forecast1.Needles" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.Needles" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.CaPumpersAbvImp" [@"24:00:00 December 31, Current Year"] := $ "California_CU_Forecast1.CaPumpersAbvImp" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.CaPumpersAbvImp" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.Mexico" [@"24:00:00 December 31, Current Year"] := 1700000.00000000 "acre-ft";

    END;

    RULE                 "Set Quantified Surplus Schedules";
    DESCRIPTION          "If there is a positive Quantified Surplus Volume this rule will fire and set the Total Annual Schedules for all water Users Impacted by Quantified Surplus. The Total Annual Schedules include both the Normal and Surplus Schedules. Rule fires only once per year during January. <br><br>Quantified Surplus is higher in priority than Domestic Surplus, but lower in priority than Flood Control Surplus. Therefore, this rule will override any Domestic Surplus Schedules, but may then be overriden by Flood Control Surplus Schedules if a Flood Control Surplus exists. -HMG 8/2/11";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND $ "Surplus.Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] > 0.00000000 "acre-feet";
    BEGIN

      $ "Surplus Total Annual Schedules.MWD" [@"24:00:00 December 31, Current Year"] := $ "California_CU_Forecast1.MWDDiversion" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.MWD Quantified" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.Coachella" [@"24:00:00 December 31, Current Year"] := IF ( $ "Surplus.California Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] > $ "Surplus Volume Entitlements.MWD Quantified" [@"24:00:00 December 31, Current Year"] )
   THEN
      $ "California_CU_Forecast1.Coachella" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.CA Ag" [@"24:00:00 December 31, Current Year"] * $ "Surplus.Share of CA Ag Surplus" [0.00000000, 0.00000000]
   ELSE
      $ "California_CU_Forecast1.Coachella" [@"24:00:00 December 31, Current Year"]
   ENDIF;

      $ "Surplus Total Annual Schedules.IID" [@"24:00:00 December 31, Current Year"] := IF ( $ "Surplus.California Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] > $ "Surplus Volume Entitlements.MWD Quantified" [@"24:00:00 December 31, Current Year"] )
   THEN
      $ "California_CU_Forecast1.IID" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.CA Ag" [@"24:00:00 December 31, Current Year"] * $ "Surplus.Share of CA Ag Surplus" [0.00000000, 1.00000000]
   ELSE
      $ "California_CU_Forecast1.IID" [@"24:00:00 December 31, Current Year"]
   ENDIF;

      $ "Surplus Total Annual Schedules.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.Gila Monster Farms" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.Gila Monster Farms" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.Gila Monster Farms" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.City of Parker" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.City of Parker" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.City of Parker" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.CibolaValleyIID" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.CibolaValleyIID" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.CibolaValleyIID" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.CAP" [@"24:00:00 December 31, Current Year"] := 1835000.00000000 "acre-ft" COMMENTED_BY "<assumes CAP will take a full ditch even lacking full surplus volume for interstate banking. Surplus Volume Entitlement contains actual CAP quantified surplus volume>";

      $ "Surplus Total Annual Schedules.SNWA" [@"24:00:00 December 31, Current Year"] := $ "Nevada_CU_Forecast1.SNWP" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.SNWA Quantified and FC" [@"24:00:00 December 31, Current Year"];

    END;

    RULE                 "Set Domestic Surplus Schedules - Minute 319";
    DESCRIPTION          "If a Domestic Surplus exists, meaning that Mead's Pool Elevation is greater than the Domestic Surplus Trigger, then this rule will fire in January of the Current Year and set the Total Annual Schedules for all water users impacted by Domestic Surplus.<br><br>Domestic Surplus is the lowest priority surplus, meaning that a Quantified or Flood Control Surplus will override these values.  -HMG 8/2/11";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT $ "Mead.Pool Elevation" [@"24:00:00 December 31, Previous Year"] >= $ "Surplus.Domestic Surplus Trigger Elevation" [];
    BEGIN

      $ "Surplus Total Annual Schedules.SNWA" [@"24:00:00 December 31, Current Year"] := $ "Nevada_CU_Forecast1.SNWP" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.SNWA Domestic" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.MWD" [@"24:00:00 December 31, Current Year"] := "Min"( $ "California_CU_Forecast1.MWDDiversion" [@"24:00:00 December 31, Current Year"] + 1.00000000 / 2.00000000 * $ "Surplus Volume Entitlements.MWD Domestic" [@"24:00:00 December 31, Current Year"] - $ "Mexico_CU_Forecast1.MexicoTJ" [@"24:00:00 December 31, Current Year"], 1250000.00000000 "acre-ft" - $ "Mexico_CU_Forecast1.MexicoTJ" [@"24:00:00 December 31, Current Year"] );

      $ "Surplus Total Annual Schedules.Gila Monster Farms" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.Gila Monster Farms" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.Gila Monster Farms" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.CAP" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.CAP" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.CAP Domestic" [@"24:00:00 December 31, Current Year"];

    END;

    RULE                 "Set Domestic Surplus Schedules";
    DESCRIPTION          "If a Domestic Surplus exists, meaning that Mead's Pool Elevation is greater than the Domestic Surplus Trigger, then this rule will fire in January of the Current Year and set the Total Annual Schedules for all water users impacted by Domestic Surplus.<br><br>Domestic Surplus is the lowest priority surplus, meaning that a Quantified or Flood Control Surplus will override these values.  -HMG 8/2/11";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND $ "Mead.Pool Elevation" [@"24:00:00 December 31, Previous Year"] >= $ "Surplus.Domestic Surplus Trigger Elevation" [];
    BEGIN

      $ "Surplus Total Annual Schedules.SNWA" [@"24:00:00 December 31, Current Year"] := $ "Nevada_CU_Forecast1.SNWP" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.SNWA Domestic" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.MWD" [@"24:00:00 December 31, Current Year"] := IF ( "GetYear"( @"24:00:00 January 31, Current Year" ) < 2017.00000000 )
   THEN
      1250000.00000000 "acre-ft" - $ "Mexico_CU_Forecast1.MexicoTJ" [@"24:00:00 December 31, Current Year"]
   ELSE
      "Min"( $ "California_CU_Forecast1.MWDDiversion" [@"24:00:00 December 31, Current Year"] + 250000.00000000 "acre-ft", 1250000.00000000 "acre-ft" - $ "Mexico_CU_Forecast1.MexicoTJ" [@"24:00:00 December 31, Current Year"] )
   ENDIF;

      $ "Surplus Total Annual Schedules.Gila Monster Farms" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.Gila Monster Farms" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.Gila Monster Farms" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.CAP" [@"24:00:00 December 31, Current Year"] := IF ( "GetYear"( @"24:00:00 January 31, Current Year" ) < 2017.00000000 )
   THEN
      $ "Arizona_CU_Forecast1.CAP" [@"24:00:00 December 31, Current Year"]
   ELSE
      $ "Arizona_CU_Forecast1.CAP" [@"24:00:00 December 31, Current Year"] + ( 100000.00000000 "acre-ft" - ( $ "Surplus Volume Entitlements.Gila Monster Farms" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"] ) )
   ENDIF;

    END;

    RULE                 "Set Quantified Surplus Entitlement Vols CAP and MWD";
    DESCRIPTION          "This rule distributed the volume of quantified surplus available between MWD and CAP";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND $ "Surplus.Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] > 0.00000000 "acre-feet";
    BEGIN

      $ "Surplus Volume Entitlements.MWD Quantified" [@"24:00:00 December 31, Current Year"] := IF ( $ "Surplus.California Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] > $ "Surplus Volume Entitlements.MWD Domestic" [@"24:00:00 December 31, Current Year"] )
   THEN
      1250000.00000000 "acre-ft" - $ "California_CU_Forecast1.MWDDiversion" [@"24:00:00 December 31, Current Year"]
   ELSE
      $ "Surplus Volume Entitlements.MWD Domestic" [@"24:00:00 December 31, Current Year"]
   ENDIF;

      $ "Surplus Volume Entitlements.CAP Quantified" [@"24:00:00 December 31, Current Year"] := IF ( $ "Surplus.Arizona Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] > $ "Surplus Volume Entitlements.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.Gila Monster Farms" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.CAP Domestic" [@"24:00:00 December 31, Current Year"] )
   THEN
      1835000.00000000 "acre-ft" - $ "Arizona_CU_Forecast1.CAP" [@"24:00:00 December 31, Current Year"]
   ELSE
      $ "Surplus Volume Entitlements.CAP Domestic" [@"24:00:00 December 31, Current Year"]
   ENDIF;

    END;

    RULE                 "Set Domestic and FC Surplus Entitlement Vols for MWD - Minute 319";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    BEGIN

      IF_STATEMENT (IsNaN $ "Surplus Volume Entitlements.MWD Domestic" [@"24:00:00 December 31, Current Year"]) THEN
            $ "Surplus Volume Entitlements.MWD Domestic" [@"24:00:00 December 31, Current Year"] := IF ( "GetYear"( @"24:00:00 January 31, Current Year" ) < 2017.00000000 )
   THEN
      1250000.00000000 "acre-ft" - $ "California_CU_Forecast1.MWDDiversion" [@"24:00:00 December 31, Current Year"] - 1.00000000 / 3.00000000 * $ "Mexico Shortage and Surplus.Mexico Annual Surplus" [@"24:00:00 December 31, Current Year"]
   ELSE
      IF ( $ "Surplus Volume Entitlements.CAP Domestic" [@"24:00:00 December 31, Current Year"] > 0.00000000 "acre-ft" AND $ "Surplus Volume Entitlements.SNWA Domestic" [@"24:00:00 December 31, Current Year"] > 0.00000000 "acre-ft" )
      THEN
         250000.00000000 "acre-ft" - 1.00000000 / 3.00000000 * $ "Mexico Shortage and Surplus.Mexico Annual Surplus" [@"24:00:00 December 31, Current Year"]
      ELSE
         250000.00000000 "acre-ft"
      ENDIF
   ENDIF;

      END_IF_STATEMENT;

      IF_STATEMENT (IsNaN $ "Surplus Volume Entitlements.MWD FC" [@"24:00:00 December 31, Current Year"]) THEN
            $ "Surplus Volume Entitlements.MWD FC" [@"24:00:00 December 31, Current Year"] := 1250000.00000000 "acre-ft" - $ "California_CU_Forecast1.MWDDiversion" [@"24:00:00 December 31, Current Year"];

      END_IF_STATEMENT;

    END;

    RULE                 "Set Domestic and FC Surplus Entitlement Vols for CAP - Minute 319";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    BEGIN

      IF_STATEMENT (IsNaN $ "Surplus Volume Entitlements.CAP Domestic" [@"24:00:00 December 31, Current Year"]) THEN
            $ "Surplus Volume Entitlements.CAP Domestic" [@"24:00:00 December 31, Current Year"] := IF ( "GetYear"( @"24:00:00 January 31, Current Year" ) < 2017.00000000 )
   THEN
      0.00000000 "acre-ft"
   ELSE
      100000.00000000 "acre-ft" - 1.00000000 / 3.00000000 * $ "Mexico Shortage and Surplus.Mexico Annual Surplus" [@"24:00:00 December 31, Current Year"] - ( $ "Surplus Volume Entitlements.Gila Monster Farms" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"] )
   ENDIF;

      END_IF_STATEMENT;

      IF_STATEMENT (IsNaN $ "Surplus Volume Entitlements.CAP FC" [@"24:00:00 December 31, Current Year"]) THEN
            $ "Surplus Volume Entitlements.CAP FC" [@"24:00:00 December 31, Current Year"] := 1835000.00000000 "acre-ft" - $ "Arizona_CU_Forecast1.CAP" [@"24:00:00 December 31, Current Year"];

      END_IF_STATEMENT;

    END;

    RULE                 "Set Domestic and FC Surplus Entitlement Vols for CAP and MWD";
    DESCRIPTION          "This rule is inactive. It has been replaced with a similar rule that includes consideration of Mexican surplus volume per Minute 319.";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    BEGIN

      IF_STATEMENT (IsNaN $ "Surplus Volume Entitlements.MWD Domestic" [@"24:00:00 December 31, Current Year"]) THEN
            $ "Surplus Volume Entitlements.MWD Domestic" [@"24:00:00 December 31, Current Year"] := IF ( "GetYear"( @"24:00:00 January 31, Current Year" ) < 2017.00000000 )
   THEN
      1250000.00000000 "acre-ft" - $ "California_CU_Forecast1.MWDDiversion" [@"24:00:00 December 31, Current Year"]
   ELSE
      250000.00000000 "acre-ft"
   ENDIF;

      END_IF_STATEMENT;

      IF_STATEMENT (IsNaN $ "Surplus Volume Entitlements.MWD FC" [@"24:00:00 December 31, Current Year"]) THEN
            $ "Surplus Volume Entitlements.MWD FC" [@"24:00:00 December 31, Current Year"] := 1250000.00000000 "acre-ft" - $ "California_CU_Forecast1.MWDDiversion" [@"24:00:00 December 31, Current Year"];

      END_IF_STATEMENT;

      IF_STATEMENT (IsNaN $ "Surplus Volume Entitlements.CAP Domestic" [@"24:00:00 December 31, Current Year"]) THEN
            $ "Surplus Volume Entitlements.CAP Domestic" [@"24:00:00 December 31, Current Year"] := IF ( "GetYear"( @"24:00:00 January 31, Current Year" ) < 2017.00000000 )
   THEN
      0.00000000 "acre-ft"
   ELSE
      100000.00000000 "acre-ft" - ( $ "Surplus Volume Entitlements.Gila Monster Farms" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"] )
   ENDIF;

      END_IF_STATEMENT;

      IF_STATEMENT (IsNaN $ "Surplus Volume Entitlements.CAP FC" [@"24:00:00 December 31, Current Year"]) THEN
            $ "Surplus Volume Entitlements.CAP FC" [@"24:00:00 December 31, Current Year"] := 1835000.00000000 "acre-ft" - $ "Arizona_CU_Forecast1.CAP" [@"24:00:00 December 31, Current Year"];

      END_IF_STATEMENT;

    END;

    RULE                 "Set Quantified Volumes by State";
    DESCRIPTION          "If there is a positive Quantified Surplus volume, this rule will distribute it amond the lower basin states of AZ, CA, and NV. The distribution amounts (shares) are stored in a slot on the Surplus object. <br>IF there is not a positive Quantified Surplus, the execution contraints will prevent this rule from firing. -HMG 8/2/11";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND $ "Surplus.Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] > 0.00000000 "acre-feet";
    BEGIN

      FOREACH (STRING state IN { "California" , "Arizona" , "Nevada" }) DO
            % "Surplus" & ( state CONCAT " Quantified Surplus Volume" ) [@"24:00:00 December 31, Current Year"] := $ "Surplus.Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] * $ "Surplus.Share of Quantified Surplus by State" [0.00000000, state];

      ENDFOREACH;

    END;

    RULE                 "Compute Quantified Surplus Volume - Minute 319";
    DESCRIPTION          "Computes the total volume of Quantified Surplus water for the year. This slot only computes once per year in January and is NOT recalculted if Lower Basin demands are revised.<br><br>If this value is postitive,  there is a Quantified Surplus determination and water use schedules are revised as appropriate. <br><br>Equation:   Surplus Volume = (Powell Storage + Mead Storage ? maxstorage - previous year ICS credits)*(1+avgBankStorcoef) + runoff ? UBDemand ? LBDemand <br>Variable Definitions:<br>  Powell Storage = Powell storage at beginning of the year (December month-end) <br>  Mead Storage = Mead storage at the beginning of the year (December month-end) <br>  Max Storage = 47.96 maf <br>  Previous year ICS credits ? cumulative ICS credits over entire Lower Basin over all years <br>  avgBankStorcoef = average of Powell and Mead bank storage coefficients <br>  Runoff = 17.4 maf (70th percentile non-exceedence flow) <br>  UBDemand = Upper Basin depletion scheduled for the year + average evaporation loss in the Upper Basin (same as in 602a calculation, 560 kaf) <br>  LBDemand = sum of depletions below Powell + evaporation losses in the Lower Basin (avg 900 kaf) ? avg gains below Powell (Powell to Mead and below Mead) <br><br>-HMG 8/2/11";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "Surplus.Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"];
    BEGIN

      $ "Surplus.Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] := "Max"( ( $ "Powell.Storage" [@"t - 1"] + $ "Mead.Storage" [@"t - 1"] - $ "Surplus.MaxStorage" [] - ( "SumPreviousYearICScredits"(  ) + $ "Mexico Shortage and Surplus.ICMA Balance" [@"24:00:00 December 31, Previous Year"] ) ) * ( 1.00000000 + ( $ "Powell.Bank Storage Coefficient" [0.00000000, 0.00000000] + $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] ) / 2.00000000 ) + $ "Surplus.70RLeesFerryFlow" [] - ( $ "Surplus.UBEvaporation" [] + $ "Surplus.UBDemand" [@"24:00:00 December 31, Current Year"] ) - "SumLBDemands - Include Mexico"(  ), 0.00000000 "acre-ft" );

    END;

    RULE                 "Compute Quantified Surplus Volume";
    DESCRIPTION          "Computes the total volume of Quantified Surplus water for the year. This slot only computes once per year in January and is NOT recalculted if Lower Basin demands are revised.<br><br>If this value is postitive,  there is a Quantified Surplus determination and water use schedules are revised as appropriate. <br><br>Equation:   Surplus Volume = (Powell Storage + Mead Storage ? maxstorage - previous year ICS credits)*(1+avgBankStorcoef) + runoff ? UBDemand ? LBDemand <br>Variable Definitions:<br>  Powell Storage = Powell storage at beginning of the year (December month-end) <br>  Mead Storage = Mead storage at the beginning of the year (December month-end) <br>  Max Storage = 47.96 maf <br>  Previous year ICS credits ? cumulative ICS credits over entire Lower Basin over all years <br>  avgBankStorcoef = average of Powell and Mead bank storage coefficients <br>  Runoff = 17.4 maf (70th percentile non-exceedence flow) <br>  UBDemand = Upper Basin depletion scheduled for the year + average evaporation loss in the Upper Basin (same as in 602a calculation, 560 kaf) <br>  LBDemand = sum of depletions below Powell + evaporation losses in the Lower Basin (avg 900 kaf) ? avg gains below Powell (Powell to Mead and below Mead) <br><br>-HMG 8/2/11";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND IsNaN $ "Surplus.Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"];
    BEGIN

      $ "Surplus.Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] := "Max"( ( $ "Powell.Storage" [@"t - 1"] + $ "Mead.Storage" [@"t - 1"] - $ "Surplus.MaxStorage" [] - "SumPreviousYearICScredits"(  ) ) * ( 1.00000000 + ( $ "Powell.Bank Storage Coefficient" [0.00000000, 0.00000000] + $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] ) / 2.00000000 ) + $ "Surplus.70RLeesFerryFlow" [] - ( $ "Surplus.UBEvaporation" [] + $ "Surplus.UBDemand" [@"24:00:00 December 31, Current Year"] ) - "SumLBDemands"(  ), 0.00000000 "acre-ft" );

    END;

    RULE                 "Set Outyear Surplus Schedules for Mexico - Minute 319";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND @"t" != @"Start Timestep" AND $ "Mexico Shortage and Surplus.Mexico Surplus Flag" [@"24:00:00 December 31, Current Year"] > 0.00000000;
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "MexicanTreatyDelivery:MexicoSched.Diversion Requested" [date] := "VolumeToFlow"( $ "Mexico_CU_Schedules.MexicoSched" [date] - $ "Mexico_CU_Schedules.MexicoTJ" [date] + $ "Mexico Shortage and Surplus.Mexico Surplus Table" [$ "Mexico Shortage and Surplus.Mexico Surplus Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, "Volume"] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "Mexico"], date );

      ENDFOREACH;

      $ "Mexico Shortage and Surplus.Mexico Annual Surplus" [@"24:00:00 December 31, Current Year"] := $ "Mexico Shortage and Surplus.Mexico Surplus Table" [$ "Mexico Shortage and Surplus.Mexico Surplus Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, "Volume"];

    END;

    RULE                 "Set Mexico Surplus Flag - Minute 319";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND @"t" != @"Start Timestep";
    BEGIN

      $ "Mexico Shortage and Surplus.Mexico Surplus Flag" [@"24:00:00 December 31, Current Year"] := IF ( $ "Mead.Pool Elevation" [@"t - 1"] >= $ "Mexico Shortage and Surplus.Mexico Surplus Table" [2.00000000, "Elevation"] )
   THEN
      3.00000000
   ELSE
      IF ( $ "Mead.Pool Elevation" [@"t - 1"] >= $ "Mexico Shortage and Surplus.Mexico Surplus Table" [1.00000000, "Elevation"] )
      THEN
         2.00000000
      ELSE
         IF ( $ "Mead.Pool Elevation" [@"t - 1"] >= $ "Mexico Shortage and Surplus.Mexico Surplus Table" [0.00000000, "Elevation"] )
         THEN
            1.00000000
         ELSE
            0.00000000
         ENDIF
      ENDIF
   ENDIF;

    END;

  END;

  POLICY_GROUP   "Shortage";
  DESCRIPTION    "This policy group contains the rules required to simulate Lower Basin Shortage operations. Lower Basin Shortage operations are based on the 2007 Interim Guidelines as well as IBWC Minute 319. <br><br>Shortage volumes in Arizona are based on the Arizona Shortage Sharing Agreement. All shortage volumes are the volumes used during the 2007 Interim Guidelines EIS, and were provided by the state of Arizona for use in the EIS process.<br><br>Mexico shortage volumes are based on IBWC Minute 319.   ";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Set Mexico Outyear Shortage Schedules - Minute 319";
    DESCRIPTION          "This rule sets a shortage diversion amount to the water use object MexicanTreatyDelivery:MexicoSched. The Mexico schedule is reduced by the shortage volume. The Mexico shortage volume is specified in IBWC Minute 319.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND @"t" != @"Start Timestep" AND $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] > 0.00000000;
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "MexicanTreatyDelivery:MexicoSched.Diversion Requested" [date] := "VolumeToFlow"( $ "Mexico_CU_Schedules.MexicoSched" [date] - $ "Mexico_CU_Schedules.MexicoTJ" [date] - $ "Mexico Shortage and Surplus.Mexico Shortage Volumes" [$ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, "Mexico"] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "Mexico"], date );

      ENDFOREACH;

      $ "Mexico Shortage and Surplus.Mexico Annual Shortage" [@"24:00:00 December 31, Current Year"] := $ "Mexico Shortage and Surplus.Mexico Shortage Volumes" [$ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, "Mexico"];

    END;

    RULE                 "Set Outyear Shortage Schedules";
    DESCRIPTION          "This rule sets the shortage schedules located in data objects or calculated to the diversion requested slots of the appropriate U.S. water use simulation objects.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND @"t" != @"Start Timestep" AND $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] > 0.00000000;
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date] := IF ( $ "AnnualWaterUse.Nevada_Forecast1" [@"24:00:00 December 31, Current Year"] - $ "Shortage.State Shortage Volumes" [$ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, "Nevada"] < $ "AnnualWaterUse.Nevada_Apportionment" [@"24:00:00 December 31, Current Year"] )
   THEN
      "VolumeToFlow"( $ "Nevada_CU_Schedules.SNWP" [date] - $ "Shortage.State Shortage Volumes" [$ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, "Nevada"] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "Average"], date )
   ENDIF;

            $ "AzDvsToPkr:LakeHavasuCity.Diversion Requested" [date] := "Arizona Shortage Depletion"( "LakeHavasuCity", $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

            $ "AzDvsToPkr:MohaveValleyIID.Diversion Requested" [date] := "Arizona Shortage Depletion"( "MohaveValleyIID", $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

            $ "AzDvsToPkr:BullheadCity.Diversion Requested" [date] := "Arizona Shortage Depletion"( "BullheadCity", $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

            $ "AzPkrToImp:CibolaValleyIID.Diversion Requested" [date] := "Arizona Shortage Depletion"( "CibolaValleyIID", $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

            $ "AzPkrToImp:Parker.Diversion Requested" [date] := "Arizona Shortage Depletion"( "City of Parker", $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

            $ "AzPkrToImp:Ehrenberg.Diversion Requested" [date] := "Arizona Shortage Depletion"( "Ehrenberg", $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

            $ "GilaAndYumaUsers:GilaMonsterFarms.Diversion Requested" [date] := "Arizona Shortage Depletion"( "Gila Monster Farms", $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

            $ "GilaAndYumaUsers:CocopahIndRes.Diversion Requested" [date] := "Arizona Shortage Depletion"( "Cocopah Indian Res", $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

            $ "AzPkrToImp:AzPumpersAbvImp.Diversion Requested" [date] := "Arizona Shortage Depletion"( "AzPumpersAbvImp", $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

            $ "OthersBlwImp:AzPumpersBlwImp.Diversion Requested" [date] := "Arizona Shortage Depletion"( "AzPumpersBlwImp", $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

            $ "AzDvsToPkr:AzPumpersDvsToPkr.Diversion Requested" [date] := "Arizona Shortage Depletion"( "AzPumpersDvsToPkr", $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

            $ "CAPDiversion.Total Diversion Requested" [date] := "CAP Shortage Depletion"( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

      ENDFOREACH;

    END;

    RULE                 "Set CAP Annual Shortage Volume";
    DESCRIPTION          "This rule sets the annual shortage volume for CAP in Arizona. The CAP shortage volume is based on the Arizona Shortage Sharing Agreement. It is calculated as the total Arizona shortage volume (based on Lake Mead trigger elevation) minus the sum of the shortage volumes of the other Arizona water users.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND @"t" != @"Start Timestep" AND "GetRunCycleIndex"(  ) >= 3.00000000;
    BEGIN

      $ "Shortage.CAP Annual Shortage Volume" [@"24:00:00 December 31, Current Year"] := IF ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] > 0.00000000 )
   THEN
      "GetAnnualCAPShortage"( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000 )
   ELSE
      0.00000000 "acre-feet"
   ENDIF;

    END;

    RULE                 "Set Shortage Flag";
    DESCRIPTION          "In the event that a Lower Basin shortage is projected, this rule sets the Shortage Flag slot to indicate the level of shortage. No shortage = 0. Most sever shortage (Mead < 1025 feet) = 3.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND @"t" != @"Start Timestep" AND "GetRunCycleIndex"(  ) >= 3.00000000;
    BEGIN

      $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] := IF ( $ "Mead.Pool Elevation" [@"t - 1"] < $ "Shortage.Mead Shortage Elevations" [2.00000000, 0.00000000] )
   THEN
      3.00000000
   ELSE
      IF ( $ "Mead.Pool Elevation" [@"t - 1"] < $ "Shortage.Mead Shortage Elevations" [1.00000000, 0.00000000] )
      THEN
         2.00000000
      ELSE
         IF ( $ "Mead.Pool Elevation" [@"t - 1"] <= $ "Shortage.Mead Shortage Elevations" [0.00000000, 0.00000000] )
         THEN
            1.00000000
         ELSE
            0.00000000
         ENDIF
      ENDIF
   ENDIF;

      $ "LowerBasinDemandVariability.AbvHooverTriggerSet" [@"24:00:00 December 31, Current Year"] := IF ( $ "Mead.Pool Elevation" [@"t - 1"] <= $ "Shortage.Mead Shortage Elevations" [0.00000000, 0.00000000] )
   THEN
      2.00000000
   ENDIF;

    END;

  END;

  POLICY_GROUP   "24 Month";
  DESCRIPTION    "This policy group contains rules that pertain to Lake Mead operations. Lake Mead has 2 basic modes of operation - meeting downstream demands or flood control.";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Set Flow To Mexico (flow at NIB) exp";
    DESCRIPTION          "This rule just computes the flow to Mexico and stores it on the<br>MexicoExcess data object in the slot NIBFlow for subsequent write to hdb<br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    BEGIN

      $ "Lower Basin Output.NIBFlow" [] := $ "Lower Basin Output.MexicoExcessFlow" [] + $ "MexicanTreatyDelivery:MexicoSched.Diversion Requested" [];

    END;

    RULE                 "Set Mexico Excess";
    DESCRIPTION          " this rule determines the excess flow to Mexico which is just the<br> actual Mead release minus the release determined to meet downstream requirements <br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    BEGIN

      $ "Lower Basin Output.MexicoExcessFlow" [] := $ "Mead.Outflow" [] - "VolumeToFlow"( $ "Lower Basin Output.DownstreamReq" [], @"t" );

    END;

    RULE                 "Set DownStream Requirement exp";
    DESCRIPTION          "This rule calculates what is the demand downstream of Lake Mead. It should get reset if shortage or surplus schedules are applied.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    BEGIN

      $ "Lower Basin Output.DownstreamReq" [] := IF ( @"t" <= @"Start Timestep + 1" )
   THEN
      "FlowToVolume"( $ "HavasuOutflow.BHOPSParkerOutflow" [], @"t" )
   ELSE
      $ "HavasuOutflow.ParkerRequirement" []
   ENDIF + "SumAllDiversionsBelowVolume"( % "Mead", @"t", @"t" ) - "SumGainsBelowVolume"( % "Mead", @"t", @"t" ) + "ComputeDeltaTargetStorage"( % "Mohave" ) + "ComputeDeltaTargetStorage"( % "Havasu" ) + $ "Mohave.Evaporation" [] + $ "Havasu.Evaporation" [];

    END;

    RULE                 "Set Parker Final Requirement";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    BEGIN

      $ "HavasuOutflow.ParkerRequirement" [] := "SumAllDiversionsBelowVolume"( % "Havasu", @"t", @"t" ) - "SumAllGainsBelowVolume"( % "Havasu", @"t", @"t" );

    END;

  END;

  POLICY_GROUP   "Powell Steady Flow Experiment";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Set Steady Flow Experiment Release";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT $ "PowellData.SteadyFlowExperimentFlag" [] == 1.00000000 AND "GetRunCycleIndex"(  ) == 3.00000000;
    BEGIN

      IF_STATEMENT ("MonthIs"( { "September" } )) THEN
            $ "Powell.Outflow" [] := "GetSeptemberSteadyFlowRelease"( $ "PowellData.AnnualReleaseVolume" [] );

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "October" } )) THEN
            $ "Powell.Outflow" [] := $ "Powell.Outflow" [@"t - 1"];

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "April" } )) THEN
            $ "Powell.Outflow" [] := $ "Powell.Outflow" [] - $ "PowellSteadyFlowExperiment.5_ReduceApril" ["CurrentYear"(  )] / "GetDaysInMonth"( @"t" );

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "May" } )) THEN
            $ "Powell.Outflow" [] := $ "Powell.Outflow" [] - $ "PowellSteadyFlowExperiment.6_ReduceMay" ["CurrentYear"(  )] / "GetDaysInMonth"( @"t" );

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "June" } )) THEN
            $ "Powell.Outflow" [] := $ "Powell.Outflow" [] - ( $ "PowellSteadyFlowExperiment.4_ReduceJune_2" ["CurrentYear"(  )] + $ "PowellSteadyFlowExperiment.3_ReduceJune_1" ["CurrentYear"(  )] ) / "GetDaysInMonth"( @"t" );

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "July" } )) THEN
            $ "Powell.Outflow" [] := $ "Powell.Outflow" [] - $ "PowellSteadyFlowExperiment.2_ReduceAugust" ["CurrentYear"(  )] / "GetDaysInMonth"( @"t" );

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "July" } )) THEN
            $ "Powell.Outflow" [] := $ "Powell.Outflow" [] - $ "PowellSteadyFlowExperiment.1_ReduceJuly" ["CurrentYear"(  )] / "GetDaysInMonth"( @"t" );

      END_IF_STATEMENT;

    END;

    RULE                 "Set Steady Flow Reductions";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT "MonthIs"( { "April" } ) AND "GetRunCycleIndex"(  ) == 3.00000000;
    BEGIN

      $ "PowellSteadyFlowExperiment.1_ReduceJuly" ["CurrentYear"(  )] := "SteadyFlowReduce_1_July"(  );

      $ "PowellSteadyFlowExperiment.2_ReduceAugust" ["CurrentYear"(  )] := "SteadyFlowReduce_2_August"(  );

      $ "PowellSteadyFlowExperiment.3_ReduceJune_1" ["CurrentYear"(  )] := "SteadyFlowReduce_3_June1"(  );

      $ "PowellSteadyFlowExperiment.4_ReduceJune_2" ["CurrentYear"(  )] := "SteadyFlowReduce_4_June2"(  );

      $ "PowellSteadyFlowExperiment.5_ReduceApril" ["CurrentYear"(  )] := "SteadyFlowReduce_5_April"(  );

      $ "PowellSteadyFlowExperiment.6_ReduceMay" ["CurrentYear"(  )] := "SteadyFlowReduce_6_May"(  );

    END;

  END;

  POLICY_GROUP   "PowellAfterLBDV";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Set Lower Balancing Release VolumePostLBDV";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "IsYearDemandVariabilityAndRunCycle4"( @"t" ) AND ( @"t" == @"Start Timestep" OR "MonthIs"( { "August" } ) ) AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    BEGIN

      IF_STATEMENT (@"t" == @"Start Timestep" AND "TierIs"( "Lower", @"t", TRUE )) THEN
            $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "Min"( "Max"( "LowerTierEqualizationRelease"( "RelativeEOWYDate"( @"t" ) ), $ "PowellData.PowellLowerTierMinAnnualRelease" [] ), $ "PowellData.PowellLowerTierMaxAnnualRelease" [] );

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "August" } ) AND "TierIs"( "Lower", @"t", FALSE )) THEN
            $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "Min"( "Max"( "LowerTierEqualizationRelease"( "RelativeEOWYDate"( @"t + 2" ) ), $ "PowellData.PowellLowerTierMinAnnualRelease" [] ), $ "PowellData.PowellLowerTierMaxAnnualRelease" [] );

      END_IF_STATEMENT;

    END;

    RULE                 "Set Mid-Elevation Release VolumePostLBDV";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "IsYearDemandVariabilityAndRunCycle4"( @"t" ) AND ( @"t" == @"Start Timestep" OR "MonthIs"( { "August" } ) ) AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    BEGIN

      IF_STATEMENT (@"t" == @"Start Timestep" AND "TierIs"( "Mid", @"t", TRUE )) THEN
            $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "Max"( IF ( $ "Mead.Pool Elevation" ["DateToCheckJan1Elevation"( @"t", TRUE )] >= 1025.00000000 "ft" )
   THEN
      7480.00000000 "1000 acre-ft"
   ELSE
      8230.00000000 "1000 acre-ft"
   ENDIF, NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"Start Timestep" ) )] ) );

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "August" } ) AND "TierIs"( "Mid", @"t", FALSE )) THEN
            $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := IF ( $ "Mead.Pool Elevation" [@"24:00:00 December 31, Current Year"] >= 1025.00000000 "ft" )
   THEN
      7480.00000000 "1000 acre-ft"
   ELSE
      8230.00000000 "1000 acre-ft"
   ENDIF;

      END_IF_STATEMENT;

    END;

    RULE                 "Refine Equalization Release VolumePostLBDV";
    DESCRIPTION          "This rule refines the annual release volume from Powell when either the Equalization Tier or Upper Elevation Balancing Tier B3 branch is operative for setting the annual release from Powell.  The release needs to be refined by this rule because when it is originally set, it is a preliminary &quot;guess&quot; for the volume it will take to arrive at the appropriate final (end of water year) condition (Equalized storage volumes, or Powell at a specific pool elevation at the end of the year - see Equalization Tier logic for more details as to what the final eowy condition should be).  This volume is then released and the end of year condition is checked against what it is supposed to be.  The first guess will almost always be off by some amount because of the non-linear elements in the water balance in both Powell and Mead of Evaporation and Bank Storage.  So rather than trying to set up a calculation or mini-simulation to calculate the exact right release volume to hit the end of water year condtion the first time, the guess volume is actually released and then this rule, because it can see the results of the original release, adjusts the release volume to eliminate the deviation from the target that it observes as a result of the initial guess release.  This rule is allowed to fire multiple times in a timestep and may do so in order to hit exactly the end of water year target condition. - sc 06/21/12";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT WITH DATETIME eoyDate = IF ( "MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) )
   THEN
      "Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )
   ELSE
      "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )
   ENDIF DO
      "HasRuleFiredSuccessfully"( "Set Equalization Release Volume" ) OR ( "HasRuleFiredSuccessfully"( "Set Upper Balancing Release Volume" ) AND $ "PowellData.UpperElevBalBranch" [eoyDate] == 1.30000000 ) AND "IsYearDemandVariabilityAndRunCycle4"( @"t" )
   ENDWITH;
    BEGIN

      IF_STATEMENT (@"t" == @"Start Timestep" AND ( "TierIs"( "Upper", @"t", TRUE ) OR "TierIs"( "Equalization", @"t", TRUE ) ) AND NOT "MonthIs"( { "August" } )) THEN
            IF_STATEMENT (NOT "VolumeDeviationFromEOWYTarget"( "RelativeEOWYDate"( @"t" ) ) == 0.00000000 "acre-ft") THEN
            $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] + "VolumeDeviationFromEOWYTarget"( "RelativeEOWYDate"( @"t" ) );

      END_IF_STATEMENT;

            IF_STATEMENT ($ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] == 1.40000000) THEN
            $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "Max"( "EnsureReleaseLimits"( "EqualizationRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) ), 8230.00000000 "1000 acre-ft", 9000.00000000 "1000 acre-ft" ), NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"Start Timestep" ) )] ) );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) AND ( "TierIs"( "Upper", @"t", FALSE ) OR "TierIs"( "Equalization", @"t", FALSE ) )) THEN
            IF_STATEMENT (NOT "VolumeDeviationFromEOWYTarget"( "RelativeEOWYDate"( @"t + 2" ) ) == 0.00000000 "acre-ft") THEN
            $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] + "VolumeDeviationFromEOWYTarget"( "RelativeEOWYDate"( @"t + 2" ) );

      END_IF_STATEMENT;

            IF_STATEMENT ($ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 1.40000000) THEN
            $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "EnsureReleaseLimits"( "EqualizationRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) ), 8230.00000000 "1000 acre-ft", 9000.00000000 "1000 acre-ft" );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "Set Upper Balancing Release Volume PostLBDV";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "IsYearDemandVariabilityAndRunCycle4"( @"t" ) AND ( @"t" == @"Start Timestep" OR "MonthIs"( { "August" } ) ) AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) AND @"t + 2" <= @"Finish Timestep";
    BEGIN

      IF_STATEMENT (@"t" == @"Start Timestep" AND ( "GetRunCycleIndex"(  ) == 3.00000000 OR "IsYearDemandVariabilityAndRunCycle4"( @"t" ) ) AND "TierIs"( "Upper", @"t", TRUE )) THEN
            $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := WITH DATETIME meadProjecetionDate = IF ( @"t" <= @"September 30" )
   THEN
      @"24:00:00 December 31, Previous Year"
   ELSE
      @"24:00:00 December 31, Current Year"
   ENDIF DO
      IF ( $ "Powell.Pool Elevation" ["DateToCheckEOWYElevation"( @"t", TRUE )] > "EqLevel"( "DateToCheckEOWYElevation"( @"t", TRUE ) ) )
      THEN
         GET @INDEX 0.00000000 FROM "EqualizationTeirCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) )
      ELSE
         IF ( $ "Mead.Pool Elevation" [meadProjecetionDate] >= 1075.00000000 "ft" )
         THEN
            "Max"( "B1_Branch_UpperBalancingTeirVolume"( "DateToCheckEOWYElevation"( @"t", TRUE ) ), NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"Start Timestep" ) )] ) )
         ELSE
            "Max"( "B2_Branch_UpperBalancingTeirVolume"( "DateToCheckEOWYElevation"( @"t", TRUE ) ), NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"Start Timestep" ) )] ) )
         ENDIF
      ENDIF COMMENTED_BY "Check EOWY Powell Elevation.  If above equalization level then go to equalization teir calculation.  If not, continue..."
   ENDWITH;

            WITH_STATEMENT (NUMERIC upperElevBranch = "UpperElevationBalancingBranchCalculation"( "DateToCheckEOWYElevation"( @"t", TRUE ) )) DO
            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := upperElevBranch;

            IF_STATEMENT (upperElevBranch == 1.30000000) THEN
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 0.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := GET @INDEX 1.00000000 FROM "EqualizationTeirCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) );

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      IF_STATEMENT (( "MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) ) AND "TierIs"( "Upper", @"t", FALSE )) THEN
            $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := IF ( $ "Powell.Pool Elevation" ["DateToCheckEOWYElevation"( @"t", FALSE )] > "EqLevel"( "DateToCheckEOWYElevation"( @"t", FALSE ) ) )
   THEN
      GET @INDEX 0.00000000 FROM "EqualizationTeirCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) )
   ELSE
      IF ( $ "Mead.Pool Elevation" [@"24:00:00 December 31, Current Year"] >= 1075.00000000 "ft" )
      THEN
         "B1_Branch_UpperBalancingTeirVolume"( "DateToCheckEOWYElevation"( @"t", FALSE ) )
      ELSE
         "B2_Branch_UpperBalancingTeirVolume"( "DateToCheckEOWYElevation"( @"t", FALSE ) )
      ENDIF
   ENDIF COMMENTED_BY "Check EOWY Powell Elevation.  If above equalization level then go to equalization teir calculation.  If not, continue...";

            WITH_STATEMENT (NUMERIC upperElevBranch = "UpperElevationBalancingBranchCalculation"( "DateToCheckEOWYElevation"( @"t", FALSE ) )) DO
            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := upperElevBranch;

            IF_STATEMENT (upperElevBranch == 1.30000000) THEN
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 0.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := GET @INDEX 1.00000000 FROM "EqualizationTeirCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) );

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "Set Equalization Release VolumePostLBDV";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( "IsYearDemandVariabilityAndRunCycle4"( @"t" ) AND ( @"t" == @"Start Timestep" OR "MonthIs"( { "August" } ) ) AND @"t + 2" <= @"Finish Timestep" AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) ) COMMENTED_BY "This rule only fires if we are in the third run cycle or in the fourth run cycle and demand variability<br> has changed the demands out of Lake Mead, it is August, and the model has selected the<br> Equalization teir for the current year. - sc 02/02/11 & TP 08/20/2014";
    BEGIN

      IF_STATEMENT (@"t" == @"Start Timestep" AND "TierIs"( "Equalization", @"t", TRUE )) THEN
            $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "Max"( GET @INDEX 0.00000000 FROM "EqualizationTeirCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) ), NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) );

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := GET @INDEX 1.00000000 FROM "EqualizationTeirCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) );

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) AND "TierIs"( "Equalization", @"t", FALSE )) THEN
            $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := GET @INDEX 0.00000000 FROM "EqualizationTeirCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) );

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := GET @INDEX 1.00000000 FROM "EqualizationTeirCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) );

      END_IF_STATEMENT;

    END;

    RULE                 "Preliminary Set Out Year Release Volume To 8.23MAF post LBDV";
    DESCRIPTION          "This rule preliminarily sets outflows from Powell in order to evaluate the projections of Powell and Mead elevations used for tierthe  selection calculation.  It sets the release volume to 8.23 MAF unless doing so will cause the model to fail by overfilling Powell.  In that case it sets the annual release volumes to the amount needed to just keep Powell below its max elevation.  The rule fires on the first timestep of run cycle 3 and should allow the whole model to solve for this preliminary condition.  Subsequent rules will then calculate the appropriate tier values for each water year in the run and then set the releases from Powell on a monthly basis. - sc 03/25/11";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "IsYearDemandVariabilityAndRunCycle4"( @"t" ) AND ( @"t" == @"Start Timestep" OR "MonthIs"( { "August" } ) ) AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) AND @"t + 2" <= @"Finish Timestep";
    BEGIN

      WITH_STATEMENT (NUMERIC watYearIndex = "GetYear"( @"t" ) - "GetYear"( @"Start Timestep" ) + IF ( "GetMonth"( @"Start Timestep" ) > 9.00000000 )
   THEN
      1.00000000
   ELSE
      2.00000000
   ENDIF) DO
            WITH_STATEMENT (NUMERIC availWatPowell = ( IF ( "GetMonth"( @"Start Timestep" ) == 9.00000000 )
   THEN
      $ "Powell.Storage" [@"t - 1"]
   ELSE
      $ "Powell.Storage" [@"t + 1"]
   ENDIF + FOR ( DATETIME date IN "WaterYearDatesByGroup"( watYearIndex ) ) STAT_SUM
      "FlowToVolume"( $ "Powell.Inflow" [date], date )
   ENDFOR ) COMMENTED_BY "This is added to check that in years when Powell might go very low, the model won't bomb out <br>when setting the preliminary release when Powell is low. TP 1/22/2013<br>") DO
            IF_STATEMENT (NOT "IsInput"( $ "PowellData.AnnualReleaseVolume", "Dec31ofYear"( "OffsetDate"( "RelativeEOWYDate"( @"Start Timestep" ), watYearIndex - 1.00000000, "1 years" ) ) )) THEN
            $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "OffsetDate"( "RelativeEOWYDate"( @"Start Timestep" ), watYearIndex - 1.00000000, "1 years" ) )] := "Min"( "Max"( 8230.00000000 "1000 acre-feet", "CalcPrelimReleaseAmt_PreventModelCrash"( "WaterYearDatesByGroup"( watYearIndex ) ) ), availWatPowell );

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "Preliminary Set WY1 Release Volume To 8.23MAF post LBDV";
    DESCRIPTION          "This rule preliminarily sets outflows from Powell in order to evaluate the projections of Powell and Mead elevations used for tierthe  selection calculation.  It sets the release volume to 8.23 MAF unless doing so will cause the model to fail by overfilling Powell.  In that case it sets the annual release volumes to the amount needed to just keep Powell below its max elevation.  The rule fires on the first timestep of run cycle 3 and should allow the whole model to solve for this preliminary condition.  Subsequent rules will then calculate the appropriate tier values for each water year in the run and then set the releases from Powell on a monthly basis. - sc 03/25/11";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "IsYearDemandVariabilityAndRunCycle4"( @"t" ) AND @"t" == @"Start Timestep" AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    BEGIN

      IF_STATEMENT (NOT "IsInput"( $ "PowellData.AnnualReleaseVolume", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) )) THEN
            $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "MaxItem"( { 8230.00000000 "1000 acre-feet" , "CalcPrelimReleaseAmt_PreventModelCrash"( "WaterYearDatesByGroup"( 1.00000000 ) ) , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) } );

      END_IF_STATEMENT;

    END;

  END;

  POLICY_GROUP   "Powell";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Set Lower Balancing Release Volume";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 3.00000000 AND ( @"t" == @"Start Timestep" OR "MonthIs"( { "August" } ) ) AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    BEGIN

      IF_STATEMENT (@"t" == @"Start Timestep" AND "TierIs"( "Lower", @"t", TRUE ) AND NOT "IsInput"( $ "PowellData.AnnualReleaseVolume", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) )) THEN
            $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "Min"( "Max"( "LowerTierEqualizationRelease"( "RelativeEOWYDate"( @"t" ) ), $ "PowellData.PowellLowerTierMinAnnualRelease" [] ), $ "PowellData.PowellLowerTierMaxAnnualRelease" [] );

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "August" } ) AND "TierIs"( "Lower", @"t", FALSE )) THEN
            $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "Min"( "Max"( "LowerTierEqualizationRelease"( "RelativeEOWYDate"( @"t + 2" ) ), $ "PowellData.PowellLowerTierMinAnnualRelease" [] ), $ "PowellData.PowellLowerTierMaxAnnualRelease" [] );

      END_IF_STATEMENT;

    END;

    RULE                 "Set Mid-Elevation Release Volume";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 3.00000000 AND ( @"t" == @"Start Timestep" OR "MonthIs"( { "August" } ) ) AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    BEGIN

      IF_STATEMENT (@"t" == @"Start Timestep" AND "TierIs"( "Mid", @"t", TRUE ) AND NOT "IsInput"( $ "PowellData.AnnualReleaseVolume", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) )) THEN
            $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "Max"( IF ( $ "Mead.Pool Elevation" ["DateToCheckJan1Elevation"( @"t", TRUE )] >= 1025.00000000 "ft" )
   THEN
      7480.00000000 "1000 acre-ft"
   ELSE
      8230.00000000 "1000 acre-ft"
   ENDIF, NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"Start Timestep" ) )] ) );

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "August" } ) AND "TierIs"( "Mid", @"t", FALSE )) THEN
            $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := IF ( $ "Mead.Pool Elevation" [@"24:00:00 December 31, Current Year"] >= 1025.00000000 "ft" )
   THEN
      7480.00000000 "1000 acre-ft"
   ELSE
      8230.00000000 "1000 acre-ft"
   ENDIF;

      END_IF_STATEMENT;

    END;

    RULE                 "Refine Equalization Release Volume";
    DESCRIPTION          "This rule refines the annual release volume from Powell when either the Equalization Tier or Upper Elevation Balancing Tier B3 branch is operative for setting the annual release from Powell.  The release needs to be refined by this rule because when it is originally set, it is a preliminary &quot;guess&quot; for the volume it will take to arrive at the appropriate final (end of water year) condition (Equalized storage volumes, or Powell at a specific pool elevation at the end of the year - see Equalization Tier logic for more details as to what the final eowy condition should be).  This volume is then released and the end of year condition is checked against what it is supposed to be.  The first guess will almost always be off by some amount because of the non-linear elements in the water balance in both Powell and Mead of Evaporation and Bank Storage.  So rather than trying to set up a calculation or mini-simulation to calculate the exact right release volume to hit the end of water year condtion the first time, the guess volume is actually released and then this rule, because it can see the results of the original release, adjusts the release volume to eliminate the deviation from the target that it observes as a result of the initial guess release.  This rule is allowed to fire multiple times in a timestep and may do so in order to hit exactly the end of water year target condition. - sc 06/21/12";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT WITH DATETIME eoyDate = IF ( "MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) )
   THEN
      "Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )
   ELSE
      "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )
   ENDIF DO
      "HasRuleFiredSuccessfully"( "Set Equalization Release Volume" ) OR ( "HasRuleFiredSuccessfully"( "Set Upper Balancing Release Volume" ) AND $ "PowellData.UpperElevBalBranch" [eoyDate] == 1.30000000 ) AND "GetRunCycleIndex"(  ) == 3.00000000
   ENDWITH;
    BEGIN

      IF_STATEMENT (@"t" == @"Start Timestep" AND ( "TierIs"( "Upper", @"t", TRUE ) OR "TierIs"( "Equalization", @"t", TRUE ) ) AND NOT "MonthIs"( { "August" } ) AND NOT "IsInput"( $ "PowellData.AnnualReleaseVolume", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) )) THEN
            IF_STATEMENT (NOT "VolumeDeviationFromEOWYTarget"( "RelativeEOWYDate"( @"t" ) ) == 0.00000000 "acre-ft") THEN
            $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] + "VolumeDeviationFromEOWYTarget"( "RelativeEOWYDate"( @"t" ) );

      END_IF_STATEMENT;

            IF_STATEMENT ($ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] == 1.40000000) THEN
            $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "Max"( "EnsureReleaseLimits"( "EqualizationRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) ), 8230.00000000 "1000 acre-ft", 9000.00000000 "1000 acre-ft" ), NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"Start Timestep" ) )] ) );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) AND ( "TierIs"( "Upper", @"t", FALSE ) OR "TierIs"( "Equalization", @"t", FALSE ) )) THEN
            IF_STATEMENT (NOT "VolumeDeviationFromEOWYTarget"( "RelativeEOWYDate"( @"t + 2" ) ) == 0.00000000 "acre-ft") THEN
            $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] + "VolumeDeviationFromEOWYTarget"( "RelativeEOWYDate"( @"t + 2" ) );

      END_IF_STATEMENT;

            IF_STATEMENT ($ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 1.40000000) THEN
            $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "EnsureReleaseLimits"( "EqualizationRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) ), 8230.00000000 "1000 acre-ft", 9000.00000000 "1000 acre-ft" );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "Set Upper Balancing Release Volume";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 3.00000000 AND ( @"t" == @"Start Timestep" OR "MonthIs"( { "August" } ) ) AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) AND @"t + 2" <= @"Finish Timestep";
    BEGIN

      IF_STATEMENT (@"t" == @"Start Timestep" AND ( "GetRunCycleIndex"(  ) == 3.00000000 OR "IsYearDemandVariabilityAndRunCycle4"( @"t" ) ) AND "TierIs"( "Upper", @"t", TRUE ) AND NOT "IsInput"( $ "PowellData.AnnualReleaseVolume", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) )) THEN
            $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := WITH DATETIME meadProjecetionDate = IF ( @"t" <= @"September 30" )
   THEN
      @"24:00:00 December 31, Previous Year"
   ELSE
      @"24:00:00 December 31, Current Year"
   ENDIF DO
      IF ( $ "Powell.Pool Elevation" ["DateToCheckEOWYElevation"( @"t", TRUE )] > "EqLevel"( "DateToCheckEOWYElevation"( @"t", TRUE ) ) )
      THEN
         GET @INDEX 0.00000000 FROM "EqualizationTeirCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) )
      ELSE
         IF ( $ "Mead.Pool Elevation" [meadProjecetionDate] >= 1075.00000000 "ft" )
         THEN
            "Max"( "B1_Branch_UpperBalancingTeirVolume"( "DateToCheckEOWYElevation"( @"t", TRUE ) ), NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"Start Timestep" ) )] ) )
         ELSE
            "Max"( "B2_Branch_UpperBalancingTeirVolume"( "DateToCheckEOWYElevation"( @"t", TRUE ) ), NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"Start Timestep" ) )] ) )
         ENDIF
      ENDIF COMMENTED_BY "Check EOWY Powell Elevation.  If above equalization level then go to equalization teir calculation.  If not, continue..."
   ENDWITH;

            WITH_STATEMENT (NUMERIC upperElevBranch = "UpperElevationBalancingBranchCalculation"( "DateToCheckEOWYElevation"( @"t", TRUE ) )) DO
            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := upperElevBranch;

            IF_STATEMENT (upperElevBranch == 1.30000000) THEN
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 0.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := GET @INDEX 1.00000000 FROM "EqualizationTeirCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) );

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      IF_STATEMENT (( "MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) ) AND "TierIs"( "Upper", @"t", FALSE )) THEN
            $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := IF ( $ "Powell.Pool Elevation" ["DateToCheckEOWYElevation"( @"t", FALSE )] > "EqLevel"( "DateToCheckEOWYElevation"( @"t", FALSE ) ) )
   THEN
      GET @INDEX 0.00000000 FROM "EqualizationTeirCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) )
   ELSE
      IF ( $ "Mead.Pool Elevation" [@"24:00:00 December 31, Current Year"] >= 1075.00000000 "ft" )
      THEN
         "B1_Branch_UpperBalancingTeirVolume"( "DateToCheckEOWYElevation"( @"t", FALSE ) )
      ELSE
         "B2_Branch_UpperBalancingTeirVolume"( "DateToCheckEOWYElevation"( @"t", FALSE ) )
      ENDIF
   ENDIF COMMENTED_BY "Check EOWY Powell Elevation.  If above equalization level then go to equalization teir calculation.  If not, continue...";

            WITH_STATEMENT (NUMERIC upperElevBranch = "UpperElevationBalancingBranchCalculation"( "DateToCheckEOWYElevation"( @"t", FALSE ) )) DO
            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := upperElevBranch;

            IF_STATEMENT (upperElevBranch == 1.30000000) THEN
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 0.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := GET @INDEX 1.00000000 FROM "EqualizationTeirCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) );

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "Set Equalization Release Volume";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( "GetRunCycleIndex"(  ) == 3.00000000 AND ( @"t" == @"Start Timestep" OR "MonthIs"( { "August" } ) ) AND @"t + 2" <= @"Finish Timestep" AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) ) COMMENTED_BY "This rule only fires if we are in the third run cycle or in the fourth run cycle and demand variability<br> has changed the demands out of Lake Mead, it is August, and the model has selected the<br> Equalization teir for the current year. - sc 02/02/11 & TP 08/20/2014";
    BEGIN

      IF_STATEMENT (@"t" == @"Start Timestep" AND "TierIs"( "Equalization", @"t", TRUE ) AND NOT "IsInput"( $ "PowellData.AnnualReleaseVolume", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) )) THEN
            $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "Max"( GET @INDEX 0.00000000 FROM "EqualizationTeirCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) ), NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) );

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := GET @INDEX 1.00000000 FROM "EqualizationTeirCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) );

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) AND "TierIs"( "Equalization", @"t", FALSE )) THEN
            $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := GET @INDEX 0.00000000 FROM "EqualizationTeirCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) );

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := GET @INDEX 1.00000000 FROM "EqualizationTeirCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) );

      END_IF_STATEMENT;

    END;

    RULE                 "Preliminary Set Out Year Release Volume To 8.23MAF";
    DESCRIPTION          "This rule preliminarily sets outflows from Powell in order to evaluate the projections of Powell and Mead elevations used for tierthe  selection calculation.  It sets the release volume to 8.23 MAF unless doing so will cause the model to fail by overfilling Powell.  In that case it sets the annual release volumes to the amount needed to just keep Powell below its max elevation.  The rule fires on the first timestep of run cycle 3 and should allow the whole model to solve for this preliminary condition.  Subsequent rules will then calculate the appropriate tier values for each water year in the run and then set the releases from Powell on a monthly basis. - sc 03/25/11";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 3.00000000 AND ( @"t" == @"Start Timestep" OR "MonthIs"( { "August" } ) ) AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) AND @"t + 2" <= @"Finish Timestep";
    BEGIN

      WITH_STATEMENT (NUMERIC watYearIndex = "GetYear"( @"t" ) - "GetYear"( @"Start Timestep" ) + IF ( "GetMonth"( @"Start Timestep" ) > 9.00000000 )
   THEN
      1.00000000
   ELSE
      2.00000000
   ENDIF) DO
            WITH_STATEMENT (NUMERIC availWatPowell = ( IF ( "GetMonth"( @"Start Timestep" ) == 9.00000000 )
   THEN
      $ "Powell.Storage" [@"t - 1"]
   ELSE
      $ "Powell.Storage" [@"t + 1"]
   ENDIF + FOR ( DATETIME date IN "WaterYearDatesByGroup"( watYearIndex ) ) STAT_SUM
      "FlowToVolume"( $ "Powell.Inflow" [date], date )
   ENDFOR ) COMMENTED_BY "This is added to check that in years when Powell might go very low, the model won't bomb out <br>when setting the preliminary release when Powell is low. TP 1/22/2013<br>") DO
            IF_STATEMENT (NOT "IsInput"( $ "PowellData.AnnualReleaseVolume", "Dec31ofYear"( "OffsetDate"( "RelativeEOWYDate"( @"Start Timestep" ), watYearIndex - 1.00000000, "1 years" ) ) )) THEN
            $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "OffsetDate"( "RelativeEOWYDate"( @"Start Timestep" ), watYearIndex - 1.00000000, "1 years" ) )] := "Min"( "Max"( 8230.00000000 "1000 acre-feet", "CalcPrelimReleaseAmt_PreventModelCrash"( "WaterYearDatesByGroup"( watYearIndex ) ) ), availWatPowell );

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "Set Release Tier";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 3.00000000 AND ( @"t" == @"Start Timestep" OR "MonthIs"( { "August" } ) ) AND @"t + 2" <= @"Finish Timestep" AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    BEGIN

    DESCRIPTION          "Model needs to set the teir for the current year if at the start timestep, regardless of month. - sc 02/02/11";
      IF_STATEMENT (@"t" == @"Start Timestep" AND IsNaN $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )]) THEN
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "PowellReleaseTier"( $ "Powell.Pool Elevation" ["DateToCheckJan1Elevation"( @"t", TRUE )], "RelativeEOWYDate"( @"t" ) );

            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 999.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 999.00000000;

      END_IF_STATEMENT;

    DESCRIPTION          "Model needs to set the teir for the following water year if current timestep is August. - sc 02/02/11";
      IF_STATEMENT (( "MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) ) AND @"t + 2" IN "WaterYearDatesByGroup"( 2.00000000 ) AND NOT "IsInput"( $ "PowellData.ReleaseTier", "Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) ) )) THEN
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "PowellReleaseTier"( $ "Powell.Pool Elevation" [@"24:00:00 December 31, Current Year"], "RelativeEOWYDate"( @"t + 2" ) );

            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "August" } ) AND @"t + 2" IN "WaterYearDatesByGroup"( 3.00000000 ) AND NOT "IsInput"( $ "PowellData.ReleaseTier", "Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) ) )) THEN
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "PowellReleaseTier"( $ "Powell.Pool Elevation" [@"24:00:00 December 31, Current Year"], "RelativeEOWYDate"( @"t + 2" ) );

            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "August" } ) AND @"t + 2" IN "WaterYearDatesByGroup"( 4.00000000 ) AND NOT "IsInput"( $ "PowellData.ReleaseTier", "Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) ) )) THEN
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "PowellReleaseTier"( $ "Powell.Pool Elevation" [@"24:00:00 December 31, Current Year"], "RelativeEOWYDate"( @"t + 2" ) );

            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "August" } ) AND @"t + 2" IN "WaterYearDatesByGroup"( 5.00000000 ) AND NOT "IsInput"( $ "PowellData.ReleaseTier", "Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) ) )) THEN
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "PowellReleaseTier"( $ "Powell.Pool Elevation" [@"24:00:00 December 31, Current Year"], "RelativeEOWYDate"( @"t + 2" ) );

            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "August" } ) AND @"t + 2" IN "WaterYearDatesByGroup"( 6.00000000 ) AND NOT "IsInput"( $ "PowellData.ReleaseTier", "Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) ) )) THEN
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "PowellReleaseTier"( $ "Powell.Pool Elevation" [@"24:00:00 December 31, Current Year"], "RelativeEOWYDate"( @"t + 2" ) );

            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

      END_IF_STATEMENT;

    END;

    RULE                 "Preliminary Set WY1 Release Volume To 8.23MAF";
    DESCRIPTION          "This rule preliminarily sets outflows from Powell in order to evaluate the projections of Powell and Mead elevations used for tierthe  selection calculation.  It sets the release volume to 8.23 MAF unless doing so will cause the model to fail by overfilling Powell.  In that case it sets the annual release volumes to the amount needed to just keep Powell below its max elevation.  The rule fires on the first timestep of run cycle 3 and should allow the whole model to solve for this preliminary condition.  Subsequent rules will then calculate the appropriate tier values for each water year in the run and then set the releases from Powell on a monthly basis. - sc 03/25/11";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 3.00000000 AND @"t" == @"Start Timestep" AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    BEGIN

      IF_STATEMENT (NOT "IsInput"( $ "PowellData.AnnualReleaseVolume", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) )) THEN
            $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "MaxItem"( { 8230.00000000 "1000 acre-feet" , "CalcPrelimReleaseAmt_PreventModelCrash"( "WaterYearDatesByGroup"( 1.00000000 ) ) , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) } );

      END_IF_STATEMENT;

    END;

    RULE                 "Set Powell Outflow";
    DESCRIPTION          "In most months, interpolate values from the monthly release table using the current value of annual release volume. In August and September the annual release volume has already been set for the subsequent water year, so use the previous water year's annual volume. ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND ( @"t" == @"Start Timestep" OR "MonthIs"( { "August" } ) ) AND @"t + 2" <= @"Finish Timestep";
    BEGIN

      IF_STATEMENT (@"t" == @"Start Timestep" AND NOT IsNaN $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( 1.00000000 ) ) )]) THEN
            FOREACH (LIST dateRelease IN "GetPowellReleasesCorrectedForBypass"( "Sort"( "GetPowellMonthlyReleases"( "WaterYearDatesByGroup"( 1.00000000 ) ) ) )) DO
            $ "Powell.Outflow" [GET @INDEX 0.00000000 FROM dateRelease] := GET @INDEX 1.00000000 FROM dateRelease;

      ENDFOREACH;

      END_IF_STATEMENT;

      WITH_STATEMENT (NUMERIC waterYearNumber = "GetYear"( @"t" ) - "GetYear"( @"Start Timestep" ) + IF ( "GetMonth"( @"Start Timestep" ) > 9.00000000 )
   THEN
      1.00000000
   ELSE
      2.00000000
   ENDIF) DO
            IF_STATEMENT (NOT IsNaN $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( waterYearNumber ) ) )] AND NOT IsNaN $ "Powell.Outflow" ["RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( IF ( "GetMonth"( @"Start Timestep" ) > 9.00000000 AND @"t" == @"Start Timestep" )
   THEN
      waterYearNumber
   ELSE
      waterYearNumber - 1.00000000
   ENDIF ) )]) THEN
            FOREACH (LIST dateRelease IN "GetPowellReleasesCorrectedForBypass"( "Sort"( "GetPowellMonthlyReleases"( "WaterYearDatesByGroup"( waterYearNumber ) ) ) )) DO
            $ "Powell.Outflow" [GET @INDEX 0.00000000 FROM dateRelease] := GET @INDEX 1.00000000 FROM dateRelease;

      ENDFOREACH;

      END_IF_STATEMENT;

            IF_STATEMENT ("IsInput"( $ "PowellData.AnnualReleaseVolume", "Dec31ofYear"( "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( waterYearNumber ) ) ) )) THEN
            FOREACH (LIST dateRelease IN "Sort"( "GetPowellMonthlyReleases"( "WaterYearDatesByGroup"( waterYearNumber ) ) )) DO
            $ "Powell.Outflow" [GET @INDEX 0.00000000 FROM dateRelease] := GET @INDEX 1.00000000 FROM dateRelease;

      ENDFOREACH;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

    INACTIVE      IF_STATEMENT (@"t" == @"Start Timestep" AND NOT IsNaN $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( 1.00000000 ) ) )]) THEN
            FOREACH (LIST dateRelease IN "GetPowellReleasesCorrectedForBypass"( "Sort"( "GetPowellMonthlyReleases"( "WaterYearDatesByGroup"( 1.00000000 ) ) ) )) DO
            $ "Powell.Outflow" [GET @INDEX 0.00000000 FROM dateRelease] := GET @INDEX 1.00000000 FROM dateRelease;

      ENDFOREACH;

      ELSE
          DESCRIPTION          "Calculates the water year number relative to the water year of the start timestep. This enables the rule to solve for any run length. -TP and HG 1/23/13";
      WITH_STATEMENT (NUMERIC waterYearNumber = "GetYear"( @"t" ) - "GetYear"( @"Start Timestep" ) + IF ( "GetMonth"( @"Start Timestep" ) > 9.00000000 )
   THEN
      1.00000000
   ELSE
      2.00000000
   ENDIF) DO
            IF_STATEMENT (NOT @"t" == @"Start Timestep" AND NOT IsNaN $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( waterYearNumber ) ) )]) THEN
            FOREACH (LIST dateRelease IN "GetPowellReleasesCorrectedForBypass"( "Sort"( "GetPowellMonthlyReleases"( "WaterYearDatesByGroup"( waterYearNumber ) ) ) )) DO
            $ "Powell.Outflow" [GET @INDEX 0.00000000 FROM dateRelease] := GET @INDEX 1.00000000 FROM dateRelease;

      ENDFOREACH;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    END;

  END;

  POLICY_GROUP   "NavajoNew";
  DESCRIPTION    "";
  ACTIVE         FALSE;
  BEGIN

    RULE                 "Fall Peak Release New";
    DESCRIPTION          "This Rule Uses the already set pool elevations for Navajo from the prevoius rule and uses the October Pool elevation to check if the elevation is above 6,065 ft.  If the volume in October is above 6,065 make a relase in September great enough to get the pool elevation at the end of October to 6,065.  The reason we are looking at the October pool elevation is in the rare event that October is Wet, then the pool elevation in September will allow for the high flows in October to result in a Pool Elevation of 6,065 heading into the Winter months.  If we use the September Pool elevation and don' t release enough the system might have to release more the next spring than needed. <br><br>This rule only fires in months after the Spring Peak Release cannot be set (July - September) and only after the model has the opportunity to set outflows from Navajo at the maximum 1,000 cfs per day for the months of July - September. <br><br>TP 9/13/2012";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetMonth"( @"t" ) >= 7.00000000 AND "GetMonth"( @"t" ) <= 9.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    BEGIN

      WITH_STATEMENT (NUMERIC NavOctStor = "ElevationToStorage"( % "Navajo", $ "Navajo.Pool Elevation" [@"24:00:00 September Max DayOfMonth, Current Year"] )) DO
            WITH_STATEMENT (NUMERIC TargetPEStor = "ElevationToStorage"( % "Navajo", $ "NavajoDataNew.EOWYTargetPE" [] )) DO
            IF_STATEMENT (NavOctStor > TargetPEStor) THEN
            $ "Navajo.Outflow" [@"24:00:00 September Max DayOfMonth, Current Year"] := $ "Navajo.Outflow" [@"24:00:00 September Max DayOfMonth, Current Year"] + "VolumeToFlow"( NavOctStor - TargetPEStor, @"24:00:00 September Max DayOfMonth, Current Year" );

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "Dam Protection Flood ControlNew";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      IF_STATEMENT ($ "Navajo.Pool Elevation" [] > $ "NavajoData.PostDamProtectionPE" []) THEN
            $ "Navajo.Outflow" [] := "Min"( $ "Navajo.Outflow" [] + "VolumeToFlow"( "ElevationToStorage"( % "Navajo", $ "Navajo.Pool Elevation" [] ) - "ElevationToStorage"( % "Navajo", $ "NavajoData.PostDamProtectionPE" [] ), @"t" ), 5000.00000000 "cfs" );

            $ "NavajoData.DamProtectionFlag" [@"t"] := 1.00000000;

            $ "NavajoData.VolumeReleasedForDamProtection" ["Dec31ofYear"( @"t" )] := "ElevationToStorage"( % "Navajo", $ "Navajo.Pool Elevation" [] ) - "ElevationToStorage"( % "Navajo", $ "NavajoData.PostDamProtectionPE" [] );

      END_IF_STATEMENT;

    END;

    RULE                 "Reduce Outflow and Diversions if Navajo is below Min LevelNew";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "IsLowFlowAdjustmentNecessary"(  ) AND "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" );
    BEGIN

      FOREACH (LIST DateDiffR IN "DetermineLowFlowsatNavajo"(  )) DO
            $ "Navajo.Outflow" [GET @INDEX 0.00000000 FROM DateDiffR] := GET @INDEX 1.00000000 FROM DateDiffR;

            $ "NavajoIndianIrrigationProjectNIIP.Diversion" [GET @INDEX 0.00000000 FROM DateDiffR] := GET @INDEX 2.00000000 FROM DateDiffR;

          INACTIVE      $ "NavajoIndianIrrigationProjectNIIP.Depletion Requested" [GET @INDEX 0.00000000 FROM DateDiffR] := GET @INDEX 2.00000000 FROM DateDiffR;

      ENDFOREACH;

    END;

    RULE                 "SumNavajoOutflowtoMonthlyNew";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" OR "GetMonth"( @"t" ) == 3.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      WITH_STATEMENT (DATETIME endDate = IF ( "GetMonth"( @"t" ) < 3.00000000 )
   THEN
      @"24:00:00 February Max DayOfMonth, Current Year"
   ELSE
      @"24:00:00 February Max DayOfMonth, Current Year + 12"
   ENDIF) DO
            IF_STATEMENT (@"t" == @"Start Timestep") THEN
            FOREACH (DATETIME date IN "GetDates"( @"t", endDate, "1 months" )) DO
            $ "Navajo.Outflow" [date] := "DetermineNavajoMonthlyFlowVolumeNew"( date ) / 1.00000000 "month";

      ENDFOREACH;

      END_IF_STATEMENT;

            IF_STATEMENT ("MonthIs"( { "March" } )) THEN
            FOREACH (DATETIME date IN "GetDates"( @"24:00:00 March 31, Current Year", @"24:00:00 February Max DayOfMonth, Current Year + 12", "1 months" )) DO
            $ "Navajo.Outflow" [date] := "DetermineNavajoMonthlyFlowVolumeNew"( date ) / 1.00000000 "month";

      ENDFOREACH;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "HitTargetPoolElevationNew";
    DESCRIPTION          "This Rule checks the Releases created from the level release structure and demands and estimates a daily release between July 31 and September 30 to bring the reservoir down to and elevation of 6,065 ft if the inflow allows for an additional release. TP 6/28/2012";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetMonth"( @"t" ) > 3.00000000 OR "GetMonth"( @"t" ) == 3.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      IF_STATEMENT ("NavEndStorWithEvap"(  ) > "ElevationToStorage"( % "Navajo", $ "NavajoData.EOWYTargetPE" [] )) THEN
            IF_STATEMENT ("GetMonth"( @"t" ) >= 10.00000000) THEN
            FOREACH (DATETIME date IN "GetDates"( "DateMax"( "NavDateOfBaseFlowAfterPeak"(  ), @"t" - "GetDaysInMonth"( @"t" ) ), @"24:00:00 September Max DayOfMonth, Current Year + 12", "1 days" )) DO
            $ "NavajoData.NavajoOutflowWithScale" [date] := "Min"( $ "NavajoData.NavajoOutflowWithScale" [date] + ( "NavEndStorWithEvap"(  ) - "ElevationToStorage"( % "Navajo", $ "NavajoData.EOWYTargetPE" [] ) ) / IF ( "GetMonth"( @"t" ) >= 10.00000000 )
   THEN
      @"24:00:00 September Max DayOfMonth, Current Year + 12" - "NavDateOfBaseFlowAfterPeak"(  )
   ELSE
      @"24:00:00 September Max DayOfMonth, Current Year" - "NavDateOfBaseFlowAfterPeak"(  )
   ENDIF, 1000.00000000 "cfs" );

      ENDFOREACH;

      ELSE
            FOREACH (DATETIME date IN "GetDates"( "DateMax"( "NavDateOfBaseFlowAfterPeak"(  ), @"t" - "GetDaysInMonth"( @"t" ) ), @"24:00:00 September Max DayOfMonth, Current Year", "1 days" )) DO
            $ "NavajoData.NavajoOutflowWithScale" [date] := "Min"( $ "NavajoData.NavajoOutflowWithScale" [date] + ( "NavEndStorWithEvap"(  ) - "ElevationToStorage"( % "Navajo", $ "NavajoData.EOWYTargetPE" [] ) ) / IF ( "GetMonth"( @"t" ) >= 10.00000000 )
   THEN
      @"24:00:00 September Max DayOfMonth, Current Year + 12" - "NavDateOfBaseFlowAfterPeak"(  )
   ELSE
      @"24:00:00 September Max DayOfMonth, Current Year" - "NavDateOfBaseFlowAfterPeak"(  )
   ENDIF, 1000.00000000 "cfs" );

      ENDFOREACH;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "CalculateNavajoOutflowNew";
    DESCRIPTION          "This rule sets the daily outflow values that will be summed and applied to the outflow slot at Navajo.  The flows are calculated based on the release levels set in earlier rules and the scale value calculated.  If additional flows are required, then additional releases are added to the flow regime set by the release level.  The additional flow changes the are applied to the ramping up values first then to the ramping down values if needed. <br><br>This No Longer Applies as the Animas and diversions have been added to the functions. 6/20/2014 --The functions with this rule (DeterminSpringReleaseExctentionCurrentYear and DetermineSpringReleaseExtentionFutureYear) are where the Animas Flow and Downstream user diversions can be added in if those slot values are to be added into the SanJuanBelowNavajo object.  The annual volumes and monthly distribution for the down stream diversions can be found in the NavajoData Object and the Animas flows are input on the SanJaunBelwoNavajo Slot. TP 6/28/2012<br><br>";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" OR "GetMonth"( @"t" ) == 3.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    BEGIN

      WITH_STATEMENT (NUMERIC AvailH2O = "ComputeWaterReqdForAnnRelease"( @"t" )) DO
            WITH_STATEMENT (NUMERIC TarPEVol = "ComputeWaterReqdForEOYTPE"( @"t" )) DO
            WITH_STATEMENT (NUMERIC Release4Now = "DetermineLevelRelease"(  )) DO
            WITH_STATEMENT (DATETIME endDate = IF ( "GetMonth"( @"t" ) < 3.00000000 )
   THEN
      @"24:00:00 February Max DayOfMonth, Current Year"
   ELSE
      @"24:00:00 February Max DayOfMonth, Current Year + 12"
   ENDIF) DO
            IF_STATEMENT (@"t" == @"Start Timestep") THEN
            IF_STATEMENT ($ "NavajoData.ReleaseLevel" [@"24:00:00 December 31, Current Year"] == 0.00000000 OR IsNaN $ "NavajoData.ReleaseLevel" [@"24:00:00 December 31, Current Year"]) THEN
            FOREACH (DATETIME date IN "GetDates"( @"t - 1", endDate, "1 days" )) DO
            $ "NavajoData.NavajoOutflowWithScale" [date] := "CalcFlowAboveBaseForDSDiversions"( date );

      ENDFOREACH;

      ELSE
            FOREACH (DATETIME date IN "GetDates"( @"t - 1", endDate, "1 days" )) DO
            $ "NavajoData.NavajoOutflowWithScale" [date] := "DetermineSpringReleaseExtentionCurrentYear"( date, TarPEVol, Release4Now );

      ENDFOREACH;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

            IF_STATEMENT ("MonthIs"( { "March" } )) THEN
            IF_STATEMENT ($ "NavajoData.ReleaseLevel" [@"24:00:00 December 31, Current Year"] == 0.00000000 OR IsNaN $ "NavajoData.ReleaseLevel" [@"24:00:00 December 31, Current Year"]) THEN
            FOREACH (DATETIME date IN "GetDates"( @"24:00:00 March 1, Current Year", @"24:00:00 February Max DayOfMonth, Current Year + 12", "1 days" )) DO
            $ "NavajoData.NavajoOutflowWithScale" [date] := "CalcFlowAboveBaseForDSDiversions"( date );

      ENDFOREACH;

      ELSE
            FOREACH (DATETIME date IN "GetDates"( @"24:00:00 March 1, Current Year", @"24:00:00 February Max DayOfMonth, Current Year + 12", "1 days" )) DO
            $ "NavajoData.NavajoOutflowWithScale" [date] := "DetermineSpringReleaseExtentionForwardYears"( date, TarPEVol, Release4Now );

      ENDFOREACH;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "March through July Daily ReleaseNew";
    DESCRIPTION          "Calculate the Daily release given the policy constraints outlined by the Flow recomendation document from the San Juan Flow Recommendations.  These flows will be based on the policy from the release level calculated and not the acual available water. That will come after a scale value is applied. <br>TP May312012<br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" OR "GetMonth"( @"t" ) == 3.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      IF_STATEMENT (@"t" == @"Start Timestep") THEN
            IF_STATEMENT ("GetMonth"( @"t" ) >= 3.00000000 AND "GetMonth"( @"t" ) <= 7.00000000) THEN
            FOREACH (DATETIME date IN "GetDates"( @"t - 1", @"24:00:00 February Max DayOfMonth, Current Year + 12", "1 days" )) DO
            $ "NavajoDataNew.MarchThruJulyDaily" [date] := "DailyOutflowsForNavajo"( date, $ "NavajoDataNew.ReleaseLevel" ["Dec31ofYear"( @"t" )], $ "NavajoDataNew.NoseLevel" ["Dec31ofYear"( @"t" )], $ "NavajoDataNew.ExcessOfRelease" ["Dec31ofYear"( @"t" )] );

      ENDFOREACH;

      ELSE
            IF_STATEMENT ("GetMonth"( @"t" ) >= 8.00000000) THEN
            FOREACH (DATETIME date IN "GetDates"( @"t - 1", @"24:00:00 February Max DayOfMonth, Current Year + 12", "1 days" )) DO
            $ "NavajoDataNew.MarchThruJulyDaily" [date] := "DailyOutflowsForNavajo"( date, $ "NavajoDataNew.ReleaseLevel" ["Dec31ofYear"( @"t" )], $ "NavajoDataNew.NoseLevel" ["Dec31ofYear"( @"t" )], $ "NavajoDataNew.ExcessOfRelease" ["Dec31ofYear"( @"t" )] );

      ENDFOREACH;

      ELSE
            FOREACH (DATETIME date IN "GetDates"( @"t - 1", @"24:00:00 February Max DayOfMonth, Current Year", "1 days" )) DO
            $ "NavajoDataNew.MarchThruJulyDaily" [date] := "DailyOutflowsForNavajo"( date, $ "NavajoDataNew.ReleaseLevel" ["Dec31ofYear"( @"t" )], $ "NavajoDataNew.NoseLevel" ["Dec31ofYear"( @"t" )], $ "NavajoDataNew.ExcessOfRelease" ["Dec31ofYear"( @"t" )] );

      ENDFOREACH;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ELSE
            FOREACH (DATETIME date IN "GetDates"( @"24:00:00 March 1, Current Year", @"24:00:00 February Max DayOfMonth, Current Year + 12", "1 days" )) DO
            $ "NavajoDataNew.MarchThruJulyDaily" [date] := "DailyOutflowsForNavajo"( date, $ "NavajoDataNew.ReleaseLevel" ["Dec31ofYear"( @"t" )], $ "NavajoDataNew.NoseLevel" ["Dec31ofYear"( @"t" )], $ "NavajoDataNew.ExcessOfRelease" ["Dec31ofYear"( @"t" )] );

      ENDFOREACH;

      END_IF_STATEMENT;

    END;

    RULE                 "DetermineReleaseLevelValues";
    DESCRIPTION          "Determine the release level (0-4) for the sping release based on the calculated available flow to hit the EOWYTargetPE. The determination of level is based on the values in the SpringPeakReleaseLevels table.  The Rule sets the Release Level, the Spring Peak Releas Volume, The Nose Level (If Applicable), the Nose Volume (if Applicable), the excess of a Nose Volume (If Applicable), <br>TP May312012<br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000 AND ( @"t" == @"Start Timestep" OR "MonthIs"( { "March" } ) ) AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    BEGIN

      IF_STATEMENT (NOT "IsInput"( $ "NavajoDataNew.ReleaseLevel", "Dec31ofYear"( @"t" ) )) THEN
            IF_STATEMENT (@"t" == @"Start Timestep") THEN
            IF_STATEMENT ("GetMonth"( @"t" ) >= 10.00000000) THEN
            $ "NavajoDataNew.ReleaseLevel" ["Dec31ofYear"( @"t" )] := 0.00000000;

            $ "NavajoDataNew.SpringPeakRelease" ["Dec31ofYear"( @"t" )] := 0.00000000 "acre-ft";

            $ "NavajoDataNew.NoseLevel" ["Dec31ofYear"( @"t" )] := 0.00000000;

            $ "NavajoDataNew.SpringPeakNose" ["Dec31ofYear"( @"t" )] := 0.00000000 "acre-ft";

            $ "NavajoDataNew.ExcessOfRelease" ["Dec31ofYear"( @"t" )] := 0.00000000 "acre-ft";

      ELSE
            $ "NavajoDataNew.ReleaseLevel" ["Dec31ofYear"( @"t" )] := GET @INDEX 1.00000000 FROM "DetermineNavajoEoWYReleaseLevelNew"( "Dec31ofYear"( @"t" ) );

            $ "NavajoDataNew.SpringPeakRelease" ["Dec31ofYear"( @"t" )] := GET @INDEX 0.00000000 FROM "DetermineNavajoEoWYReleaseLevelNew"( "Dec31ofYear"( @"t" ) );

            $ "NavajoDataNew.NoseLevel" ["Dec31ofYear"( @"t" )] := GET @INDEX 2.00000000 FROM "DetermineNavajoEoWYReleaseLevelNew"( "Dec31ofYear"( @"t" ) );

            $ "NavajoDataNew.SpringPeakNose" ["Dec31ofYear"( @"t" )] := GET @INDEX 3.00000000 FROM "DetermineNavajoEoWYReleaseLevelNew"( "Dec31ofYear"( @"t" ) );

            $ "NavajoDataNew.ExcessOfRelease" ["Dec31ofYear"( @"t" )] := GET @INDEX 4.00000000 FROM "DetermineNavajoEoWYReleaseLevelNew"( "Dec31ofYear"( @"t" ) );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

            IF_STATEMENT ("MonthIs"( { "March" } )) THEN
            $ "NavajoDataNew.ReleaseLevel" ["Dec31ofYear"( @"t" )] := GET @INDEX 1.00000000 FROM "DetermineNavajoEoWYReleaseLevelNew"( "Dec31ofYear"( @"t" ) );

            $ "NavajoDataNew.SpringPeakRelease" ["Dec31ofYear"( @"t" )] := GET @INDEX 0.00000000 FROM "DetermineNavajoEoWYReleaseLevelNew"( "Dec31ofYear"( @"t" ) );

            $ "NavajoDataNew.NoseLevel" ["Dec31ofYear"( @"t" )] := GET @INDEX 2.00000000 FROM "DetermineNavajoEoWYReleaseLevelNew"( "Dec31ofYear"( @"t" ) );

            $ "NavajoDataNew.SpringPeakNose" ["Dec31ofYear"( @"t" )] := GET @INDEX 3.00000000 FROM "DetermineNavajoEoWYReleaseLevelNew"( "Dec31ofYear"( @"t" ) );

            $ "NavajoDataNew.ExcessOfRelease" ["Dec31ofYear"( @"t" )] := GET @INDEX 4.00000000 FROM "DetermineNavajoEoWYReleaseLevelNew"( "Dec31ofYear"( @"t" ) );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "Preliminarily Set Navajo Outflow to Desired Base Flow";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT NOT "IsInput"( $ "NavajoDataNew.ReleaseLevel", "Dec31ofYear"( @"t" ) );
    BEGIN

      WITH_STATEMENT (NUMERIC waterYearNumber = "GetYear"( @"t" ) - "GetYear"( @"Start Timestep" ) + IF ( "GetMonth"( @"Start Timestep" ) > 9.00000000 )
   THEN
      1.00000000
   ELSE
      2.00000000
   ENDIF) DO
            WITH_STATEMENT (LIST dateList = IF ( @"t" == @"Start Timestep" AND NOT "IsInput"( $ "NavajoDataNew.ReleaseLevel", "Dec31ofYear"( @"t" ) ) AND "GetMonth"( @"t" ) < 10.00000000 )
   THEN
      @"t" TO @"24:00:00 February Max DayOfMonth, Current Year + 12 Month"
   ELSE
      @"t" TO @"24:00:00 February Max DayOfMonth, Current Year + 12 Month"
   ENDIF) DO
            FOREACH (DATETIME date IN dateList) DO
            $ "Navajo.Outflow" [date] := $ "NavajoDataNew.MinTargetBaseflow" [];

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "SetNavajoDiversionsNew";
    DESCRIPTION          "Sets the NIIPDiversions Requested slot, the SanJuanBelowNavajo.TotalDiversion Slot, and NIIP.Fractional Return Flow Slot values based on user input.  The Fractional Inflow values will at some point need to be changed in the future to the value that would be the fractional return flow. This rule fires so that the input values in the NavajoData.NIIPAnnualRequest and NavajoData.SJDownstreamDiversions slots  are assigned if input is provided for those two slots.  TP 8/5/2012";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000 AND @"t" == @"Start Timestep";
    BEGIN

      FOREACH (DATETIME date IN "GetDates"( @"Start Timestep", @"Finish Timestep", "1 Months" )) DO
            IF_STATEMENT (IsNaN $ "SanJuanBelowNavajo.Total Diversion" [date]) THEN
            $ "SanJuanBelowNavajo.Total Diversion" [date] := $ "NavajoData.SJDownstreamDepletions" [date, 0.00000000];

      END_IF_STATEMENT;

            $ "NavajoIndianIrrigationProjectNIIP.Fractional Return Flow" [date] := 0.00000000;

            $ "NavajoIndianIrrigationProjectNIIP.Diversion" [date] := $ "NavajoIndianIrrigationProjectNIIP.Diversion Requested" [date];

            $ "Azotea Tunnel.Diversion" [date] := "Min"( $ "Azotea Tunnel.Diversion Requested" [date], "Max"( $ "UpperSanJuan.Inflow" [date] - $ "Azotea Tunnel.Diversion Requested" [date], 0.00000000 "cfs" ) );

      ENDFOREACH;

    END;

  END;

  POLICY_GROUP   "Navajo";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Fall Peak Release ";
    DESCRIPTION          "This Rule Uses the already set pool elevations for Navajo from the prevoius rule and uses the October Pool elevation to check if the elevation is above 6,065 ft.  If the volume in October is above 6,065 make a relase in September great enough to get the pool elevation at the end of October to 6,065.  The reason we are looking at the October pool elevation is in the rare event that October is Wet, then the pool elevation in September will allow for the high flows in October to result in a Pool Elevation of 6,065 heading into the Winter months.  If we use the September Pool elevation and don' t release enough the system might have to release more the next spring than needed. <br><br>This rule only fires in months after the Spring Peak Release cannot be set (July - September) and only after the model has the opportunity to set outflows from Navajo at the maximum 1,000 cfs per day for the months of July - September. <br><br>TP 9/13/2012";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetMonth"( @"t" ) >= 7.00000000 AND "GetMonth"( @"t" ) <= 9.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    BEGIN

      WITH_STATEMENT (NUMERIC NavOctStor = "ElevationToStorage"( % "Navajo", $ "Navajo.Pool Elevation" [@"24:00:00 October Max DayOfMonth, Current Year"] )) DO
            WITH_STATEMENT (NUMERIC TargetPEStor = "ElevationToStorage"( % "Navajo", $ "NavajoData.EOWYTargetPE" [] )) DO
            IF_STATEMENT (NavOctStor > TargetPEStor) THEN
            $ "Navajo.Outflow" [@"24:00:00 September Max DayOfMonth, Current Year"] := $ "Navajo.Outflow" [@"24:00:00 September Max DayOfMonth, Current Year"] + "VolumeToFlow"( NavOctStor - TargetPEStor, @"24:00:00 September Max DayOfMonth, Current Year" );

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "Dam Protection Flood Control";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      IF_STATEMENT ($ "Navajo.Pool Elevation" [] > $ "NavajoData.PostDamProtectionPE" []) THEN
            $ "Navajo.Outflow" [] := "Min"( $ "Navajo.Outflow" [] + "VolumeToFlow"( "ElevationToStorage"( % "Navajo", $ "Navajo.Pool Elevation" [] ) - "ElevationToStorage"( % "Navajo", $ "NavajoData.PostDamProtectionPE" [] ), @"t" ), 5000.00000000 "cfs" );

            $ "NavajoData.DamProtectionFlag" [@"t"] := 1.00000000;

            $ "NavajoData.VolumeReleasedForDamProtection" ["Dec31ofYear"( @"t" )] := "ElevationToStorage"( % "Navajo", $ "Navajo.Pool Elevation" [] ) - "ElevationToStorage"( % "Navajo", $ "NavajoData.PostDamProtectionPE" [] );

      END_IF_STATEMENT;

    END;

    RULE                 "Reduce Outflow and Diversions if Navajo is below Min Level";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "IsLowFlowAdjustmentNecessary"(  ) AND "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" );
    BEGIN

      FOREACH (LIST DateDiffR IN "DetermineLowFlowsatNavajo"(  )) DO
            $ "Navajo.Outflow" [GET @INDEX 0.00000000 FROM DateDiffR] := GET @INDEX 1.00000000 FROM DateDiffR;

            $ "NavajoIndianIrrigationProjectNIIP.Diversion" [GET @INDEX 0.00000000 FROM DateDiffR] := GET @INDEX 2.00000000 FROM DateDiffR;

          INACTIVE      $ "NavajoIndianIrrigationProjectNIIP.Depletion Requested" [GET @INDEX 0.00000000 FROM DateDiffR] := GET @INDEX 2.00000000 FROM DateDiffR;

      ENDFOREACH;

    END;

    RULE                 "SumNavajoOutflowtoMonthly";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" OR "GetMonth"( @"t" ) == 3.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      WITH_STATEMENT (DATETIME endDate = IF ( "GetMonth"( @"t" ) < 3.00000000 )
   THEN
      @"24:00:00 February Max DayOfMonth, Current Year"
   ELSE
      @"24:00:00 February Max DayOfMonth, Current Year + 12"
   ENDIF) DO
            IF_STATEMENT (@"t" == @"Start Timestep") THEN
            FOREACH (DATETIME date IN "GetDates"( @"t", endDate, "1 months" )) DO
            $ "Navajo.Outflow" [date] := "DetermineNavajoMonthlyFlowVolume"( date ) / 1.00000000 "month";

      ENDFOREACH;

      END_IF_STATEMENT;

            IF_STATEMENT ("MonthIs"( { "March" } )) THEN
            FOREACH (DATETIME date IN "GetDates"( @"24:00:00 March 31, Current Year", @"24:00:00 February Max DayOfMonth, Current Year + 12", "1 months" )) DO
            $ "Navajo.Outflow" [date] := "DetermineNavajoMonthlyFlowVolume"( date ) / 1.00000000 "month";

      ENDFOREACH;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "HitTargetPoolElevation";
    DESCRIPTION          "This Rule checks the Releases created from the level release structure and demands and estimates a daily release between July 31 and September 30 to bring the reservoir down to and elevation of 6,065 ft if the inflow allows for an additional release. TP 6/28/2012";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetMonth"( @"t" ) > 3.00000000 OR "GetMonth"( @"t" ) == 3.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      IF_STATEMENT ("NavEndStorWithEvap"(  ) > "ElevationToStorage"( % "Navajo", $ "NavajoData.EOWYTargetPE" [] )) THEN
            IF_STATEMENT ("GetMonth"( @"t" ) >= 10.00000000) THEN
            FOREACH (DATETIME date IN "GetDates"( "DateMax"( "NavDateOfBaseFlowAfterPeak"(  ), @"t" - "GetDaysInMonth"( @"t" ) ), @"24:00:00 September Max DayOfMonth, Current Year + 12", "1 days" )) DO
            $ "NavajoData.NavajoOutflowWithScale" [date] := "Min"( $ "NavajoData.NavajoOutflowWithScale" [date] + ( "NavEndStorWithEvap"(  ) - "ElevationToStorage"( % "Navajo", $ "NavajoData.EOWYTargetPE" [] ) ) / IF ( "GetMonth"( @"t" ) >= 10.00000000 )
   THEN
      @"24:00:00 September Max DayOfMonth, Current Year + 12" - "NavDateOfBaseFlowAfterPeak"(  )
   ELSE
      @"24:00:00 September Max DayOfMonth, Current Year" - "NavDateOfBaseFlowAfterPeak"(  )
   ENDIF, 1000.00000000 "cfs" );

      ENDFOREACH;

      ELSE
            FOREACH (DATETIME date IN "GetDates"( "DateMax"( "NavDateOfBaseFlowAfterPeak"(  ), @"t" - "GetDaysInMonth"( @"t" ) ), @"24:00:00 September Max DayOfMonth, Current Year", "1 days" )) DO
            $ "NavajoData.NavajoOutflowWithScale" [date] := "Min"( $ "NavajoData.NavajoOutflowWithScale" [date] + ( "NavEndStorWithEvap"(  ) - "ElevationToStorage"( % "Navajo", $ "NavajoData.EOWYTargetPE" [] ) ) / IF ( "GetMonth"( @"t" ) >= 10.00000000 )
   THEN
      @"24:00:00 September Max DayOfMonth, Current Year + 12" - "NavDateOfBaseFlowAfterPeak"(  )
   ELSE
      @"24:00:00 September Max DayOfMonth, Current Year" - "NavDateOfBaseFlowAfterPeak"(  )
   ENDIF, 1000.00000000 "cfs" );

      ENDFOREACH;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "CalculateNavajoOutflow";
    DESCRIPTION          "This rule sets the daily outflow values that will be summed and applied to the outflow slot at Navajo.  The flows are calculated based on the release levels set in earlier rules and the scale value calculated.  If additional flows are required, then additional releases are added to the flow regime set by the release level.  The additional flow changes the are applied to the ramping up values first then to the ramping down values if needed. <br><br>This No Longer Applies as the Animas and diversions have been added to the functions. 6/20/2014 --The functions with this rule (DeterminSpringReleaseExctentionCurrentYear and DetermineSpringReleaseExtentionFutureYear) are where the Animas Flow and Downstream user diversions can be added in if those slot values are to be added into the SanJuanBelowNavajo object.  The annual volumes and monthly distribution for the down stream diversions can be found in the NavajoData Object and the Animas flows are input on the SanJaunBelwoNavajo Slot. TP 6/28/2012<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" OR "GetMonth"( @"t" ) == 3.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    BEGIN

      WITH_STATEMENT (NUMERIC AvailH2O = "ComputeWaterReqdForAnnRelease"( @"t" )) DO
            WITH_STATEMENT (NUMERIC TarPEVol = "ComputeWaterReqdForEOYTPE"( @"t" )) DO
            WITH_STATEMENT (NUMERIC Release4Now = "DetermineLevelRelease"(  )) DO
            WITH_STATEMENT (DATETIME endDate = IF ( "GetMonth"( @"t" ) < 3.00000000 )
   THEN
      @"24:00:00 February Max DayOfMonth, Current Year"
   ELSE
      @"24:00:00 February Max DayOfMonth, Current Year + 12"
   ENDIF) DO
            IF_STATEMENT (@"t" == @"Start Timestep") THEN
            IF_STATEMENT ($ "NavajoData.ReleaseLevel" [@"24:00:00 December 31, Current Year"] == 0.00000000 OR IsNaN $ "NavajoData.ReleaseLevel" [@"24:00:00 December 31, Current Year"]) THEN
            FOREACH (DATETIME date IN "GetDates"( @"t - 1", endDate, "1 days" )) DO
            $ "NavajoData.NavajoOutflowWithScale" [date] := "CalcFlowAboveBaseForDSDiversions"( date );

      ENDFOREACH;

      ELSE
            FOREACH (DATETIME date IN "GetDates"( @"t - 1", endDate, "1 days" )) DO
            $ "NavajoData.NavajoOutflowWithScale" [date] := "DetermineSpringReleaseExtentionCurrentYear"( date, TarPEVol, Release4Now );

      ENDFOREACH;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

            IF_STATEMENT ("MonthIs"( { "March" } )) THEN
            IF_STATEMENT ($ "NavajoData.ReleaseLevel" [@"24:00:00 December 31, Current Year"] == 0.00000000 OR IsNaN $ "NavajoData.ReleaseLevel" [@"24:00:00 December 31, Current Year"]) THEN
            FOREACH (DATETIME date IN "GetDates"( @"24:00:00 March 1, Current Year", @"24:00:00 February Max DayOfMonth, Current Year + 12", "1 days" )) DO
            $ "NavajoData.NavajoOutflowWithScale" [date] := "CalcFlowAboveBaseForDSDiversions"( date );

      ENDFOREACH;

      ELSE
            FOREACH (DATETIME date IN "GetDates"( @"24:00:00 March 1, Current Year", @"24:00:00 February Max DayOfMonth, Current Year + 12", "1 days" )) DO
            $ "NavajoData.NavajoOutflowWithScale" [date] := "DetermineSpringReleaseExtentionForwardYears"( date, TarPEVol, Release4Now );

      ENDFOREACH;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "March through July Daily Release";
    DESCRIPTION          "Calculate the Daily release given the policy constraints outlined by the Flow recomendation document from the San Juan Flow Recommendations.  These flows will be based on the policy from the release level calculated and not the acual available water. That will come after a scale value is applied. <br>TP May312012<br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" OR "GetMonth"( @"t" ) == 3.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      IF_STATEMENT (@"t" == @"Start Timestep") THEN
            IF_STATEMENT ($ "NavajoData.ReleaseLevelforTEoYPE" [@"24:00:00 December 31, Current Year"] == 0.00000000) THEN
            FOREACH (DATETIME date IN "GetDates"( @"t - 1", @"24:00:00 February Max DayOfMonth, Current Year + 12", "1 days" )) DO
            $ "NavajoData.MarchThruJulyDaily" [date] := $ "NavajoData.BaseRelease" [];

      ENDFOREACH;

      ELSE
            IF_STATEMENT ("GetMonth"( @"t" ) >= 3.00000000 AND "GetMonth"( @"t" ) <= 7.00000000) THEN
            FOREACH (DATETIME date IN "GetDates"( @"t - 1", @"24:00:00 February Max DayOfMonth, Current Year + 12", "1 days" )) DO
            $ "NavajoData.MarchThruJulyDaily" [date] := "PeakReleaseatNavajo"( date );

      ENDFOREACH;

      ELSE
            IF_STATEMENT ("GetMonth"( @"t" ) >= 8.00000000) THEN
            FOREACH (DATETIME date IN "GetDates"( @"t - 1", @"24:00:00 February Max DayOfMonth, Current Year + 12", "1 days" )) DO
            $ "NavajoData.MarchThruJulyDaily" [date] := $ "NavajoData.BaseRelease" [];

      ENDFOREACH;

      ELSE
            FOREACH (DATETIME date IN "GetDates"( @"t - 1", @"24:00:00 February Max DayOfMonth, Current Year", "1 days" )) DO
            $ "NavajoData.MarchThruJulyDaily" [date] := $ "NavajoData.BaseRelease" [];

      ENDFOREACH;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ELSE
            IF_STATEMENT ($ "NavajoData.ReleaseLevelforTEoYPE" [@"24:00:00 December 31, Current Year"] == 0.00000000) THEN
            FOREACH (DATETIME date IN "GetDates"( @"24:00:00 March 1, Current Year", @"24:00:00 February Max DayOfMonth, Current Year + 12", "1 days" )) DO
            $ "NavajoData.MarchThruJulyDaily" [date] := $ "NavajoData.BaseRelease" [];

      ENDFOREACH;

      ELSE
            FOREACH (DATETIME date IN "GetDates"( @"24:00:00 March 1, Current Year", @"24:00:00 February Max DayOfMonth, Current Year + 12", "1 days" )) DO
            $ "NavajoData.MarchThruJulyDaily" [date] := "PeakReleaseatNavajo"( date );

      ENDFOREACH;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "DetermineReleaseLevel";
    DESCRIPTION          "Determine the release level (0-3) for the sping release based on the calculated available flow. The determination of level is based on a flow matrix that can be found in the Flow Recommendations Document from the San Juan Basin Recover Implementation Program. <br>TP May312012<br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000 AND ( @"t" == @"Start Timestep" OR "MonthIs"( { "March" } ) ) AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    BEGIN

      IF_STATEMENT (NOT "IsInput"( $ "NavajoData.ReleaseLevel", "Dec31ofYear"( @"t" ) )) THEN
            IF_STATEMENT (@"t" == @"Start Timestep") THEN
            IF_STATEMENT ("GetMonth"( @"t" ) >= 10.00000000) THEN
            $ "NavajoData.ReleaseLevel" ["Dec31ofYear"( @"t" )] := 0.00000000;

            $ "NavajoData.ReleaseLevelforTEoYPE" ["Dec31ofYear"( @"t" )] := 0.00000000;

      ELSE
            $ "NavajoData.ReleaseLevel" ["Dec31ofYear"( @"t" )] := "DetermineNavajoEoWYReleaseLevel"( "Dec31ofYear"( @"t" ) );

            $ "NavajoData.ReleaseLevelforTEoYPE" ["Dec31ofYear"( @"t" )] := "DetermineNavajoEoWYReleaseLevel"( "Dec31ofYear"( @"t" ) );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

            IF_STATEMENT ("MonthIs"( { "March" } )) THEN
            $ "NavajoData.ReleaseLevel" ["Dec31ofYear"( @"t" )] := "DetermineNavajoEoWYReleaseLevel"( "Dec31ofYear"( @"t" ) );

            $ "NavajoData.ReleaseLevelforTEoYPE" ["Dec31ofYear"( @"t" )] := "DetermineNavajoEoWYReleaseLevel"( "Dec31ofYear"( @"t" ) );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "SetNavajoDiversions";
    DESCRIPTION          "Sets the NIIPDiversions Requested slot, the SanJuanBelowNavajo.TotalDiversion Slot, and NIIP.Fractional Return Flow Slot values based on user input.  The Fractional Inflow values will at some point need to be changed in the future to the value that would be the fractional return flow. This rule fires so that the input values in the NavajoData.NIIPAnnualRequest and NavajoData.SJDownstreamDiversions slots  are assigned if input is provided for those two slots.  TP 8/5/2012";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000 AND @"t" == @"Start Timestep";
    BEGIN

      FOREACH (DATETIME date IN "GetDates"( @"Start Timestep", @"Finish Timestep", "1 Months" )) DO
            IF_STATEMENT (IsNaN $ "SanJuanBelowNavajo.Total Diversion" [date]) THEN
            $ "SanJuanBelowNavajo.Total Diversion" [date] := $ "NavajoData.SJDownstreamDepletions" [date, 0.00000000];

      END_IF_STATEMENT;

            $ "NavajoIndianIrrigationProjectNIIP.Fractional Return Flow" [date] := 0.00000000;

            $ "NavajoIndianIrrigationProjectNIIP.Diversion" [date] := $ "NavajoIndianIrrigationProjectNIIP.Diversion Requested" [date];

            $ "Azotea Tunnel.Diversion" [date] := "Min"( $ "Azotea Tunnel.Diversion Requested" [date], "Max"( $ "UpperSanJuan.Inflow" [date] - $ "Azotea Tunnel.Diversion Requested" [date], 0.00000000 "cfs" ) );

      ENDFOREACH;

    END;

  END;

  POLICY_GROUP   "Flaming Gorge_OLD";
  DESCRIPTION    "";
  ACTIVE         FALSE;
  BEGIN

    RULE                 "RIP Adjusted Release Request";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT NOT IsNaN $ "FlamingGorgeData.RipAdjustedReleaseRequest" [];
    BEGIN

      $ "FlamingGorge.Outflow" [] := $ "FlamingGorgeData.RipAdjustedReleaseRequest" [];

    END;

    RULE                 "Shift Water for Power Generation";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT TRUE;
    BEGIN

    END;

    RULE                 "Spill for PE Control";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 2.00000000;
    BEGIN

      IF_STATEMENT ($ "FlamingGorge.Pool Elevation" [] > $ "FlamingGorgeData.MaxPE" []) THEN
            $ "FlamingGorgeData.ManualSpill" [] := $ "FlamingGorgeData.ManualSpill" [] + "VolumeToFlow"( "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorge.Pool Elevation" [] ) - "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorgeData.MaxPE" [] ), @"t" );

            $ "FlamingGorge.Outflow" [] := $ "FlamingGorge.Outflow" [] + "VolumeToFlow"( "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorge.Pool Elevation" [] ) - "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorgeData.MaxPE" [] ), @"t" );

            $ "FlamingGorge.Bypass" [] := "Min"( $ "FlamingGorge.Bypass" [] + "VolumeToFlow"( "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorge.Pool Elevation" [] ) - "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorgeData.MaxPE" [] ), @"t" ), ( $ "FlamingGorgeData.BypassCharacteristics" [0.00000000, "Bypass Capacity"] - $ "FlamingGorgeData.PowerPlantCapacity" [] ) COMMENTED_BY "The actual bypass capacity, not counting the amount that can go through the power plant" );

      END_IF_STATEMENT;

    END;

    RULE                 "Min Flow in Extremely Dry Years with Low Storage";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "MonthIs"( { "January" , "February" , "March" , "April" , "August" , "September" , "October" , "November" , "December" } ) AND "GetRunCycleIndex"(  ) == 2.00000000;
    BEGIN

      IF_STATEMENT ($ "FlamingGorge.Pool Elevation" [] < $ "FlamingGorgeData.MinReleaseTrigger" []) THEN
            $ "FlamingGorge.Outflow" [] := $ "FlamingGorgeData.AbsoluteMinRelease" [];

            $ "FlamingGorgeData.LowReleaseFlag" [] := 1.00000000;

      END_IF_STATEMENT;

    END;

    RULE                 "Recalculate June July Baseflow";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "MonthIs"( { "June" , "July" } ) AND "GetRunCycleIndex"(  ) == 2.00000000 AND @"t" != @"Start Timestep";
    BEGIN

      $ "FlamingGorge.Outflow" [] := IF ( $ "FlamingGorgeData.DailyFGOutflow" ["GetStartDayOfMonth"(  )] == $ "FlamingGorgeData.DailyFGOutflow" ["GetEndDayOfMonth"(  )] )
   THEN
      "Max"( "GetFGBaseFlowMagnitude"(  ), ( "VolumeToFlow"( "PrevStorage"( % "FlamingGorge" ), @"t" ) + $ "FlamingGorge.Inflow" [] - "VolumeToFlow"( "ElevationToStorage"( % "FlamingGorge", 6039.50000000 "ft" ), @"t" ) ) COMMENTED_BY "Check for Spill -HG 10/5/12" )
   ENDIF;

    END;

    RULE                 "Spring Flow Operations ";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "MonthIs"( { "May" , "June" , "July" } ) AND "GetRunCycleIndex"(  ) == 2.00000000;
    BEGIN

      IF_STATEMENT (@"t" == @"Start Timestep" AND ( "GetMonthAsString"( @"Start Timestep" ) == "June" OR "GetMonthAsString"( @"Start Timestep" ) == "July" )) THEN
            IF_STATEMENT ("GetMonthAsString"( @"t" ) == "June") THEN
          DESCRIPTION          "Adjust calculated June releases to account for any difference between actual and calculated May releases. -HG 10/5/12";
      $ "FlamingGorge.Outflow" [] := WITH NUMERIC adjustment = $ "FlamingGorgeData.MonthlyFGOutflow" [@"24:00:00 May Max DayOfMonth, Current Year"] - $ "FlamingGorge.Outflow" [@"24:00:00 May Max DayOfMonth, Current Year"] DO
      "Max"( $ "FlamingGorgeData.MonthlyFGOutflow" [] + adjustment, 0.00000000 "cfs" )
   ENDWITH;

      ELSE
          DESCRIPTION          "Adjust calculated July releases to account for any difference between actual and calculated May and June releases. -HG 10/5/12";
      $ "FlamingGorge.Outflow" [] := WITH NUMERIC adjustment = ( $ "FlamingGorgeData.MonthlyFGOutflow" [@"24:00:00 May Max DayOfMonth, Current Year"] + $ "FlamingGorgeData.MonthlyFGOutflow" [@"24:00:00 June Max DayOfMonth, Current Year"] ) - ( $ "FlamingGorge.Outflow" [@"24:00:00 May Max DayOfMonth, Current Year"] + $ "FlamingGorge.Outflow" [@"24:00:00 June Max DayOfMonth, Current Year"] ) DO
      "Max"( $ "FlamingGorgeData.MonthlyFGOutflow" [] + adjustment, 0.00000000 "cfs" )
   ENDWITH;

      END_IF_STATEMENT;

      ELSE
            $ "FlamingGorge.Outflow" [] := $ "FlamingGorgeData.MonthlyFGOutflow" [];

      END_IF_STATEMENT;

    END;

    RULE                 "Sum Daily Release To Monthly, Check For Spills";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "MonthIs"( { "May" , "June" , "July" } ) AND "GetRunCycleIndex"(  ) == 2.00000000;
    BEGIN

      $ "FlamingGorgeData.MonthlyFGOutflow" [] := WITH NUMERIC release = FOR ( DATETIME date IN "GetDates"( "GetStartDayOfMonth"(  ), "GetEndDayOfMonth"(  ), "1 days" ) ) STAT_AVE
      $ "FlamingGorgeData.DailyFGOutflow" [date]
   ENDFOR DO
      WITH NUMERIC spillRelease = "VolumeToFlow"( "PrevStorage"( % "FlamingGorge" ), @"t" ) + $ "FlamingGorge.Inflow" [] - "VolumeToFlow"( "ElevationToStorage"( % "FlamingGorge", 6039.50000000 "ft" ), @"t" ) DO
         "Max"( release, spillRelease ) COMMENTED_BY "this is temporary until a generic checResPhysical Constraints function can be built. - sc 01/28/11"
      ENDWITH
   ENDWITH;

    DESCRIPTION          "When the start timestep is June or July, sum the <br>calculated daily releases before the start timestep. -HG 10/5/12";
      IF_STATEMENT (@"t" == @"Start Timestep" AND ( "GetMonthAsString"( @"Start Timestep" ) == "June" OR "GetMonthAsString"( @"Start Timestep" ) == "July" )) THEN
            $ "FlamingGorgeData.MonthlyFGOutflow" [@"24:00:00 May Max DayOfMonth, Current Year"] := FOR ( DATETIME date IN "GetDates"( @"24:00:00 May Min DayOfMonth, Current Year", @"24:00:00 May Max DayOfMonth, Current Year", "1 days" ) ) STAT_AVE
      $ "FlamingGorgeData.DailyFGOutflow" [date]
   ENDFOR;

            IF_STATEMENT ("GetMonthAsString"( @"Start Timestep" ) == "July") THEN
            $ "FlamingGorgeData.MonthlyFGOutflow" [@"24:00:00 June Max DayOfMonth, Current Year"] := FOR ( DATETIME date IN "GetDates"( @"24:00:00 June Min DayOfMonth, Current Year", @"24:00:00 June Max DayOfMonth, Current Year", "1 days" ) ) STAT_AVE
      $ "FlamingGorgeData.DailyFGOutflow" [date]
   ENDFOR;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "May Thru July Daily FG Outflow";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IF ( @"Start Timestep" == @"24:00:00 June Max DayOfMonth, Current Year" OR @"Start Timestep" == @"24:00:00 July Max DayOfMonth, Current Year" )
   THEN
      "MonthIs"( { "May" } ) OR @"t" == @"Start Timestep"
   ELSE
      "MonthIs"( { "May" } )
   ENDIF AND "GetRunCycleIndex"(  ) == 2.00000000;
    BEGIN

      FOREACH (LIST dateFlow IN "SpringDateAndFlowLists"(  )) DO
            $ "FlamingGorgeData.DailyFGOutflow" [GET @INDEX 0.00000000 FROM dateFlow] := GET @INDEX 1.00000000 FROM dateFlow;

      ENDFOREACH;

    END;

    RULE                 "Release to Meet ULDE";
    DESCRIPTION          "Overrides the baseflow rule for the months of March and April. During these months the May 1 ULDE could be adjusted based upon the &quot;projected&quot; unregulated inflow into Flaming Gorge. Also the release is not limited by the baseflow max and min constraints, as the reservoir needs to release whatever necessary to meet the May 1 target. -HG 10/9/12 ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "MonthIs"( { "March" , "April" } ) AND "GetRunCycleIndex"(  ) == 2.00000000;
    BEGIN

    DESCRIPTION          "If it is March or April, then release whatever necessary to meet the May 1 ULDE, regardless of the Baseflow Limits. -HG 9/12/12";
      $ "FlamingGorge.Outflow" [] := "GetFGBaseFlowMagnitudeUnconstrained"(  );

    END;

    RULE                 "Adaptive Management Adjustments ";
    DESCRIPTION          "This rule determines baseflow for various period of the year. From the end of the Ramp Down Period through the end of September 140% of the maximum baseflow limit is released as requested by the USFWS. For the months of October and November either 60% of the minimum baseflow for the current hydrologic classification, or the absolute minimum baseflow is released to meet USFWS requests, whichever is greater. For December through Feburary, 125% of the maximum baseflow limit is released to meet Western requests as long as the maximum pool elevation at the end of the period will be greater than 6018 ft. Otherwise the maximum baseflow limit is released for this period. -CE 6/12/2013";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 2.00000000 AND NOT "MonthIs"( { "March" , "April" } ) AND IF ( "RunStartDate"(  ) >= @"May" )
   THEN
      @"t" < "CompletePartialDate"( @"April Max DayOfMonth", "OffsetDate"( "RunStartDate"(  ), 1.00000000, "1 years" ) )
   ELSE
      "StartYear"(  )
   ENDIF;
    BEGIN

      $ "FlamingGorge.Outflow" [] := WITH DATETIME HClassYear = IF ( "MonthIs"( { "May" , "June" , "July" , "August" , "September" , "October" , "November" , "December" } ) OR "StartYear"(  ) COMMENTED_BY "Previous Year's April through July volume is not know during the start year of the run,<br> therefore use the current year's target. -HG 10/3/12" )
   THEN
      @"24:00:00 December Max DayOfMonth, Current Year"
   ELSE
      @"24:00:00 December Max DayOfMonth, Previous Year"
   ENDIF COMMENTED_BY "Selects the correct April through July period to be considered for basefow operations. <br>In actual operations the HClass would be based upon the previous April - July period for baseflow purposes.-HG 9/13/12" DO
      IF ( "MonthIs"( { "May" , "June" , "July" , "August" , "September" } ) )
      THEN
         ( "GetFGBaseFlowMagnitude"(  ) * 1.40000000 ) COMMENTED_BY "From the end of the Ramp Down Period through the end of September, USFWS requests +40% of the maximum baseflow limit be released. -HG 10/29/12"
      ELSE
         IF ( "MonthIs"( { "October" , "November" } ) )
         THEN
            "GetFGBaseFlowMagnitude"(  ) COMMENTED_BY "For October and November the USFWS requests -40% of the minimum baseflow limit be released. This value is constrained by the minimum flow limit as well. -HG 10/29/12"
         ELSE
            IF ( "MonthIs"( { "December" , "January" , "February" } ) )
            THEN
               WITH NUMERIC BelowLimitBaseflow = "GetFGBaseFlowMagnitude"(  ) DO
                  WITH NUMERIC AboveLimitBaseflow = "GetFGBaseFlowMagnitude"(  ) * 1.20000000 DO
                     IF ( "StorageToElevation"( % "FlamingGorge", ( $ "FlamingGorge.Storage" [@"t - 1"] + "SumFlowsToVolumeSkipNaN"( $ "FlamingGorge.Inflow", @"t", IF ( "MonthIs"( { "December" } ) )
                     THEN
                        @"24:00:00 February Max DayOfMonth, Next Year"
                     ELSE
                        @"24:00:00 February Max DayOfMonth, Current Year"
                     ENDIF ) - AboveLimitBaseflow * 3.00000000 "month" ) ) > $ "FlamingGorgeData.WesternWinterReleaseElevLimit" [] )
                     THEN
                        AboveLimitBaseflow
                     ELSE
                        BelowLimitBaseflow
                     ENDIF
                  ENDWITH
               ENDWITH COMMENTED_BY "During December through February, Western requests +25% of the maximum baseflow limit be released. <br>This request can be honored as long as the resulting pool elevation at the end of the period will  be greater than 6018 ft. <br>If the resulting pool elevation is not greater than 6018 ft. the maximum baseflow limit will be used.<br>-HG 10/29/12"
            ELSE
               $ "FlamingGorge.Outflow" []
            ENDIF
         ENDIF
      ENDIF
   ENDWITH;

    END;

    RULE                 "Base Flow Operations";
    DESCRIPTION          "Sets the baseflow for each month, except March and April where the baseflow is set by a later rule.  -HG 10/9/12";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 2.00000000 AND NOT "MonthIs"( { "March" , "April" } );
    BEGIN

      $ "FlamingGorge.Outflow" [] := "Max"( "GetFGBaseFlowMagnitude"(  ), "VolumeToFlow"( "PrevStorage"( % "FlamingGorge" ), @"t" ) + $ "FlamingGorge.Inflow" [] - "VolumeToFlow"( "ElevationToStorage"( % "FlamingGorge", 6039.50000000 "ft" ), @"t" ) );

    END;

    RULE                 "Hydrologic Classification";
    DESCRIPTION          "This rule determines the hydraulic classification index (0: Dry, 1: ModDry, 2: Ave, 3: ModWet, 4: Wet) for Flaming Gorge inflow and the Yampa River for each timestep. - CE 6/11/13";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 2.00000000;
    BEGIN

      FOREACH (DATETIME date IN @"Start Timestep" TO @"Finish Timestep") DO
            IF_STATEMENT (NOT IsNaN $ "FlamingGorgeData.AprJulPercentExceedance" ["Dec31ofYear"( date )]) THEN
          DESCRIPTION          "Flaming Gorge";
      FOREACH (NUMERIC index IN { 0.00000000 , 1.00000000 , 2.00000000 , 3.00000000 , 4.00000000 }) DO
            IF_STATEMENT ($ "FlamingGorgeData.AprJulPercentExceedance" ["Dec31ofYear"( date )] <= $ "FlamingGorgeData.HydrologicClassPercentileLimits" [index, 1.00000000]) THEN
            IF_STATEMENT (IsNaN $ "FlamingGorgeData.HClass" ["Dec31ofYear"( date )]) THEN
            $ "FlamingGorgeData.HClass" ["Dec31ofYear"( date )] := index;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ENDFOREACH;

      END_IF_STATEMENT;

            IF_STATEMENT (NOT IsNaN $ "FlamingGorgeData.YampaAprJulPercentExceedance" ["Dec31ofYear"( date )]) THEN
          DESCRIPTION          "Yampa";
      FOREACH (NUMERIC index IN { 0.00000000 , 1.00000000 , 2.00000000 , 3.00000000 , 4.00000000 }) DO
            IF_STATEMENT ($ "FlamingGorgeData.YampaAprJulPercentExceedance" ["Dec31ofYear"( date )] <= $ "FlamingGorgeData.HydrologicClassPercentileLimits" [index, 1.00000000]) THEN
            IF_STATEMENT (IsNaN $ "FlamingGorgeData.YampaHClass" ["Dec31ofYear"( date )]) THEN
            $ "FlamingGorgeData.YampaHClass" ["Dec31ofYear"( date )] := index;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ENDFOREACH;

      END_IF_STATEMENT;

      ENDFOREACH;

    END;

    RULE                 "Calc Percent Exceedance";
    DESCRIPTION          "This rule calcualtes the exceedence percentage of the April to July Flaming Gorge inflow volume and the Yamper River flow volume for each year in the study period based on the historic data. - CE 6/11/13";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 2.00000000;
    BEGIN

      FOREACH (DATETIME date IN @"Start Timestep" TO @"Finish Timestep") DO
            IF_STATEMENT (NOT IsNaN $ "FlamingGorgeData.AprJulInflowVolume" ["Dec31ofYear"( date )]) THEN
            $ "FlamingGorgeData.AprJulPercentExceedance" ["Dec31ofYear"( date )] := 1.00000000 - "PercentRank"( "GetSlotVals"( $ "FlamingGorgeData.AprJulVolAnnual", "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "FlamingGorgeData.HydrologicClassificationPeriod" [0.00000000, "Start Year"] ) ) ), "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "FlamingGorgeData.HydrologicClassificationPeriod" [0.00000000, "End Year"] ) ) ) ), $ "FlamingGorgeData.AprJulInflowVolume" ["Dec31ofYear"( date )] );

      END_IF_STATEMENT;

            IF_STATEMENT (NOT IsNaN $ "FlamingGorgeData.YampaAprJulVol" ["Dec31ofYear"( date )]) THEN
            $ "FlamingGorgeData.YampaAprJulPercentExceedance" ["Dec31ofYear"( date )] := 1.00000000 - "PercentRank"( "GetSlotVals"( $ "FlamingGorgeData.YampaAprJulVolAnnual", "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "FlamingGorgeData.HydrologicClassificationPeriod" [0.00000000, "Start Year"] ) ) ), "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "FlamingGorgeData.HydrologicClassificationPeriod" [0.00000000, "End Year"] ) ) ) ), $ "FlamingGorgeData.YampaAprJulVol" ["Dec31ofYear"( date )] );

      END_IF_STATEMENT;

      ENDFOREACH;

    END;

    RULE                 "Calc April July Volume For Model Run Period";
    DESCRIPTION          "This rule calculates the April through July inflow volume into Flaming Gorge and the April though July outflow volume for the Yampa River. Flamming Gorge inflows are set during the first runcycle so the April-July volume can be calculated at the beginning of the second runcycle. In actual operation forcasted inflows are used to determine an April-July volume in March then the forcasted value is checked against measured values in August. - CE 6/11/13";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 2.00000000;
    BEGIN

    DESCRIPTION          "Spring flow and baseflow operations interested in the april - july <br>volume. This number is used to determine the Hydrologic Classification which is used to<br>determine: May 1 ULDE, Spring Peak magnitude, spring peak duration, Ramp Up Rates, <br>Ramp Down Rates, etc. <br><br>In actual operations this number would would be calculated in March using forecasted April - July inflows and then recalculated in August using the observed April - July inflows. <br>Since Flaming Gorge inflow is set during run cycle one, we can use the known values for the<br>entire run. Therefore, we calculate the April -July Volumes once for each year of the run. <br><br>Rules and Functions calling upon these slots will need to know which year to reference. <br><br>-HG 9/13/12";
      FOREACH (DATETIME date IN @"Start Timestep" TO @"Finish Timestep") DO
          DESCRIPTION          "Temporary Check. May remove this IF statement once the historic values are added to the model as input along with the forecast values, although it should not cause problems if left.<br>This will ensure that the rule fires for all years with a complete April through July dataset; it will not fail due to missing data at the start or end year. -HG 10/8/12";
      IF_STATEMENT (NOT IsNaN $ "FlamingGorgeInflow.Unregulated" ["April30ofYear"( date )] AND NOT IsNaN $ "FlamingGorgeInflow.Unregulated" ["July31ofYear"( date )]) THEN
            $ "FlamingGorgeData.AprJulInflowVolume" ["Dec31ofYear"( date )] := "SumFlowsToVolume"( $ "FlamingGorgeInflow.Unregulated", "April30ofYear"( date ), "July31ofYear"( date ) );

      END_IF_STATEMENT;

            IF_STATEMENT (NOT IsNaN $ "YampaRiverInflow.Yampa_at_Deerlodge" ["April30ofYear"( date )] AND NOT IsNaN $ "YampaRiverInflow.Yampa_at_Deerlodge" ["July31ofYear"( date )]) THEN
            $ "FlamingGorgeData.YampaAprJulVol" ["Dec31ofYear"( date )] := "SumFlowsToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge", "April30ofYear"( date ), "July31ofYear"( date ) );

      END_IF_STATEMENT;

      ENDFOREACH;

    END;

    RULE                 "Calculate April July Volume For Hydrologic Classifcation Period";
    DESCRIPTION          "This rule calculates the annual unregulated April through July inflow volume into Flaming Gorge and the annual Yampa River April through July inflow volume for all of the years in the Hydrologic Classification Period. -CE 6/11/13";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == "RunStartDate"(  ) AND "GetRunCycleIndex"(  ) == 2.00000000;
    BEGIN

    DESCRIPTION          "Flaming Gorge Unregulated Apr-Jul Inflow volume";
      FOREACH (DATETIME time IN "GetDates"( "NumberToDate"( $ "FlamingGorgeData.HydrologicClassificationPeriod" [0.00000000, "Start Year"] ), "NumberToDate"( $ "FlamingGorgeData.HydrologicClassificationPeriod" [0.00000000, "End Year"] ), "1 years" )) DO
            $ "FlamingGorgeData.AprJulVolAnnual" ["GetDate"( "December 31, " CONCAT "GetYearAsString"( time ) )] := WITH STRING year = "GetYearAsString"( time ) DO
      "SumFlowsToVolumeSkipNaN"( $ "FlamingGorgeInflow.Unregulated", "GetDate"( "April, " CONCAT year ), "GetDate"( "July, " CONCAT year ) )
   ENDWITH;

      ENDFOREACH;

    DESCRIPTION          "Yampa Apr-Jul Inflow Vol";
      FOREACH (DATETIME time IN "GetDates"( "NumberToDate"( $ "FlamingGorgeData.YampaHydrologicClassificationPeriod" [0.00000000, "Start Year"] ), "NumberToDate"( $ "FlamingGorgeData.YampaHydrologicClassificationPeriod" [0.00000000, "End Year"] ), "1 years" )) DO
            $ "FlamingGorgeData.YampaAprJulVolAnnual" ["GetDate"( "December 31, " CONCAT "GetYearAsString"( time ) )] := WITH STRING year = "GetYearAsString"( time ) DO
      "SumFlowsToVolume"( $ "YampaRiverInflow.Maybelle", "GetDate"( "April, " CONCAT year ), "GetDate"( "July, " CONCAT year ) )
   ENDWITH;

      ENDFOREACH;

    END;

  END;

  POLICY_GROUP   "Flaming Gorge ";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Calculate Daily Jensen Flows";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 2.00000000;
    BEGIN

    DESCRIPTION          "Calculates the daily Jensen flow using daily FG releases and daily Yampa flows with the assumption that FG releases are lagged one day.";
      FOREACH (DATETIME date IN "GetDates"( @"24:00:00 Current Month Min DayOfMonth, Current Year", @"24:00:00 Current Month Max DayOfMonth, Current Year", "1 days" )) DO
            $ "KNN_MTOM.JensenDaily" [date] := IF ( @"t" == "RunStartDate"(  ) )
   THEN
      $ "KNN_MTOM.FlamingGorgeDaily" [date]
   ELSE
      $ "KNN_MTOM.FlamingGorgeDaily" [date - 1.00000000 "day"]
   ENDIF + IF ( "GetMonth"( @"t" ) >= 4.00000000 AND "GetMonth"( @"t" ) <= 7.00000000 )
   THEN
      $ "KNN_MTOM.YampaDailyDeerlodgeDepleted" [date]
   ELSE
      $ "YampaRiverInflow.Yampa_at_Deerlodge" []
   ENDIF;

      ENDFOREACH;

    END;

    RULE                 "Fill Daily Flaming Gorge Releases for Months Outside of April-July";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "MonthIs"( { "April" , "May" , "June" , "July" , "August" } ) AND "GetRunCycleIndex"(  ) == 2.00000000;
    BEGIN

    DESCRIPTION          "Sets the daily FG releases and daily Yampa releases to the average monthly <br>FG outflow and Yampa gaged outflow, respectively.";
      FOREACH (DATETIME date IN "GetDates"( @"24:00:00 Current Month Min DayOfMonth, Current Year", @"24:00:00 Current Month Max DayOfMonth, Current Year", "1 days" )) DO
            $ "KNN_MTOM.FlamingGorgeDaily" [date] := $ "FlamingGorge.Outflow" [];

            $ "KNN_MTOM.YampaDailyDeerlodgeDepleted" [date] := $ "YampaRiverInflow.Yampa_at_Deerlodge" [];

      ENDFOREACH;

    END;

    RULE                 "Sum Daily Flaming Gorge Release Schedule to Monthly";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "MonthIs"( { "April" , "May" , "June" , "July" , "August" } ) AND "GetRunCycleIndex"(  ) == 2.00000000;
    BEGIN

      $ "FlamingGorge.Outflow" COMMENTED_BY "Sets FG outflow to the aggregated daily release volume." [] := "VolumeToFlow"( "SumFlowsToVolume"( $ "KNN_MTOM.FlamingGorgeDaily", @"24:00:00 Current Month Min DayOfMonth, Current Year", @"24:00:00 Current Month Max DayOfMonth, Current Year" ), @"t" );

    END;

    RULE                 "Min Flow in Extremely Dry Years with Low Storage";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "MonthIs"( { "May" , "June" , "July" } ) AND "GetRunCycleIndex"(  ) == 2.00000000;
    BEGIN

      IF_STATEMENT ($ "FlamingGorge.Pool Elevation" [] < $ "FlamingGorgeData.MinReleaseTrigger" [] AND $ "KNN_MTOM.BaseFlowHClass" [] == 0.00000000) THEN
            $ "FlamingGorge.Outflow" [] := $ "FlamingGorgeData.AbsoluteMinRelease" [];

            $ "FlamingGorgeData.LowReleaseFlag" [] := 1.00000000;

      END_IF_STATEMENT;

    END;

    RULE                 "Adjust Daily for August Base Flow";
    DESCRIPTION          "Rule sets August releases at steady base flows or downramps from high FG releases through July 31st to August base flows.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "MonthIs"( { "August" } ) AND "GetRunCycleIndex"(  ) == 2.00000000;
    BEGIN

    DESCRIPTION          "Determines if July releases were at power plant or bypass capacity during <br>moderately wet and wet hydrology and ramps down in August.  <br>August ramp down is contained in the Flow Recommendations.";
      WITH_STATEMENT (NUMERIC RampRate = $ "KNN_MTOM.BaseFlowDownrampRateNoUnits" [$ "KNN_MTOM.BaseFlowHClass" [@"t"], 0.00000000] * 1.00000000 "cfs") DO
            WITH_STATEMENT (NUMERIC DaysToDownRamp = "RoundToNearestDay"( ( $ "KNN_MTOM.FlamingGorgeDaily" [@"24:00:00 July Max DayOfMonth, Current Year"] - $ "FlamingGorge.Outflow" [] ) / RampRate * 1.00000000 "day" )) DO
            IF_STATEMENT ($ "KNN_MTOM.FlamingGorgeDaily" [@"24:00:00 July Max DayOfMonth, Current Year"] > $ "FlamingGorge.Outflow" [] + RampRate) THEN
            FOREACH (LIST AugustFlows IN "AugustDownRamp"(  )) DO
            $ "KNN_MTOM.FlamingGorgeDaily" [GET @INDEX 0.00000000 FROM AugustFlows] := GET @INDEX 1.00000000 FROM AugustFlows;

      ENDFOREACH;

      ELSE
            FOREACH (DATETIME date IN "GetDates"( @"24:00:00 Current Month Min DayOfMonth, Current Year", @"24:00:00 Current Month Max DayOfMonth, Current Year", "1 days" )) DO
            $ "KNN_MTOM.FlamingGorgeDaily" [date] := "GetFGBaseFlowMagnitude"(  );

      ENDFOREACH;

      END_IF_STATEMENT;

            FOREACH (DATETIME date IN "GetDates"( @"24:00:00 Current Month Min DayOfMonth, Current Year", @"24:00:00 Current Month Max DayOfMonth, Current Year", "1 days" )) DO
            $ "KNN_MTOM.YampaDailyDeerlodgeDepleted" [date] := $ "YampaRiverInflow.Yampa_at_Deerlodge" [];

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "Set Flaming Gorge Daily April to July Schedule";
    DESCRIPTION          "Every April, this Rule is called which makes the daily date and flow list (through the functions) and this rule assigns them to the data object.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "MonthIs"( { "April" , "May" , "June" , "July" } ) AND @"t" == @"Start Timestep" OR "MonthIs"( { "April" } ) AND "GetRunCycleIndex"(  ) == 2.00000000;
    BEGIN

    DESCRIPTION          "Rule fires in Apr, May, June, July and sets the daily release schedule which is put together in the<br>function. It must fire each month to know where the reservoir was at at the end of the previous<br>month and update the remaining daily schedule as far as base flow goes. Daily releases are not<br>changed back in time and only replace the rest of the remaining daily schedule through July 31. -tv 8.17.12";
      FOREACH (LIST dateandflow IN "MakeDailyFlamingGorgeReleaseDateandFlowList"( IF ( "MonthIs"( { "April" } ) )
   THEN
      @"24:00:00 April 1, Current Year"
   ELSE
      IF ( "MonthIs"( { "May" } ) )
      THEN
         @"24:00:00 May 1, Current Year"
      ELSE
         IF ( "MonthIs"( { "June" } ) )
         THEN
            @"24:00:00 June 1, Current Year"
         ELSE
            @"24:00:00 July 1, Current Year" COMMENTED_BY "July"
         ENDIF
      ENDIF
   ENDIF )) DO
            $ "KNN_MTOM.FlamingGorgeDaily" [GET @INDEX 0.00000000 FROM dateandflow] := GET @INDEX 1.00000000 FROM dateandflow;

      ENDFOREACH;

    END;

    RULE                 "Release to Meet ULDE";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "MonthIs"( { "March" , "April" } ) AND "GetRunCycleIndex"(  ) == 2.00000000;
    BEGIN

    DESCRIPTION          "If it is March or April, then release whatever necessary to meet the May 1 ULDE";
      $ "FlamingGorge.Outflow" [] := "GetFGBaseFlowMagnitudeUnconstrained"(  );

    END;

    RULE                 "Base Flow Operations";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "MonthIs"( { "March" , "April" } ) AND "GetRunCycleIndex"(  ) == 2.00000000;
    BEGIN

      $ "FlamingGorge.Outflow" COMMENTED_BY "Sets the base flows for all months except March and April.  Base flow releases are set to stay<br>below maximum pool elevation (6039 ft), minimum flows or stay within the base flow range <br>based on the hydrologic classification." [] := IF ( $ "FlamingGorge.Storage" [@"t - 1"] >= "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorgeData.MaxPE" [] ) )
   THEN
      "Max"( ( ( $ "FlamingGorge.Storage" [@"t - 1"] - "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorgeData.MaxPE" [] ) + "SumFlowsToVolume"( $ "FlamingGorge.Inflow", @"t", @"t" ) ) - "EstimateEvaporation"( % "FlamingGorge", $ "FlamingGorge.Storage" [@"t - 1"], $ "FlamingGorge.Storage" [@"t - 1"], @"24:00:00 Current Month Max DayOfMonth, Current Year", @"24:00:00 Current Month Max DayOfMonth, Current Year" ) ) / 1.00000000 "month", $ "FlamingGorgeData.MinFlow" [] )
   ELSE
      "GetFGBaseFlowMagnitude"(  )
   ENDIF;

    END;

    RULE                 "Spring Flow Hydrologic Classification";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetMonthAsString"( @"t" ) IN { "March" , "April" , "May" , "June" , "July" } AND "GetRunCycleIndex"(  ) == 2.00000000;
    BEGIN

    DESCRIPTION          "Sets the spring hydrologic classification based on the May 1 forecasted April-July volume.";
      FOREACH (NUMERIC index IN { 0.00000000 , 1.00000000 , 2.00000000 , 3.00000000 , 4.00000000 }) DO
            IF_STATEMENT ($ "KNN_MTOM.AprJulPercentExceedanceSpringFlow" [] <= $ "FlamingGorgeData.HydrologicClassPercentileLimits" [index, 1.00000000]) THEN
            IF_STATEMENT (IsNaN $ "KNN_MTOM.SpringHClass" []) THEN
            $ "KNN_MTOM.SpringHClass" [] := index;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ENDFOREACH;

    DESCRIPTION          "Yampa";
      FOREACH (NUMERIC index IN { 0.00000000 , 1.00000000 , 2.00000000 , 3.00000000 , 4.00000000 }) DO
            IF_STATEMENT ($ "FlamingGorgeData.YampaAprJulPercentExceedance" [] <= $ "FlamingGorgeData.HydrologicClassPercentileLimits" [index, 1.00000000]) THEN
            IF_STATEMENT (IsNaN $ "FlamingGorgeData.YampaHClass" []) THEN
            $ "FlamingGorgeData.YampaHClass" [] := index;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ENDFOREACH;

    END;

    RULE                 "Base Flow Hydrologic Classification";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 2.00000000;
    BEGIN

    DESCRIPTION          "Sets the base flow classification based on ROD percent exceedance ranges.  Under ROD<br>compliance, base flows change one classification higher or lower depending upon the <br>previous month?s observed unregulated inflow. ";
      FOREACH (NUMERIC index IN { 0.00000000 , 1.00000000 , 2.00000000 , 3.00000000 , 4.00000000 }) DO
            IF_STATEMENT ($ "KNN_MTOM.AprJulPercentExceedanceBaseFlow" [] <= $ "FlamingGorgeData.HydrologicClassPercentileLimits" [index, 1.00000000]) THEN
            IF_STATEMENT (IsNaN $ "KNN_MTOM.BaseFlowHClass" []) THEN
            $ "KNN_MTOM.BaseFlowHClass" [] := IF ( @"t" == "RunStartDate"(  ) )
   THEN
      index
   ELSE
      IF ( index > $ "KNN_MTOM.BaseFlowHClass" [@"t - 1"] + 1.00000000 )
      THEN
         $ "KNN_MTOM.BaseFlowHClass" [@"t - 1"] + 1.00000000
      ELSE
         IF ( index < $ "KNN_MTOM.BaseFlowHClass" [@"t - 1"] - 1.00000000 )
         THEN
            $ "KNN_MTOM.BaseFlowHClass" [@"t - 1"] - 1.00000000
         ELSE
            index
         ENDIF
      ENDIF
   ENDIF;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ENDFOREACH;

    END;

    RULE                 "Calc Percent Exceedance";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 2.00000000;
    BEGIN

      $ "KNN_MTOM.AprJulPercentExceedanceSpringFlow" [] := 1.00000000 - "PercentRank"( "GetSlotVals"( $ "FlamingGorgeData.AprJulVolAnnual", "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.FGHydrologicClassificationStartYear" [] ) ) ), IF ( $ "KNN_MTOM.UpdateHistoricRecord" [] == 1.00000000 )
   THEN
      "GetDate"( "December 31, " CONCAT ( GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( @"t" ) - 1.00000000, "." ) ) )
   ELSE
      "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.FGHydrologicClassificationEndYear" [] ) ) )
   ENDIF ), $ "KNN_MTOM.AprJulVolSpringFlow" [] );

      $ "KNN_MTOM.AprJulPercentExceedanceBaseFlow" [] := 1.00000000 - "PercentRank"( "GetSlotVals"( $ "FlamingGorgeData.AprJulVolAnnual", "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.FGHydrologicClassificationStartYear" [] ) ) ), IF ( $ "KNN_MTOM.UpdateHistoricRecord" [] == 1.00000000 )
   THEN
      "GetDate"( "December 31, " CONCAT ( GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( @"t" ) - 1.00000000, "." ) ) )
   ELSE
      "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.FGHydrologicClassificationEndYear" [] ) ) )
   ENDIF ), $ "KNN_MTOM.AprJulVolBaseFlow" [] );

      $ "FlamingGorgeData.YampaAprJulPercentExceedance" [] := 1.00000000 - "PercentRank"( IF ( "GetYear"( "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationStartYear" [] ) ) < "GetYear"( "RunStartDate"(  ) ) - 1.00000000 AND $ "KNN_MTOM.UpdateHistoricRecord" [] == 1.00000000 )
   THEN
      IF ( "GetYear"( @"t" ) == "GetYear"( "RunStartDate"(  ) ) )
      THEN
         "GetSlotVals"( $ "FlamingGorgeData.YampaAprJulVolAnnual", "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationStartYear" [] ) ) ), "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationEndYear" [] ) ) ) )
      ELSE
         WITH LIST futureData = "GetSlotVals"( $ "FlamingGorgeData.YampaAprJulVolAnnual", "GetDate"( "December 31, " CONCAT "GetYearAsString"( "RunStartDate"(  ) ) ), "GetDate"( "December 31, " CONCAT ( GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( @"t" ) - 1.00000000, "." ) ) ) ) DO
            FOR ( NUMERIC i IN "GetNumbers"( 0.00000000, ( LENGTH futureData ) - 1.00000000, 1.00000000 ) ) WITH LIST result = "GetSlotVals"( $ "FlamingGorgeData.YampaAprJulVolAnnual", "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationStartYear" [] ) ) ), "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationEndYear" [] ) ) ) ) DO
               APPEND GET @INDEX i FROM futureData ONTO result
            ENDFOR
         ENDWITH
      ENDIF
   ELSE
      "GetSlotVals"( $ "FlamingGorgeData.YampaAprJulVolAnnual", "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationStartYear" [] ) ) ), IF ( $ "KNN_MTOM.UpdateHistoricRecord" [] == 1.00000000 )
      THEN
         "GetDate"( "December 31, " CONCAT ( GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( @"t" ) - 1.00000000, "." ) ) )
      ELSE
         "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationEndYear" [] ) ) )
      ENDIF )
   ENDIF, $ "FlamingGorgeData.YampaAprJulVol" [] );

    END;

    RULE                 "Initilize PE and Daily Rules";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 2.00000000;
    BEGIN

      $ "FlamingGorgeData.ManualSpill" [] := 0.00000000 "acre-ft/month";

      $ "KNN_MTOM.FlamingGorgeDaily" [@"24:00:00 December 31, 2013"] := $ "FlamingGorge.Outflow" [@"24:00:00 January Max DayOfMonth, 2014"];

    END;

    RULE                 "Calc April July Volume Monthly";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 2.00000000;
    BEGIN

    DESCRIPTION          "For spring flow operations we are interested in the april - july <br>volume for the upcoming season beginning in January through April. <br> The May official forecast is used for spring operations through July. <br> This number is needed in march to determine<br>releases to meet the ULDE. ";
      $ "KNN_MTOM.AprJulVolSpringFlow" [] := "SpringFlowA-JVolumeUpdate"(  );

    DESCRIPTION          "For base flow operations we are interested in the available observed<br>volume in the previous april - july season. Since base flow may actually <br>start in june calculate this number then. The August - December base flows <br>use the observed A-J volume.  Jan-Feb use forecast A-J and ULDE and base flow range.<br>";
      $ "KNN_MTOM.AprJulVolBaseFlow" [] := "BaseFlowA-JVolumeUpdate"(  );

      $ "FlamingGorgeData.YampaAprJulVol" [] := IF ( "MonthIs"( { "April" } ) )
   THEN
      "SumFlowsToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge", @"t", @"t + 3" )
   ELSE
      IF ( @"t" == "RunStartDate"(  ) )
      THEN
         0.00000000 "acre-ft"
      ELSE
         $ "FlamingGorgeData.YampaAprJulVol" [@"t - 1"]
      ENDIF
   ENDIF;

    END;

    RULE                 "Update Historic Record";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "MonthIs"( { "August" } ) OR @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 2.00000000;
    BEGIN

      IF_STATEMENT ("GetMonth"( @"t" ) < 8.00000000) THEN
            IF_STATEMENT (NaNToZero ( $ "FlamingGorgeData.YampaAprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Previous Year"] ) == 0.00000000 "acre-ft") THEN
            $ "FlamingGorgeData.YampaAprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Previous Year"] := "SumFlowsToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge", @"24:00:00 April Max DayOfMonth, Previous Year", @"24:00:00 July Max DayOfMonth, Previous Year" );

      END_IF_STATEMENT;

            IF_STATEMENT (NaNToZero ( $ "FlamingGorgeData.AprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Previous Year"] ) == 0.00000000 "acre-ft") THEN
            $ "FlamingGorgeData.AprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Previous Year"] := "SumFlowsToVolume"( $ "FlamingGorgeInflow.Unregulated", @"24:00:00 April Max DayOfMonth, Previous Year", @"24:00:00 July Max DayOfMonth, Previous Year" );

      END_IF_STATEMENT;

      ELSE
            IF_STATEMENT (NaNToZero ( $ "FlamingGorgeData.YampaAprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Current Year"] ) == 0.00000000 "acre-ft") THEN
            $ "FlamingGorgeData.YampaAprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Current Year"] := "SumFlowsToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" );

      END_IF_STATEMENT;

            IF_STATEMENT (NaNToZero ( $ "FlamingGorgeData.AprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Current Year"] ) == 0.00000000 "acre-ft") THEN
            $ "FlamingGorgeData.AprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Current Year"] := "SumFlowsToVolume"( $ "FlamingGorgeInflow.Unregulated", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "Calculate April To July Volume Annual Slot";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == "RunStartDate"(  ) AND "GetRunCycleIndex"(  ) == 2.00000000;
    BEGIN

    DESCRIPTION          "Flaming Gorge Unregulated Apr-Jul Inflow volume";
      FOREACH (DATETIME time IN "GetDates"( "NumberToDate"( $ "KNN_MTOM.FGHydrologicClassificationStartYear" [] ), "NumberToDate"( $ "KNN_MTOM.FGHydrologicClassificationEndYear" [] ), "1 years" )) DO
            $ "FlamingGorgeData.AprJulVolAnnual" ["GetDate"( "December 31, " CONCAT "GetYearAsString"( time ) )] := "SumFlowsToVolumeSkipNaN"( $ "KNN_MTOM.HistoricFlamingGorgeUnregInflow", "GetDate"( "April, " CONCAT "GetYearAsString"( time ) ), "GetDate"( "July, " CONCAT "GetYearAsString"( time ) ) );

      ENDFOREACH;

    DESCRIPTION          "Yampa Apr-Jul Inflow Vol";
      FOREACH (DATETIME time IN "GetDates"( "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationStartYear" [] ), "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationEndYear" [] ), "1 years" )) DO
            $ "FlamingGorgeData.YampaAprJulVolAnnual" ["GetDate"( "December 31, " CONCAT "GetYearAsString"( time ) )] := "SumFlowsToVolume"( $ "KNN_MTOM.HistoricYampaAtDeerlodge", "GetDate"( "April, " CONCAT "GetYearAsString"( time ) ), "GetDate"( "July, " CONCAT "GetYearAsString"( time ) ) );

      ENDFOREACH;

    END;

  END;

  POLICY_GROUP   "KNN Yampa Daily Flow";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Set Peak Yampa Flow";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"24:00:00 March Max DayOfMonth, Current Year" ) OR ( @"t" == @"Start Timestep" ) AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      $ "KNN_MTOM.YampaPeakDailyFlow" [@"24:00:00 December Max DayOfMonth, Current Year"] := "MaxItem"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", "GetDate"( "NumberToDate"( $ "KNN_MTOM.StartMonth" [] ) CONCAT " 1, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( @"24:00:00 December Max DayOfMonth, Current Year" ), "." ) ), "GetDate"( "NumberToDate"( $ "KNN_MTOM.EndMonth" [] ) CONCAT ( ( GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetDaysInMonth"( "GetDate"( "NumberToDate"( $ "KNN_MTOM.EndMonth" [] ) CONCAT ", current year" ) ), "." ) ) CONCAT "," ) CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( @"24:00:00 December Max DayOfMonth, Current Year" ), "." ) ) ) );

    END;

    RULE                 "Set Yampa Daily Depleted Flow at Deerlodge For Second Stage Disagg";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"24:00:00 March Max DayOfMonth, Current Year" ) OR ( @"t" == @"Start Timestep" ) AND "HasRuleFiredSuccessfully"( "Set Yampa Daily Natural - Second Stage Disagg" ) AND "GetRunCycleIndex"(  ) == 1.00000000 AND $ "KNN_MTOM.SecondStageDisaggFlag" [@"24:00:00 December Max DayOfMonth, Current Year"] == 1.00000000;
    BEGIN

      FOREACH (NUMERIC i IN "GetNumbers"( 0.00000000, ( LENGTH "GetCurrentYearDailyList"(  ) ) - 1.00000000, 1.00000000 )) DO
            $ "KNN_MTOM.YampaDailyDeerlodgeDepleted" [GET @INDEX i FROM "GetCurrentYearDailyList"(  )] := $ "KNN_MTOM.YampaDailyNatural" [GET @INDEX i FROM "GetCurrentYearDailyList"(  )];

      ENDFOREACH;

    END;

    RULE                 "Set Yampa Daily Natural - Second Stage Disagg";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"24:00:00 March Max DayOfMonth, Current Year" ) OR ( @"t" == @"Start Timestep" ) AND "MinItem"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", @"24:00:00 April 1, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" ) ) < 0.00000000 "cfs" AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      FOREACH (NUMERIC i IN "GetNumbers"( 0.00000000, ( LENGTH "GetCurrentYearDailyList"(  ) ) - 1.00000000, 1.00000000 )) DO
            $ "KNN_MTOM.YampaDailyNatural" [GET @INDEX i FROM "GetCurrentYearDailyList"(  )] := ( GET @INDEX i FROM "GetSecondStageProportionVector"(  ) ) * "GetCurrentMonthlyNaturalInflow"( GET @INDEX i FROM "GetCurrentYearDailyList"(  ) ) / 24.00000000 "hour";

      ENDFOREACH;

      $ "KNN_MTOM.SecondStageDisaggFlag" [@"24:00:00 December Max DayOfMonth, Current Year"] := 1.00000000;

    END;

    RULE                 "Set Yampa Daily Depleted Flow at Deerlodge";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"24:00:00 March Max DayOfMonth, Current Year" ) OR ( @"t" == @"Start Timestep" ) AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      FOREACH (NUMERIC i IN "GetNumbers"( 0.00000000, ( LENGTH "GetCurrentYearDailyList"(  ) ) - 1.00000000, 1.00000000 )) DO
            $ "KNN_MTOM.YampaDailyDeerlodgeDepleted" [GET @INDEX i FROM "GetCurrentYearDailyList"(  )] := $ "KNN_MTOM.YampaDailyNatural" [GET @INDEX i FROM "GetCurrentYearDailyList"(  )];

      ENDFOREACH;

    END;

    RULE                 "Set Yampa Daily Natural Flow from KNN - primary disagg";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"24:00:00 March Max DayOfMonth, Current Year" ) OR ( @"t" == @"Start Timestep" ) AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      FOREACH (NUMERIC i IN "GetNumbers"( 0.00000000, ( LENGTH "GetProportionVector"(  ) ) - 1.00000000, 1.00000000 )) DO
            $ "KNN_MTOM.YampaDailyNatural" [GET @INDEX i FROM "GetCurrentYearDailyList"(  )] := "VolumeToFlow"( ( GET @INDEX i FROM "GetProportionVector"(  ) ) * "GetSpringVolume"(  ), GET @INDEX i FROM "GetCurrentYearDailyList"(  ) );

      ENDFOREACH;

    DESCRIPTION          "Initialize the flag to 0";
      $ "KNN_MTOM.SecondStageDisaggFlag" [@"24:00:00 December Max DayOfMonth, Current Year"] := 0.00000000;

    END;

    RULE                 "Set Index Year- Ratios";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"24:00:00 March Max DayOfMonth, Current Year" ) OR ( @"t" == @"Start Timestep" ) AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      $ "KNN_MTOM.IndexYear" [@"24:00:00 December Max DayOfMonth, Current Year"] := WITH NUMERIC seasonalVol = "SumFlowsToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" ) DO
      "ChooseIndexYearRatio"( "FlowToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge" [@"24:00:00 April Max DayOfMonth, Current Year"], @"24:00:00 April Max DayOfMonth, Current Year" ) / seasonalVol, "FlowToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge" [@"24:00:00 May Max DayOfMonth, Current Year"], @"24:00:00 May Max DayOfMonth, Current Year" ) / seasonalVol, "FlowToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge" [@"24:00:00 June Max DayOfMonth, Current Year"], @"24:00:00 June Max DayOfMonth, Current Year" ) / seasonalVol, "FlowToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge" [@"24:00:00 July Max DayOfMonth, Current Year"], @"24:00:00 July Max DayOfMonth, Current Year" ) / seasonalVol )
   ENDWITH;

    END;

    RULE                 "Set Random Number";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"24:00:00 March Max DayOfMonth, Current Year" ) OR ( @"t" == @"Start Timestep" ) AND "GetRunCycleIndex"(  ) == 1.00000000 ) COMMENTED_BY "Changing the month this rule executes will change the random number generated <br>by the funciton call as the random number index is different for every month/year.<br>";
    BEGIN

      $ "KNN_MTOM.randomNum" [@"24:00:00 December Max DayOfMonth, Current Year"] := "Random"( "GetRandSeed"(  ), $ "KNN_MTOM.randomIndex" [], 0.00000000 );

    END;

  END;

  POLICY_GROUP   "Aspinal Ops";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Blue Mesa Operations";
    DESCRIPTION          "This rule sets the outflow from Blue Mesa Reservoir for the current timestep.  If the current month is May then it is set to the aggregated daily flow targets for the Black Canyon translated into releases from Blue Mesa for the month of May.  For all other months the rule finds a max constraint (ceiling) and a min constraint (floor), and a target end of timestep pool elevation and then sets an outflow that gets as close as possible to the end of month target elevation within the floor and ceiling values.  - sc 12/31/10";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "BlueMesa.Outflow" [] AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      IF_STATEMENT ("MonthIs"( { "May" } )) THEN
            $ "BlueMesa.Outflow" [] := "Min"( "VolumeToFlow"( $ "BlueMesaData.MayReleaseVolume" [@"24:00:00 December 31, Current Year"], @"t" ), "VolumeToFlow"( "PrevStorage"( % "BlueMesa" ) - 20000.00000000 "acre-ft", @"t" ) + $ "BlueMesa.Inflow" [] );

      ELSE
            IF_STATEMENT ("MonthIs"( { "June" } ) AND @"t" IN "WaterYearDatesByGroup"( 1.00000000 )) THEN
            $ "BlueMesa.Outflow" [] := FOR ( DATETIME date IN "GetDates"( @"24:00:00 June 1, Current Year", @"24:00:00 June 30, Current Year", "1 days" ) ) STAT_AVE
      IF ( date < @"Start Timestep" AND NOT "GetMonth"( date ) == 6.00000000 )
      THEN
         $ "BlueMesa.Outflow" ["MaxDayOfMonth"( date )] / 1.00000000
      ELSE
         "SolveBlueMesaReleaseForWhitewaterTarget"( $ "BlueMesaData.MayThruJulyDaily" [date], "MaxDayOfMonth"( date ) )
      ENDIF
   ENDFOR;

      ELSE
            $ "BlueMesa.Outflow" [] := WITH NUMERIC maxConstraint = "BlueMesaReleaseMAXConstraintByMonth"( @"t" ) DO
      WITH NUMERIC minConstraint = "BlueMesaReleaseMINConstraintByMonth"( @"t" ) DO
         WITH NUMERIC EOMElevTarget = $ "BlueMesaData.BlueMesaGuide" [@"t", "Target Elevation"] COMMENTED_BY "I changed this away from the unnecessarily over complicated function call to just the target curve reference. - tv 7.24.12" DO
            "SolveConstrainedOutflow"( % "BlueMesa", EOMElevTarget, $ "BlueMesa.Pool Elevation" [@"t - 1"], minConstraint, maxConstraint, @"t" )
         ENDWITH
      ENDWITH
   ENDWITH;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "Ramp Up To and Down From May Peak";
    DESCRIPTION          "This rule completes the process of developing the daily flow targets for the Black Canyon portion of the Gunnison River.  This rule only fires on the first timestep of the year and the first timestep of the run.  The previous rule set the shoulder flow and peak flow values and the appropriate days.  This rule sets the ramp-up flows to, and the ramp-down flows from the peak daily flow target.  These are all written to the daily slot on BlueMesaData and will be aggregated and translated into a monthly release from Blue Mesa for the month of May in the next rule. - sc 12/28/10";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" OR "GetMonth"( @"t" ) == 1.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      FOREACH (LIST dateFlow IN "RampUpDateAndFlowLists"(  )) DO
            $ "BlueMesaData.MayThruJulyDaily" [GET @INDEX 0.00000000 FROM dateFlow] := GET @INDEX 1.00000000 FROM dateFlow;

      ENDFOREACH;

      FOREACH (LIST dateFlow IN "RampDownDateAndFlowLists"(  )) DO
            $ "BlueMesaData.MayThruJulyDaily" [GET @INDEX 0.00000000 FROM dateFlow] := GET @INDEX 1.00000000 FROM dateFlow;

      ENDFOREACH;

    END;

    RULE                 "Calculate May Release Volume";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" OR "GetMonth"( @"t" ) == 1.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      $ "BlueMesaData.MayReleaseVolume" [@"24:00:00 December 31, Current Year"] := FOR ( DATETIME date IN "GetDates"( @"24:00:00 May 1, Current Year", @"24:00:00 May 31, Current Year", "1 days" ) ) STAT_AVE
      IF ( date < @"Start Timestep" AND NOT "GetMonth"( date ) == 5.00000000 )
      THEN
         $ "BlueMesa.Outflow" ["MaxDayOfMonth"( date )] / 1.00000000
      ELSE
         IF ( @"t" IN "WaterYearDatesByGroup"( 1.00000000 ) )
         THEN
            "SolveBlueMesaReleaseForWhitewaterTarget"( $ "BlueMesaData.MayThruJulyDaily" [date], "MaxDayOfMonth"( date ) )
         ELSE
            "SolveBlueMesaReleaseForWhitewaterTarget"( $ "BlueMesaData.MayThruJulyDaily" [date], "MaxDayOfMonth"( date ) )
         ENDIF
      ENDIF
   ENDFOR * 31.00000000 "day";

    INACTIVE      $ "BlueMesaData.MayReleaseVolume" [@"24:00:00 December 31, Current Year"] := "FlowToVolume"( FOR ( DATETIME date IN "GetDates"( @"24:00:00 May 1, Current Year", @"24:00:00 May 31, Current Year", "1 days" ) ) STAT_AVE
      IF ( date < @"Start Timestep" )
      THEN
         $ "BlueMesa.Outflow" ["MaxDayOfMonth"( date )] / 1.00000000
      ELSE
         $ "BlueMesaData.MayThruJulyDaily" [date]
      ENDIF
   ENDFOR - $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [@"24:00:00 May 31, Current Year"] - $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [@"24:00:00 May 31, Current Year"] - $ "GunnisonBelowCrystal:NorthForkGunnisonInflow.Local Inflow" [@"24:00:00 May 31, Current Year"] + $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" [@"24:00:00 May 31, Current Year"], @"24:00:00 May 31, Current Year" );

    END;

    RULE                 "April Through July Daily Canyon Target Flows1";
    DESCRIPTION          "This rule calculates the preliminary daily flow targets for the Black Canyon section of the river during the spring/summer season (April 1 - July 31).  They are preliminary in that the ramp up and ramp down from the peak flow target are not included yet.  This rule will set each day to either the shoulder flow (May 1 - July 25), the peak flow on the date specified on &quot;BlueMesaData.MayPeakFlowDate&quot; or the min flow value for any day outside of this range.  Though the model is monthly, these values are written to a daily slot on BlueMesaData that will be aggregated and converted to a monthly release from Blue Mesa Res in a subsequent rule (Blue Mesa Operations). - sc 12/27/10";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT "GetMonth"( @"t" ) == 1.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      FOREACH (DATETIME date IN "GetDates"( @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year", "1 days" )) DO
            $ "BlueMesaData.MayThruJulyDaily" [date] := IF ( date >= @"May 1" AND date <= @"July 25" )
   THEN
      IF ( date == "NumberToDate"( $ "BlueMesaData.MayPeakFlowDate" [@"24:00:00 December 31, Current Year"] ) )
      THEN
         $ "BlueMesaData.MayPeakFlowTarget" [@"24:00:00 December 31, Current Year"]
      ELSE
         IF ( date == ( "NumberToDate"( $ "BlueMesaData.MayPeakFlowDate" [@"24:00:00 December 31, Current Year"] ) + 1.00000000 "day" ) COMMENTED_BY "Added 2 day peak logic. - tv 8.1.12" )
         THEN
            1.00500000 * $ "BlueMesaData.MayPeakFlowTarget" [@"24:00:00 December 31, Current Year"]
         ELSE
            "Max"( $ "BlueMesaData.MinimumBlackCanyonFlow" [date], $ "BlueMesaData.BaseCanyonTargetFlows" [date, $ "BlueMesaData.MayPeakFlowLevel" [@"24:00:00 December 31, Current Year"]] )
         ENDIF
      ENDIF
   ELSE
      $ "BlueMesaData.MinimumBlackCanyonFlow" [date]
   ENDIF;

      ENDFOREACH;

    END;

    RULE                 "April Through July Daily Canyon Target Flows";
    DESCRIPTION          "This rule calculates the preliminary daily flow targets for the Black Canyon section of the river during the spring/summer season (April 1 - July 31).  They are preliminary in that the ramp up and ramp down from the peak flow target are not included yet.  This rule will set each day to either the shoulder flow (May 1 - July 25), the peak flow on the date specified on &quot;BlueMesaData.MayPeakFlowDate&quot; or the min flow value for any day outside of this range.  Though the model is monthly, these values are written to a daily slot on BlueMesaData that will be aggregated and converted to a monthly release from Blue Mesa Res in a subsequent rule (Blue Mesa Operations). - sc 12/27/10";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" OR "GetMonth"( @"t" ) == 1.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      WITH_STATEMENT (NUMERIC peakFlow = $ "BlueMesaData.MayPeakFlowTarget" [@"24:00:00 December 31, Current Year"]) DO
            WITH_STATEMENT (NUMERIC shoulderFlow = $ "BlueMesaData.ShoulderFlowTarget" [@"24:00:00 December 31, Current Year"]) DO
            WITH_STATEMENT (NUMERIC level = $ "BlueMesaData.MayPeakFlowLevel" [@"24:00:00 December 31, Current Year"]) DO
            WITH_STATEMENT (NUMERIC daysOfPeak = $ "BlueMesaData.SpringPeakAndDurationCanyonTargets" ["Max"( level - 1.00000000, 0.00000000 ), 2.00000000]) DO
            WITH_STATEMENT (NUMERIC daysOfShoulder = $ "BlueMesaData.SpringPeakAndDurationCanyonTargets" ["Max"( level - 1.00000000, 0.00000000 ), 1.00000000]) DO
            WITH_STATEMENT (DATETIME peakDate = "CompletePartialDate"( "NumberToDate"( $ "BlueMesaData.MayPeakFlowDate" [@"24:00:00 December 31, Current Year"] ), @"24:00:00 December 31, Current Year" )) DO
            WITH_STATEMENT (DATETIME startShoulderFlowDate = peakDate - daysOfShoulder / 2.00000000) DO
            WITH_STATEMENT (DATETIME endShoulderDate = startShoulderFlowDate + daysOfShoulder - 1.00000000 "day") DO
            WITH_STATEMENT (DATETIME startPeakFlowDate = peakDate - daysOfPeak / 2.00000000) DO
            WITH_STATEMENT (DATETIME endPeakFlowDate = startPeakFlowDate + daysOfPeak - 1.00000000 "day") DO
            FOREACH (DATETIME date IN "GetDates"( @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year", "1 days" )) DO
            WITH_STATEMENT (NUMERIC baseFlow = $ "BlueMesaData.BaseCanyonTargetFlows" [date, level]) DO
            $ "BlueMesaData.MayThruJulyDaily" [date] := IF ( date >= @"May 1" AND date <= @"July 25" )
   THEN
      IF ( date >= startShoulderFlowDate )
      THEN
         IF ( date >= startPeakFlowDate AND date <= endPeakFlowDate )
         THEN
            peakFlow
         ELSE
            IF ( date <= endShoulderDate )
            THEN
               shoulderFlow
            ELSE
               baseFlow
            ENDIF
         ENDIF
      ELSE
         baseFlow
      ENDIF
   ELSE
      baseFlow
   ENDIF;

      END_WITH_STATEMENT;

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "Calculate Gunnison Flow Targets";
    DESCRIPTION          "This rule calculates the may peak flow daily target and the shoulder flow target for the Black Canyon section of the Gunnison River.  These values are written to annual slots on BlueMesaData.  These values are used by subsequent rules to develop a set of daily flow targets through the spring/summer season and then to operate Blue Mesa Reservoir.  This rule only fires on the first day of the year or first day of the run. - sc 12/23/10";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" OR "GetMonth"( @"t" ) == 1.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      $ "BlueMesaData.MayPeakFlowTarget" [@"24:00:00 December 31, Current Year"] := "CalcGunnisonPeakFlowTarget"(  );

      $ "BlueMesaData.ShoulderFlowTarget" [@"24:00:00 December 31, Current Year"] := IF ( TRUE )
   THEN
      8070.00000000 "cfs"
   ELSE
      "CalcGunnisonShoulderFlowTarget"(  )
   ENDIF;

      $ "BlueMesaData.MayPeakFlowLevel" [@"24:00:00 December 31, Current Year"] := "CalcGunnisonPeakFlowLevel"(  );

    END;

    RULE                 "Set Morrow Point and Crystal Storage";
    DESCRIPTION          "This rule sets the storage on Crystal and Morrow Point Reservoirs for the entire run on the first timestep.  It sets all values to the storage on the init timestep.  This is done per Paul Davidson's recommendation. - sc 01/02/10";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      FOREACH (DATETIME date IN @"Start Timestep" TO @"Finish Timestep") DO
            $ "Crystal.Storage" [date] := $ "Crystal.Storage" [@"t - 1"];

      ENDFOREACH;

      FOREACH (DATETIME date IN @"Start Timestep" TO @"Finish Timestep") DO
            $ "MorrowPoint.Storage" [date] := $ "MorrowPoint.Storage" [@"t - 1"];

      ENDFOREACH;

    END;

  END;

  POLICY_GROUP   "Vallecito Ops";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "VallacitoFloodControlProtection";
    DESCRIPTION          "Determines the Vallacito outflow when the pool elevation exceeds the target elevation for the given month. The Vallecito outflow is increased until either the maximum outflow is reached, or the Vallecito pool elevation is equal to the end of month target elevation for Vallecito. -ce 6/6/13";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000 AND $ "Vallecito.Pool Elevation" [] > "GetEOMTargetElevation"( % "Vallecito", @"t" );
    BEGIN

      WITH_STATEMENT (NUMERIC previousPoolElevation = $ "Vallecito.Pool Elevation" [@"t - 1"]) DO
            $ "Vallecito.Outflow" [@"t"] := "Min"( "VallecitoMaxReleaseConstraint"( @"t", previousPoolElevation ), "VolumeToFlow"( "ElevationToStorageAtDate"( % "Vallecito", $ "Vallecito.Pool Elevation" [], @"t" ) - "ElevationToStorageAtDate"( % "Vallecito", "GetEOMTargetElevation"( % "Vallecito", @"t" ), @"t" ), @"t" ) + $ "Vallecito.Outflow" [@"t"] );

      END_WITH_STATEMENT;

    END;

    RULE                 "Vallecito Guide Release";
    DESCRIPTION          "This rule sets the Vallecito Reservoir releases for the entire run on the first timestep.  The ability to do this is predicated on the fact that Vallecito operations only need to know the inflow to the reservoir and nothing else about the state of the system.  If this changes, then it will have be done each timestep. - sc 12/15/10";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      FOREACH (LIST dateOutflowElevation IN "SimulateHeadwaterRes"( % "Vallecito" )) DO
            $ "Vallecito.Outflow" [GET @INDEX 0.00000000 FROM dateOutflowElevation] := GET @INDEX 1.00000000 FROM dateOutflowElevation;

      ENDFOREACH;

    END;

  END;

  POLICY_GROUP   "Taylor Park Ops";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Taylor Park Guide Release";
    DESCRIPTION          "This rule sets the Taylor Park Reservoir releases for the entire run on the first timestep.  The ability to do this is predicated on the fact that Taylor Park operations only need to know the inflow to the reservoir and nothing else about the state of the system.  If this changes, then it will have be done each timestep. - sc 12/31/10<br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      FOREACH (LIST dateOutflowElevation IN "SimulateHeadwaterRes"( % "TaylorPark" )) DO
            $ "TaylorPark.Outflow" [GET @INDEX 0.00000000 FROM dateOutflowElevation] := GET @INDEX 1.00000000 FROM dateOutflowElevation;

      ENDFOREACH;

    END;

  END;

  POLICY_GROUP   "Fontenelle";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Min Flow";
    DESCRIPTION          "This rule ensurs that the minimum instream flow requirements are met. If a lower priority rule sets the flow lower than the min flow then this rule resets the flow. ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( "HasAnyRuleFired"( { "Safe Channel Capacity" , "Set September-November Baseflow" , "Set December-March Baseflow" , "Set April or August Outflow" , "Set Baseflow in off month" , "Set June Outflow" , "Set July Outflow" } ) AND "GetRunCycleIndex"(  ) == 1.00000000 ) COMMENTED_BY "This is necessary for 1,2,3 rule order to prevent trumping of lower priority rules. <br>Not necessary in 3,2,1 order but does not hurt anything. ";
    BEGIN

      IF_STATEMENT ($ "Fontenelle.Outflow" [] < $ "FontenelleData.MinFlow" []) THEN
            $ "Fontenelle.Outflow" [] := $ "FontenelleData.MinFlow" [];

      END_IF_STATEMENT;

    END;

    RULE                 "Max Elevation";
    DESCRIPTION          "This rule prevents overtopping. If a previous rule sets the outflow such that the elevation would overtop the dam, this rule will set the outflow to prevent this.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( "HasAnyRuleFired"( { "Safe Channel Capacity" , "Set September-November Baseflow" , "Set December-March Baseflow" , "Set April or August Outflow" , "Set Baseflow in off month" , "Set June Outflow" , "Set July Outflow" } ) AND "GetRunCycleIndex"(  ) == 1.00000000 ) COMMENTED_BY "This is necessary for 1,2,3 rule order to prevent trumping of lower priority rules. <br>Not necessary in 3,2,1 order but does not hurt anything. ";
    BEGIN

      IF_STATEMENT ($ "Fontenelle.Pool Elevation" [] > $ "FontenelleData.MaxElevation" []) THEN
          DESCRIPTION          "If the Pool elevation goes higher than the max elevation then release whatever necessary to not overtop";
      $ "Fontenelle.Outflow" [] := $ "Fontenelle.Outflow" [] + "VolumeToFlow"( "ElevationToStorage"( % "Fontenelle", $ "Fontenelle.Pool Elevation" [] ) - "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.MaxElevation" [] ), @"t" );

      END_IF_STATEMENT;

    END;

    RULE                 "Min Elevation";
    DESCRIPTION          "If the outflow set by RiverWare will result in a pool elevation less than the minimum pool elevation for Fontenelle, then the outflow is reduced so that the minimum pool elevation is achieved. -ce 6/6/13";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      IF_STATEMENT ($ "Fontenelle.Pool Elevation" [] < $ "FontenelleData.MinElevation" []) THEN
            $ "Fontenelle.Outflow" [] := "SolveOutflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.MinElevation" [] ), $ "Fontenelle.Storage" [@"t - 1"], @"t" );

      END_IF_STATEMENT;

    END;

    RULE                 "Safe Channel Capacity";
    DESCRIPTION          "Prevents outflow from exceeding safe channel capacity unless there is a chance of overtopping, in which case, the &quot;Max Elevation&quot; rule will take precedence. ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "HasAnyRuleFired"( { "Safe Channel Capacity" , "Set September-November Baseflow" , "Set December-March Baseflow" , "Set April or August Outflow" , "Set Baseflow in off month" , "Set June Outflow" , "Set July Outflow" } ) AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      IF_STATEMENT ($ "Fontenelle.Outflow" [] > $ "FontenelleData.SafeChannelCapacity" []) THEN
            $ "Fontenelle.Outflow" [] := "Max"( $ "FontenelleData.SafeChannelCapacity" [], "SolveOutflow"( % "Fontenelle", % "Fontenelle" & "Inflow" [@"t"], "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.August1Target" [] ), "ElevationToStorage"( % "Fontenelle", $ "Fontenelle.Pool Elevation" [@"t - 1"] ), @"t" ) );

      END_IF_STATEMENT;

    END;

    RULE                 "Set September-March Baseflow";
    DESCRIPTION          "Compute the steady flow over September to March necsessary to meet Apr 1 target. <br>Change in storage plus forecasted volume divided by 3 months.  The next two months <br>will look back at this value.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetMonthAsString"( @"t" ) IN { "September" } AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

    INACTIVE      PRINT "September";

    DESCRIPTION          "Compute the steady flow over September to March necsessary to meet Apr 1 target. <br>Change in storage plus forecasted volume divided by 3 months.  The next two months <br>will look back at this value.";
      $ "Fontenelle.Outflow" [] := ( "ElevationToStorage"( % "Fontenelle", $ "Fontenelle.Pool Elevation" [@"t"] ) - "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.April1Target" [] ) + "SumFlowsToVolume"( $ "Fontenelle.Inflow", @"t", @"t + 6" ) ) / 7.00000000 "month";

    END;

    RULE                 "Set December-March Baseflow";
    DESCRIPTION          "This rule is the second of two that set the steady baseflow at Fontenelle.  This rule looks ahead at the forecasted volumes and determines what the max steady flow for the months of September-March can be. ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetMonthAsString"( @"t" ) IN { "December" } AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

    DESCRIPTION          "Compute the steady flow over December to March necsessary to meet Apr 1 target. <br>Change in storage plus forecasted volume divided by 4 months. <br>The next 3 months will look back at this value.";
      $ "Fontenelle.Outflow" [] := ( "ElevationToStorage"( % "Fontenelle", $ "Fontenelle.Pool Elevation" [@"t"] ) - "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.April1Target" [] ) + "SumFlowsToVolume"( $ "Fontenelle.Inflow", @"t", @"t + 3" ) ) / 4.00000000 "month";

    END;

    RULE                 "Set August Outflow";
    DESCRIPTION          "Sets the April and August release to the maximum possible, this also sets May since May gets set to the same as April.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetMonthAsString"( @"t" ) IN { "August" , "" } AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

    DESCRIPTION          "Only set value of Outflow if set to avoid error messages";
      IF_STATEMENT (NaNToZero ( $ "Fontenelle.Outflow" [] ) != 0.00000000 "cfs") THEN
          DESCRIPTION          "Set April or August Outflow to power plant capacity";
      $ "Fontenelle.Outflow" [] := "GetMaxReleaseGivenInflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], @"t" );

      END_IF_STATEMENT;

    END;

    RULE                 "Set April Outflow";
    DESCRIPTION          "Determines the April outflow as either the powerplant capacity, or the steady release required to meet the July 1 target pool elevation, whichever is less. -ce 6/6/13";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetMonthAsString"( @"t" ) IN { "" , "April" } AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      IF_STATEMENT (NaNToZero ( $ "Fontenelle.Outflow" [] ) != 0.00000000 "cfs") THEN
            $ "Fontenelle.Outflow" [] := "Min"( ( ( "ElevationToStorage"( % "Fontenelle", $ "Fontenelle.Pool Elevation" [@"t"] ) - "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.July1Target" [] ) + "SumFlowsToVolume"( $ "Fontenelle.Inflow", @"t", @"t + 2" ) ) / 3.00000000 "month" ) COMMENTED_BY "Steady release over April, May and June to meet July1 Target", "GetMaxReleaseGivenInflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], @"t" ) COMMENTED_BY "Power Plant Capacity" );

      END_IF_STATEMENT;

    END;

    RULE                 "Set Baseflow in off month";
    DESCRIPTION          "Handles the case when the model is started in October, November, January, February, March, or May. In these months the baseflow needs to be set to whatever the previous month's value was. ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetMonthAsString"( @"t" ) IN { "October" , "November" , "January" , "February" , "March" , "May" } AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      IF_STATEMENT ("MonthIs"( { "May" } )) THEN
            $ "Fontenelle.Outflow" [] := "Max"( $ "Fontenelle.Outflow" [@"t - 1"], "SolveOutflow"( % "Fontenelle", % "Fontenelle" & "Inflow" [@"t"], "ElevationToStorage"( % "Fontenelle", 6480.00000000 "ft" ), "ElevationToStorage"( % "Fontenelle", $ "Fontenelle.Pool Elevation" [@"t - 1"] ), @"t" ) );

      ELSE
            $ "Fontenelle.Outflow" [] := $ "Fontenelle.Outflow" [@"t - 1"];

      END_IF_STATEMENT;

    END;

    RULE                 "Set June Outflow";
    DESCRIPTION          "This rule sets the June outflow such that the July 1 target elevation is met.  Alternate cases are when SolveOutflow returns a value greater the the max possible release or less than power plant capacity.  Min(MaxRelease, Max(Release to meet target, power plant capacity)).";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetMonthAsString"( @"t" ) IN { "June" } AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      IF_STATEMENT ($ "Fontenelle.Pool Elevation" [] > $ "FontenelleData.July1Target" []) THEN
            $ "Fontenelle.Outflow" [] := "FontenelleTargetFlow"( $ "FontenelleData.August1Target" [] );

      ELSE
            $ "Fontenelle.Outflow" [] := "FontenelleTargetFlow"( $ "FontenelleData.July1Target" [] );

      END_IF_STATEMENT;

    END;

    RULE                 "Set July Outflow";
    DESCRIPTION          "Solve for the outflow which will cause the pool elevation to reach the end of timestep target. Do not let outflow go below power plant capacity or above the max possible release.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetMonthAsString"( @"t" ) IN { "July" } AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      $ "Fontenelle.Outflow" [] := "FontenelleTargetFlow"( $ "FontenelleData.August1Target" [] );

    END;

    RULE                 "Set Unset Outflow";
    DESCRIPTION          "Sets the outflow for spillCalc and power methods, registering dependencies so that higher priority rules can set values. ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      $ "Fontenelle.Outflow" [] := $ "Fontenelle.Inflow" [];

    END;

    RULE                 "ForecastFutureFGInflow";
    DESCRIPTION          "Determines the projected inflow for Flaming Gorge based on the sum of the projected outflow from Fontenelle and the local inflows between Fontenelle and Flaming Gorge. - ce 6/6/13";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      FOREACH (NUMERIC index IN "GetNumbers"( 1.00000000, IF ( "GetMonth"( @"24:00:00 April Max DayOfMonth, Next Year" ) - "GetMonth"( @"t + 1" ) < 0.00000000 )
   THEN
      12.00000000 - "Abs"( "GetMonth"( @"24:00:00 April Max DayOfMonth, Next Year" ) - "GetMonth"( @"t + 1" ) ) + 1.00000000
   ELSE
      "GetMonth"( @"24:00:00 April Max DayOfMonth, Next Year" ) - "GetMonth"( @"t + 1" ) + 1.00000000
   ENDIF, 1.00000000 )) DO
            $ "FlamingGorgeData.ProjectedInflow" ["OffsetDate"( @"t", index, "1 MONTHS" )] := ( GET @INDEX index - 1.00000000 FROM GET @INDEX 1.00000000 FROM "ForecastFontenelleRelease"( @"t + 1", @"24:00:00 April Max DayOfMonth, Next Year" ) ) + $ "GreenAboveFlamingGorge:InterveningAboveFlamingGorge.Local Inflow" ["OffsetDate"( @"t", index, "1 MONTHS" )];

      ENDFOREACH;

    END;

  END;

  POLICY_GROUP   "Set Future Uses - SNWP, CAP, MWD";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Havasu Rule Curve";
    DESCRIPTION          "This rule could just as easily use a target elevation rather than a storage.<br>It would probably be safer to do so.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 1.00000000 AND @"t" > @"Start Timestep + 1";
    BEGIN

      $ "Havasu.Outflow" [] := "SolveOutflow"( % "Havasu", $ "Havasu.Inflow" [], "GetTargetStorage"( % "Havasu", @"t" ), $ "Havasu.Storage" [@"t - 1"], @"t" );

    END;

    RULE                 "Set Havasu Outflow Exp";
    DESCRIPTION          "This rule sets Havasu's outflow to the the scheduled release from the <br>data object, HavasuOutflow.Outflow we only do this if the outflow is currently not set.  this allows<br>for setting Hoover's outflow manually";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "Havasu.Outflow" [] AND @"t" <= @"Start Timestep + 1" AND "GetRunCycleIndex"(  ) >= 1.00000000;
    BEGIN

      $ "Havasu.Outflow" [] := $ "HavasuOutflow.BHOPSParkerOutflow" [];

    END;

    RULE                 "Mohave Rule Curve";
    DESCRIPTION          "This rule could just as easily use a target elevation rather than a storage.<br>It would probably be safer to do so.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 1.00000000;
    BEGIN

      $ "Mohave.Outflow" [] := "SolveOutflow"( % "Mohave", $ "Mohave.Inflow" [], "GetTargetStorage"( % "Mohave", @"t" ), $ "Mohave.Storage" [@"t - 1"], @"t" );

    END;

    RULE                 "Set Mead Outflow To Demands";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 1.00000000;
    BEGIN

      $ "Mead.Outflow" [] := "Min"( IF ( "GetRunCycleIndex"(  ) >= 3.00000000 )
   THEN
      "CheckResPhysicalConstraint"( % "Mead", @"t" )
   ELSE
      9999999.00000000 "acre-ft/month"
   ENDIF, IF ( @"t" <= @"Start Timestep + 1" )
   THEN
      "VolumeToFlow"( "FlowToVolume"( $ "HavasuOutflow.BHOPSParkerOutflow" [], @"t" ) + "SumAllDiversionsBelowVolume"( % "Mead", @"t", @"t" ) - "SumGainsBelowVolume"( % "Mead", @"t", @"t" ) + "ComputeDeltaTargetStorage"( % "Mohave" ) + "ComputeDeltaTargetStorage"( % "Havasu" ) + $ "Mohave.Evaporation Coefficients" ["GetMonth"( @"t" ) - 1.00000000, 0.00000000] * ( ( "StorageToArea"( % "Mohave", "GetTargetStorage"( % "Mohave", @"t" ) ) + "StorageToArea"( % "Mohave", $ "Mohave.Storage" [@"t - 1"] ) ) / 2.00000000 ) * 1.00000000 "month" + $ "Havasu.Evaporation Coefficients" ["GetMonth"( @"t" ) - 1.00000000, 0.00000000] * ( ( "StorageToArea"( % "Havasu", "GetTargetStorage"( % "Havasu", @"t" ) ) + "StorageToArea"( % "Havasu", $ "Havasu.Storage" [@"t - 1"] ) ) / 2.00000000 ) * 1.00000000 "month", @"t" )
   ELSE
      "VolumeToFlow"( "SumAllDiversionsBelowVolume"( % "Havasu", @"t", @"t" ) - "SumAllGainsBelowVolume"( % "Havasu", @"t", @"t" ) + "SumAllDiversionsBelowVolume"( % "Mead", @"t", @"t" ) - "SumGainsBelowVolume"( % "Mead", @"t", @"t" ) + "ComputeDeltaTargetStorage"( % "Mohave" ) + "ComputeDeltaTargetStorage"( % "Havasu" ) + $ "Mohave.Evaporation Coefficients" ["GetMonth"( @"t" ) - 1.00000000, 0.00000000] * ( ( "StorageToArea"( % "Mohave", "GetTargetStorage"( % "Mohave", @"t" ) ) + "StorageToArea"( % "Mohave", "GetTargetStorage"( % "Mohave", @"t - 1" ) ) ) / 2.00000000 ) * 1.00000000 "month" + $ "Havasu.Evaporation Coefficients" ["GetMonth"( @"t" ) - 1.00000000, 0.00000000] * ( ( "StorageToArea"( % "Havasu", "GetTargetStorage"( % "Havasu", @"t" ) ) + "StorageToArea"( % "Havasu", "GetTargetStorage"( % "Havasu", @"t - 1" ) ) ) / 2.00000000 ) * 1.00000000 "month", @"t" )
   ENDIF );

    END;

    RULE                 "Reset Monthly Forecast Use CAP - Nov and Dec, Cur Year";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND NOT IsNaN $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND "GetMonth"( @"t" ) < 11.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      FOREACH (DATETIME date IN @"24:00:00 November Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            $ "CAPDiversion.Total Diversion Requested" [date] := ( ( "VolumeToFlow"( $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"], date ) - "VolumeToFlow"( $ "Arizona_CU_Forecast1.CAP" ["Dec31ofYear"( date )], date ) ) / 2.00000000 + "VolumeToFlow"( $ "Arizona_CU_Schedules.CAP" [date], date ) );

      ENDFOREACH;

    END;

    RULE                 "Reset Monthly Forecast Use CAP - All Months Outyears";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT IsNaN $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND ( @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND @"t" != @"Start Timestep" ) AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      FOREACH (DATETIME date IN "GetFirstDate"( @"t" ) TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            $ "CAPDiversion.Total Diversion Requested" [date] := ( ( "VolumeToFlow"( $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"], date ) - "VolumeToFlow"( $ "Arizona_CU_Forecast1.CAP" [@"24:00:00 December 31, Current Year"], date ) ) / "GetDaysBasedOnFirstDate"( @"t" ) + "VolumeToFlow"( $ "Arizona_CU_Schedules.CAP" [date], date ) );

      ENDFOREACH;

    END;

    RULE                 "Reset Monthly Forecast Use SNWP All Years";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT IsNaN $ "ForecastUse.SNWPResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            FOREACH (SLOT slot IN { $ "PumpingFromLakeMead:SNWP.Diversion Requested" , $ "PumpingFromLakeMead:SNWP.Depletion Requested" }) DO
            slot [date] := IF ( "GetYear"( @"t" ) == "GetYear"( @"Start Timestep" ) )
   THEN
      ( $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date] + ( "VolumeToFlow"( $ "ForecastUse.SNWPResetAnnualFC" [@"24:00:00 December 31, Current Year"], date ) - "VolumeToFlow"( $ "Nevada_CU_Forecast1.SNWP" [@"24:00:00 December 31, Current Year"], date ) ) / ( 12.00000000 - "GetMonth"( @"Start Timestep" ) + 1.00000000 ) )
   ELSE
      ( $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date] + ( "VolumeToFlow"( $ "ForecastUse.SNWPResetAnnualFC" [@"24:00:00 December 31, Current Year"], date ) - "VolumeToFlow"( $ "Nevada_CU_Forecast1.SNWP" [@"24:00:00 December 31, Current Year"], date ) ) / 12.00000000 )
   ENDIF;

      ENDFOREACH;

      ENDFOREACH;

    END;

    RULE                 "Reset Monthly Forecast Use MWD - Nov and Dec, Cur Year";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND NOT IsNaN $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND "GetMonth"( @"t" ) < 11.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      FOREACH (DATETIME date IN @"24:00:00 November Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            $ "MWDDiversion:MWD.Diversion Requested" [date] := "Max"( 0.00000000 "acre-ft/month", ( "VolumeToFlow"( $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"], date ) - "VolumeToFlow"( $ "California_CU_Forecast1.MWD" ["Dec31ofYear"( date )], date ) ) / 2.00000000 + "VolumeToFlow"( $ "California_CU_Schedules.MWDDiversion" [date], date ) );

      ENDFOREACH;

    END;

    RULE                 "Reset Monthly Forecast Use MWD - All Months Outyears";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT IsNaN $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND ( @"t" != @"Start Timestep" AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      FOREACH (DATETIME date IN "GetFirstDate"( @"t" ) TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            $ "MWDDiversion:MWD.Diversion Requested" [date] := ( "VolumeToFlow"( $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"], date ) - "VolumeToFlow"( $ "California_CU_Forecast1.MWD" [@"24:00:00 December 31, Current Year"], date ) ) / "GetDaysBasedOnFirstDate"( @"t" ) + "VolumeToFlow"( $ "California_CU_Schedules.MWDDiversion" [date], date );

      ENDFOREACH;

    END;

    RULE                 "Non P123b-IID Ca Overrun";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "AnnualWaterUse.CaMinusPVYPIID" [@"24:00:00 December 31, Current Year"] AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      $ "AnnualWaterUse.CaOverrun noPVYPIID" [] := $ "AnnualWaterUse.CaNoPVYPIIDTotalAnnual" [] - $ "AnnualWaterUse.CaMinusPVYPIID" [@"24:00:00 December 31, Current Year"];

    END;

    RULE                 "SumAnnualStateUse - Div Req";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    BEGIN

      FOREACH (STRING state IN { "CaNoPVYPIID" , "AzNoCAP" , "Nv" , "P123b" }) DO
            "AnnualWaterUse." CONCAT state CONCAT "TotalAnnual" [@"24:00:00 December 31, Current Year"] := IF ( "GetYear"( @"t" ) == "GetYear"( @"Start Timestep" ) AND "GetMonth"( @"Start Timestep" ) > 1.00000000 )
   THEN
      "SumSlot"( % "AnnualWaterUse" & ( state CONCAT "TotalMonthlyOrder" ), @"Start Timestep", @"24:00:00 December Max DayOfMonth, Current Year" ) + "SumSlot"( % "AnnualWaterUse" & ( state CONCAT "TotalMonthlyActual" ), @"24:00:00 January Max DayOfMonth, Current Year", @"Start Timestep - 1" )
   ELSE
      "SumSlot"( % "AnnualWaterUse" & ( state CONCAT "TotalMonthlyOrder" ), @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year" )
   ENDIF;

      ENDFOREACH;

    END;

    RULE                 "SumStateMonthlyOrders - DivReq-noP123b or IID";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January 31, Current Year" AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      FOREACH (DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            $ "AnnualWaterUse.CaNoPVYPIIDTotalMonthlyOrder" [date] := "FlowToVolume"( $ "AAC:Coachella.Diversion Requested" [date], date ) + "FlowToVolume"( $ "AAC:SaltonSea.Diversion Requested" [date], date ) + "FlowToVolume"( $ "AAC:Ranch5.Diversion Requested" [date], date ) + "FlowToVolume"( $ "CaPkrToImp.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "CRIR:CRIRCa.Diversion Requested" [date], date ) + "FlowToVolume"( $ "CaDvsToPkr.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "FtMohaveIndRes:CA.Diversion Requested" [date], date ) + ( "FlowToVolume"( $ "MWDDiversion:MWD.Diversion Requested" [date], date ) - $ "California_CU_Schedules.MWDReturns" [date] );

            $ "AnnualWaterUse.P123bTotalMonthlyOrder" [date] := "FlowToVolume"( $ "AAC:YumaProject.Diversion Requested" [date], date ) + "FlowToVolume"( $ "PaloVerde.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersBlwImp:YumaIsland.Diversion Requested" [date], date );

            $ "AnnualWaterUse.AzNoCAPTotalMonthlyOrder" [date] := "FlowToVolume"( $ "AzPkrToImp.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "GilaGravityMainCanal.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "GilaAndYumaUsers.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "CRIR:CRIRAz.Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersBlwImp:AzPumpersBlwImp.Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersBlwImp:SouthernPacific.Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersBlwImp:YAO.Diversion Requested" [date], date ) + "FlowToVolume"( $ "FtMohaveIndRes:AZ.Diversion Requested" [date], date ) + "FlowToVolume"( $ "AzDvsToPkr.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "PumpingFromLakeMead:LMNRA Az Mead.Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersMeadToMohave:LMNRA Az Mohave.Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersBlwImp:Ft Yuma.Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersMeadToMohave:DavisDamProject.Diversion Requested" [date], date );

            $ "AnnualWaterUse.NvTotalMonthlyOrder" [date] := "FlowToVolume"( $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date], date ) + "FlowToVolume"( $ "NvDvsToPkr.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "FtMohaveIndRes:NV.Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersMeadToMohave:LMNRA Nv Mohave.Diversion Requested" [date], date );

      ENDFOREACH;

    END;

    RULE                 "Set Normal Schedules MWD & SNWP";
    DESCRIPTION          "Need to separate CAP & CVWD from MWD & SNWP for full surplus";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      FOREACH (DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO "GetLastDate"( @"t" )) DO
            $ "MWDDiversion:MWD.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "California_CU_Actual.MWDDiversion" [date], date )
   ELSE
      "VolumeToFlow"( $ "California_CU_Schedules.MWDDiversion" [date], date )
   ENDIF;

            $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Nevada_CU_Actual.SNWP" [date], date )
   ELSE
      "VolumeToFlow"( $ "Nevada_CU_Schedules.SNWP" [date], date )
   ENDIF;

      ENDFOREACH;

    END;

    RULE                 "Set Normal Schedules CAP";
    DESCRIPTION          "May need 2nd condition (@t = Jan, current year) for full surplus<br>Need to separate CAP from MWD & SNWP for full surplus";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      FOREACH (DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO "GetLastDate"( @"t" )) DO
            $ "CAPDiversion.Total Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.CAP" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.CAP" [date], date )
   ENDIF;

      ENDFOREACH;

    END;

  END;

  POLICY_GROUP   "Reset Forecast Use";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Reset MWD Annual Forecast Use - Force to CA Apportionment";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"] := $ "California_CU_Forecast1.MWD" [@"24:00:00 December 31, Current Year"] - $ "California_CU_Overrun.California_Overrun_State_Ap" [];

    END;

    RULE                 "Reset Annual CAP Forecast Use - Force to AZ Apportionment";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.CAP" [@"24:00:00 December 31, Current Year"] - $ "Arizona_CU_Overrun.Arizona_Overrun_State_Ap" [];

    END;

    RULE                 "Reset Annual SNWP Forecast Use - Force to NV Apportionment";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "ForecastUse.SNWPResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      $ "ForecastUse.SNWPResetAnnualFC" [@"24:00:00 December 31, Current Year"] := $ "Nevada_CU_Forecast1.SNWP" [@"24:00:00 December 31, Current Year"] - $ "Nevada_CU_Overrun.Nevada_Overrun_State_Ap" [];

    END;

  END;

  POLICY_GROUP   "LC WaterUse Data Setup";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Set Operational GainLoss";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep";
    BEGIN

      FOREACH (DATETIME date IN @"Start Timestep" TO @"Finish Timestep") DO
            $ "HavasuToImperial:DailyOperationalGainLoss.Local Inflow" [date] := IF ( date <= @"Start Timestep + 1" )
   THEN
      ( "VolumeToFlow"( $ "HavasuOutflow.ParkerScheduleRequirement" [date], date ) - $ "HavasuOutflow.BHOPSParkerOutflow" [date] )
   ELSE
      0.00000000 "acre-ft/month"
   ENDIF;

      ENDFOREACH;

    END;

    RULE                 "Set Parker Schedule Requirement";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND IsNaN $ "HavasuOutflow.ParkerScheduleRequirement" [];
    BEGIN

      FOREACH (DATETIME date IN @"Start Timestep" TO @"Finish Timestep") DO
            $ "HavasuOutflow.ParkerScheduleRequirement" [date] := "FlowToVolume"( $ "AAC.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "AzPkrToImp.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "CRIR.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "CaPkrToImp.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "GilaAndYumaUsers.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "GilaGravityMainCanal.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "PaloVerde.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersBlwImp.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "MexicanTreatyDelivery.Total Diversion Requested" [date], date ) - ( "FlowToVolume"( $ "HavasuToImperial:GainsPkrToImp.Local Inflow" [date], date ) + "FlowToVolume"( $ "BelowImperialDam:GainsImpToNIB.Local Inflow" [date], date ) + "FlowToVolume"( $ "BelowImperialDam:Gila River.Local Inflow" [date], date ) );

      ENDFOREACH;

    END;

    RULE                 "Forecast Test";
    DESCRIPTION          "This rule sets the local inflow for the slots included for the Lower Basin.  This rule has to have a high priority so the systems will solve. It is set in a beginning run cycle and at a high priority so the Lower basin will solve.  In certain situations when the mead.outflow is changed by the Flood control rules for mead, the system will not solve.  A solution has to be found, but moving this rule to a high priority in a beginning time cycle is a start. TP 3/18/2013";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND NOT "HasRuleFiredSuccessfully"( "ThisRule" ) AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      FOREACH (DATETIME date IN "GetDates"( @"Start Timestep", @"Finish Timestep", "1 Months" )) DO
          INACTIVE      $ "BelowImperialDam:GainsImpToNIB.Local Inflow" [date] := $ "LowerBasinDemandVariability.GainsImpToNIBLocalInflow" [date];

          INACTIVE      $ "BelowImperialDam:Gila River.Local Inflow" [date] := $ "LowerBasinDemandVariability.GilaRiverLocalInflow" [date];

          INACTIVE      $ "CoRivMeadToMohave:GainsAboveDavis.Local Inflow" [date] := $ "LowerBasinDemandVariability.GainsAboveDavisLocalInflow" [date];

          INACTIVE      $ "HavasuToImperial:GainsPkrToImp.Local Inflow" [date] := $ "LowerBasinDemandVariability.GainsPkrToImpLocalInflow" [date];

          INACTIVE      $ "MWDAndCAPReach:GainsAboveParker.Local Inflow" [date] := $ "LowerBasinDemandVariability.GainsAboveParkerLocalInflow" [date];

            IF_STATEMENT ("IsMRM"(  )) THEN
            $ "BelowImperialDam:GainsImpToNIB.Local Inflow" [date] := $ "LowerBasinDemandVariability.ImperialToNIBLocalInflows" [date, "Fifty"];

            $ "BelowImperialDam:Gila River.Local Inflow" [date] := $ "LowerBasinDemandVariability.GilaRiverLocalInflow" [date];

            $ "CoRivMeadToMohave:GainsAboveDavis.Local Inflow" [date] := $ "LowerBasinDemandVariability.HooverToDavisLocalInflows" [date, "Fifty"];

            $ "HavasuToImperial:GainsPkrToImp.Local Inflow" [date] := $ "LowerBasinDemandVariability.ParkerToImperialLocalInflows" [date, "Fifty"];

            $ "MWDAndCAPReach:GainsAboveParker.Local Inflow" [date] := $ "LowerBasinDemandVariability.DavisToParkerLocalInflows" [date, "Fifty"];

      ELSE
            $ "BelowImperialDam:GainsImpToNIB.Local Inflow" [date] := $ "LowerBasinDemandVariability.GainsImpToNIBLocalInflow" [date];

            $ "BelowImperialDam:Gila River.Local Inflow" [date] := $ "LowerBasinDemandVariability.GilaRiverLocalInflow" [date];

            $ "CoRivMeadToMohave:GainsAboveDavis.Local Inflow" [date] := $ "LowerBasinDemandVariability.GainsAboveDavisLocalInflow" [date];

            $ "HavasuToImperial:GainsPkrToImp.Local Inflow" [date] := $ "LowerBasinDemandVariability.GainsPkrToImpLocalInflow" [date];

            $ "MWDAndCAPReach:GainsAboveParker.Local Inflow" [date] := $ "LowerBasinDemandVariability.GainsAboveParkerLocalInflow" [date];

      END_IF_STATEMENT;

      ENDFOREACH;

    END;

    RULE                 "Cal Allotments - noP123b or IID";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      $ "AnnualWaterUse.CaMinusPVYPIID" [@"24:00:00 December 31, Current Year"] := $ "AnnualWaterUse.California_Apportionment" [@"24:00:00 December 31, Current Year"] - $ "AnnualWaterUse.P123bApproved" [@"24:00:00 December 31, Current Year"] - $ "California_CU_AnnualApproval.IID" [@"24:00:00 December 31, Current Year"];

    END;

    RULE                 "Sum State Monthly Actual CU-noP123b or IID";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      FOREACH (DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"Start Timestep - 1") DO
            $ "AnnualWaterUse.CaNoPVYPIIDTotalMonthlyActual" [date] := $ "California_CU_Actual.MWD" [date] + $ "California_CU_Actual.CaPumpersAbvImp" [date] + $ "California_CU_Actual.Coachella" [date] + $ "California_CU_Actual.Winterhaven" [date] + $ "California_CU_Actual.CRIRCa" [date] + $ "California_CU_Actual.SaltonSea" [date] + $ "California_CU_Actual.Chemehuevi" [date] + $ "California_CU_Actual.FtMohaveCa" [date] + $ "California_CU_Actual.Needles" [date] + $ "California_CU_Actual.Ranch5" [date] + $ "California_CU_Actual.OtherLCWSP" [date];

            $ "AnnualWaterUse.P123bTotalMonthlyActual" [date] := $ "California_CU_Actual.PaloVerde" [date] + $ "California_CU_Actual.YumaProject" [date] + $ "California_CU_Actual.YumaIsland" [date];

            $ "AnnualWaterUse.AzNoCAPTotalMonthlyActual" [date] := $ "Arizona_CU_Actual.CRIRAz" [date] + $ "Arizona_CU_Actual.CibolaNWR" [date] + $ "Arizona_CU_Actual.CibolaValleyIID" [date] + $ "Arizona_CU_Actual.City of Parker" [date] + $ "Arizona_CU_Actual.ImperialNWR" [date] + $ "Arizona_CU_Actual.BrookeWater" [date] + $ "Arizona_CU_Actual.Ehrenberg" [date] + $ "Arizona_CU_Actual.AzPumpersAbvImp" [date] + $ "Arizona_CU_Actual.AzPumpersBlwImp" [date] + $ "Arizona_CU_Actual.NGVIDD" [date] + $ "Arizona_CU_Actual.WMIDD" [date] + $ "Arizona_CU_Actual.YCWUA" [date] + $ "Arizona_CU_Actual.MCAirStation" [date] + $ "Arizona_CU_Actual.YMIDD" [date] + $ "Arizona_CU_Actual.YID" [date] + $ "Arizona_CU_Actual.UnitB" [date] + $ "Arizona_CU_Actual.City of Yuma" [date] + $ "Arizona_CU_Actual.UofA" [date] + $ "Arizona_CU_Actual.LakeHavasuCity" [date] + $ "Arizona_CU_Actual.YumaUnionHighScl" [date] + $ "Arizona_CU_Actual.YumaProvingGround" [date] + $ "Arizona_CU_Actual.Cocopah Indian Res" [date] + $ "Arizona_CU_Actual.Gila Monster Farms" [date] + $ "Arizona_CU_Actual.DesertLawnMemorial" [date] + $ "Arizona_CU_Actual.SouthernPacific" [date] + $ "Arizona_CU_Actual.YAO" [date] + $ "Arizona_CU_Actual.BullheadCity" [date] + $ "Arizona_CU_Actual.FtMohaveAz" [date] + $ "Arizona_CU_Actual.DavisDamProject" [date] + $ "Arizona_CU_Actual.MohaveValleyIID" [date] + $ "Arizona_CU_Actual.MohaveWaterConsDist" [date] + $ "Arizona_CU_Actual.HavasuNWR" [date] + $ "Arizona_CU_Actual.GoldenShores" [date] + $ "Arizona_CU_Actual.LMNRA Az Mead" [date] + $ "Arizona_CU_Actual.LMNRA Az Mohave" [date] + $ "Arizona_CU_Actual.Ft Yuma" [date] + $ "Arizona_CU_Actual.AzPumpersDvsToPkr" [date];

            $ "AnnualWaterUse.NvTotalMonthlyActual" [date] := $ "Nevada_CU_Actual.SNWP" [date] + $ "Nevada_CU_Actual.FtMohaveNv" [date] + $ "Nevada_CU_Actual.BigBend" [date] + $ "Nevada_CU_Actual.SCE" [date] + $ "Nevada_CU_Actual.LMNRA Mohave" [date];

      ENDFOREACH;

    END;

    RULE                 "Overruns Based on State Apportionments";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      FOREACH (STRING state IN { "California" , "Arizona" , "Nevada" }) DO
            "GetObject"( state CONCAT "_CU_Overrun" ) & ( state CONCAT "_Overrun_State_Ap" ) [] := % "AnnualWaterUse" & ( state CONCAT "_Forecast1" ) [@"24:00:00 December 31, Current Year"] - % "AnnualWaterUse" & ( state CONCAT "_Apportionment" ) [@"24:00:00 December 31, Current Year"];

      ENDFOREACH;

    END;

    RULE                 "Priority123b Overrun";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      $ "AnnualWaterUse.P123bOverrun" [@"24:00:00 December 31, Current Year"] := $ "AnnualWaterUse.P123b Forecast1" [@"24:00:00 December 31, Current Year"] - $ "AnnualWaterUse.P123bApproved" [@"24:00:00 December 31, Current Year"];

    END;

    RULE                 "Set CU Over-Underruns User-By-User";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      FOREACH (STRING state IN { "California" , "Arizona" , "Nevada" }) DO
            FOREACH (STRING user IN "SlotToString"( "GetObject"( state CONCAT "_CU_AnnualApproval" ) )) DO
            "GetObject"( state CONCAT "_CU_Overrun" ) & user [@"24:00:00 December 31, Current Year"] := "GetObject"( state CONCAT "_CU_Forecast1" ) & user [@"24:00:00 December 31, Current Year"] - "GetObject"( state CONCAT "_CU_AnnualApproval" ) & user [@"24:00:00 December 31, Current Year"];

      ENDFOREACH;

      ENDFOREACH;

    END;

    RULE                 "Priority123b Approval";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      $ "AnnualWaterUse.P123bApproved" [@"24:00:00 December 31, Current Year"] := $ "California_CU_AnnualApproval.PaloVerde" [@"24:00:00 December 31, Current Year"] + $ "California_CU_AnnualApproval.YumaProject" [@"24:00:00 December 31, Current Year"] + $ "California_CU_AnnualApproval.YumaIsland" [@"24:00:00 December 31, Current Year"];

    END;

    RULE                 "Sum Annual Approvals for Lower Basin States";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      FOREACH (STRING state IN { "California" , "Arizona" , "Nevada" }) DO
            % "AnnualWaterUse" & ( state CONCAT "_AnnualApproval" ) [@"24:00:00 December 31, Current Year"] := IF ( state == "Nevada" )
   THEN
      $ "Nevada_CU_AnnualApproval.SNWP" [@"24:00:00 December 31, Current Year"] + $ "Nevada_CU_AnnualApproval.BigBend" [@"24:00:00 December 31, Current Year"] + $ "Nevada_CU_AnnualApproval.FtMohaveNv" [@"24:00:00 December 31, Current Year"] + $ "Nevada_CU_AnnualApproval.LMNRA Mohave" [@"24:00:00 December 31, Current Year"] + $ "Nevada_CU_AnnualApproval.SCE" [@"24:00:00 December 31, Current Year"]
   ELSE
      IF ( state == "California" )
      THEN
         "SumSlotListDates"( "GetObject"( state CONCAT "_CU_AnnualApproval" ), @"24:00:00 December 31, Current Year" ) - $ "California_CU_AnnualApproval.MWDDiversion" [@"24:00:00 December 31, Current Year"] - $ "California_CU_AnnualApproval.MWDReturns" [@"24:00:00 December 31, Current Year"]
      ELSE
         "SumSlotListDates"( "GetObject"( state CONCAT "_CU_AnnualApproval" ), @"24:00:00 December 31, Current Year" )
      ENDIF
   ENDIF;

      ENDFOREACH;

    END;

    RULE                 "Sum Annual Forecast1 for Lower Basin States";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      FOREACH (STRING state IN { "California" , "Arizona" , "Nevada" }) DO
            % "AnnualWaterUse" & ( state CONCAT "_Forecast1" ) [@"24:00:00 December 31, Current Year"] := IF ( state == "Nevada" )
   THEN
      $ "Nevada_CU_Forecast1.SNWP" [@"24:00:00 December 31, Current Year"] + $ "Nevada_CU_Forecast1.BigBend" [@"24:00:00 December 31, Current Year"] + $ "Nevada_CU_Forecast1.FtMohaveNv" [@"24:00:00 December 31, Current Year"] + $ "Nevada_CU_Forecast1.LMNRA Mohave" [@"24:00:00 December 31, Current Year"] + $ "Nevada_CU_Forecast1.SCE" [@"24:00:00 December 31, Current Year"]
   ELSE
      IF ( state == "California" )
      THEN
         "SumSlotListDates"( % "California_CU_Forecast1", @"24:00:00 December 31, Current Year" ) - $ "California_CU_Forecast1.MWDDiversion" [@"24:00:00 December 31, Current Year"] - $ "California_CU_Forecast1.MWDReturns" [@"24:00:00 December 31, Current Year"]
      ELSE
         "SumSlotListDates"( % "Arizona_CU_Forecast1", @"24:00:00 December 31, Current Year" )
      ENDIF
   ENDIF;

      ENDFOREACH;

    END;

    RULE                 "Priority 123b Use Above 420K";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      $ "AnnualWaterUse.P123b UseAbv420" [@"24:00:00 December 31, Current Year"] := $ "California_CU_Forecast1.PaloVerde" [@"24:00:00 December 31, Current Year"] + $ "California_CU_Forecast1.YumaProject" [@"24:00:00 December 31, Current Year"] + $ "California_CU_Forecast1.YumaIsland" [@"24:00:00 December 31, Current Year"] - 420000.00000000 "acre-ft";

    END;

    RULE                 "Priority 123b Forecast";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      $ "AnnualWaterUse.P123b Forecast1" [@"24:00:00 December 31, Current Year"] := $ "California_CU_Forecast1.PaloVerde" [@"24:00:00 December 31, Current Year"] + $ "California_CU_Forecast1.YumaProject" [@"24:00:00 December 31, Current Year"] + $ "California_CU_Forecast1.YumaIsland" [@"24:00:00 December 31, Current Year"];

    END;

    RULE                 "Set Forecast1";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      FOREACH (STRING state IN { "California" , "Arizona" , "Nevada" , "Mexico" }) DO
            FOREACH (STRING user IN "SlotToString"( "GetObject"( state CONCAT "_CU_Forecast1" ) )) DO
            "GetObject"( state CONCAT "_CU_Forecast1" ) & user [@"24:00:00 December 31, Current Year"] := IF ( "GetYear"( @"t" ) == "GetYear"( @"Start Timestep" ) AND "GetMonth"( @"Start Timestep" ) > 1.00000000 )
   THEN
      "SumSlot"( "GetObject"( state CONCAT "_CU_Actual" ) & user, @"24:00:00 January Max DayOfMonth, Current Year", @"Start Timestep - 1" ) + "SumSlot"( "GetObject"( state CONCAT "_CU_Schedules" ) & user, @"Start Timestep", @"24:00:00 December Max DayOfMonth, Current Year" )
   ELSE
      "AnnualVolumeSlot"( "GetObject"( state CONCAT "_CU_Schedules" ) & user )
   ENDIF;

      ENDFOREACH;

      ENDFOREACH;

    END;

    RULE                 "Set Schedules Volume to Flow";
    DESCRIPTION          "This rule sets the monthly diversion requests for lower basin diversion for each timestep in the run period.<br>This rule fires on the first timestep of the first runcycle. - CE 9/17/13";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      FOREACH (DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO "GetLastDate"( @"t" )) DO
            $ "PaloVerde.Total Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "California_CU_Actual.PaloVerde" [date], date )
   ELSE
      "VolumeToFlow"( $ "California_CU_Schedules.PaloVerde" [date], date )
   ENDIF;

            $ "CRIR:CRIRAz.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.CRIRAz" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.CRIRAz" [date], date )
   ENDIF;

            $ "CRIR:CRIRCa.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "California_CU_Actual.CRIRCa" [date], date )
   ELSE
      "VolumeToFlow"( $ "California_CU_Schedules.CRIRCa" [date], date )
   ENDIF;

            $ "CaPkrToImp:Winterhaven.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "California_CU_Actual.Winterhaven" [date], date )
   ELSE
      "VolumeToFlow"( $ "California_CU_Schedules.Winterhaven" [date], date )
   ENDIF;

            $ "CaPkrToImp:CaPumpersAbvImp.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "California_CU_Actual.CaPumpersAbvImp" [date], date )
   ELSE
      "VolumeToFlow"( $ "California_CU_Schedules.CaPumpersAbvImp" [date], date )
   ENDIF;

            $ "AzPkrToImp:AzPumpersAbvImp.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.AzPumpersAbvImp" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.AzPumpersAbvImp" [date], date )
   ENDIF;

            $ "AzPkrToImp:BrookeWater.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.BrookeWater" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.BrookeWater" [date], date )
   ENDIF;

            $ "AzPkrToImp:CibolaNWR.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.CibolaNWR" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.CibolaNWR" [date], date )
   ENDIF;

            $ "AzPkrToImp:CibolaValleyIID.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.CibolaValleyIID" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.CibolaValleyIID" [date], date )
   ENDIF;

            $ "AzPkrToImp:Ehrenberg.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.Ehrenberg" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.Ehrenberg" [date], date )
   ENDIF;

            $ "AzPkrToImp:ImperialNWR.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.ImperialNWR" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.ImperialNWR" [date], date )
   ENDIF;

            $ "AzPkrToImp:Parker.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.City of Parker" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.City of Parker" [date], date )
   ENDIF;

            $ "AAC:SaltonSea.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "California_CU_Actual.SaltonSea" [date], date )
   ELSE
      "VolumeToFlow"( $ "California_CU_Schedules.SaltonSea" [date], date )
   ENDIF;

            $ "AAC:IID.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "California_CU_Actual.IID" [date], date )
   ELSE
      "VolumeToFlow"( $ "California_CU_Schedules.IID" [date], date )
   ENDIF;

            $ "AAC:Coachella.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "California_CU_Actual.Coachella" [date], date )
   ELSE
      "VolumeToFlow"( $ "California_CU_Schedules.Coachella" [date], date )
   ENDIF;

            $ "AAC:YumaProject.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "California_CU_Actual.YumaProject" [date], date )
   ELSE
      "VolumeToFlow"( $ "California_CU_Schedules.YumaProject" [date], date )
   ENDIF;

            $ "AAC:Ranch5.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "California_CU_Actual.Ranch5" [date], date )
   ELSE
      "VolumeToFlow"( $ "California_CU_Schedules.Ranch5" [date], date )
   ENDIF;

            $ "GilaAndYumaUsers:CocopahIndRes.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.Cocopah Indian Res" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.Cocopah Indian Res" [date], date )
   ENDIF;

            $ "GilaAndYumaUsers:DesertLawnMemorial.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.DesertLawnMemorial" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.DesertLawnMemorial" [date], date )
   ENDIF;

            $ "GilaAndYumaUsers:GilaMonsterFarms.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.Gila Monster Farms" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.Gila Monster Farms" [date], date )
   ENDIF;

            $ "OthersBlwImp:AzPumpersBlwImp.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.AzPumpersBlwImp" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.AzPumpersBlwImp" [date], date )
   ENDIF;

            $ "OthersBlwImp:SouthernPacific.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.SouthernPacific" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.SouthernPacific" [date], date )
   ENDIF;

            $ "OthersBlwImp:YAO.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.YAO" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.YAO" [date], date )
   ENDIF;

            $ "OthersBlwImp:YumaIsland.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "California_CU_Actual.YumaIsland" [date], date )
   ELSE
      "VolumeToFlow"( $ "California_CU_Schedules.YumaIsland" [date], date )
   ENDIF;

            $ "OthersBlwImp:Ft Yuma.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.Ft Yuma" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.Ft Yuma" [date], date )
   ENDIF;

            $ "GilaGravityMainCanal:CityOfYuma.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.City of Yuma" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.City of Yuma" [date], date )
   ENDIF;

            $ "GilaGravityMainCanal:MCAirStation.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.MCAirStation" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.MCAirStation" [date], date )
   ENDIF;

            $ "GilaGravityMainCanal:NGVIDD.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.NGVIDD" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.NGVIDD" [date], date )
   ENDIF;

            $ "GilaGravityMainCanal:UnitB.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.UnitB" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.UnitB" [date], date )
   ENDIF;

            $ "GilaGravityMainCanal:UofA.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.UofA" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.UofA" [date], date )
   ENDIF;

            $ "GilaGravityMainCanal:WMIDD.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.WMIDD" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.WMIDD" [date], date )
   ENDIF;

            $ "GilaGravityMainCanal:YCWUA.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.YCWUA" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.YCWUA" [date], date )
   ENDIF;

            $ "GilaGravityMainCanal:YID.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.YID" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.YID" [date], date )
   ENDIF;

            $ "GilaGravityMainCanal:YMIDD.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.YMIDD" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.YMIDD" [date], date )
   ENDIF;

            $ "GilaGravityMainCanal:YumaProvingGround.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.YumaProvingGround" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.YumaProvingGround" [date], date )
   ENDIF;

            $ "GilaGravityMainCanal:YumaUnionHighScl.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.YumaUnionHighScl" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.YumaUnionHighScl" [date], date )
   ENDIF;

            $ "MWDDiversion:Tijuana.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Mexico_CU_Actual.MexicoTJ" [date], date )
   ELSE
      "VolumeToFlow"( $ "Mexico_CU_Schedules.MexicoTJ" [date], date )
   ENDIF;

            $ "MexicanTreatyDelivery:MexicoSched.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Mexico_CU_Actual.MexicoSched" [date] - $ "Mexico_CU_Actual.MexicoTJ" [date], date )
   ELSE
      "VolumeToFlow"( $ "Mexico_CU_Schedules.MexicoSched" [date] - $ "Mexico_CU_Schedules.MexicoTJ" [date], date )
   ENDIF;

            $ "MexicanTreatyDelivery:MexicoBypass.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Mexico_CU_Actual.MexicoBypass" [date], date )
   ELSE
      "VolumeToFlow"( $ "Mexico_CU_Schedules.MexicoBypass" [date], date )
   ENDIF;

            $ "MexicanTreatyDelivery:MexicoExcess.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Mexico_CU_Actual.MexicoExcess" [date], date )
   ELSE
      "VolumeToFlow"( $ "Mexico_CU_Schedules.MexicoExcess" [date], date )
   ENDIF;

            $ "FtMohaveIndRes:NV.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Nevada_CU_Actual.FtMohaveNv" [date], date )
   ELSE
      "VolumeToFlow"( $ "Nevada_CU_Schedules.FtMohaveNv" [date], date )
   ENDIF;

            $ "FtMohaveIndRes:CA.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "California_CU_Actual.FtMohaveCa" [date], date )
   ELSE
      "VolumeToFlow"( $ "California_CU_Schedules.FtMohaveCa" [date], date )
   ENDIF;

            $ "FtMohaveIndRes:AZ.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.FtMohaveAz" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.FtMohaveAz" [date], date )
   ENDIF;

            $ "NvDvsToPkr:SCE.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Nevada_CU_Actual.SCE" [date], date )
   ELSE
      "VolumeToFlow"( $ "Nevada_CU_Schedules.SCE" [date], date )
   ENDIF;

            $ "NvDvsToPkr:BigBend.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Nevada_CU_Actual.BigBend" [date], date )
   ELSE
      "VolumeToFlow"( $ "Nevada_CU_Schedules.BigBend" [date], date )
   ENDIF;

            $ "OthersMeadToMohave:LMNRA Nv Mohave.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Nevada_CU_Actual.LMNRA Mohave" [date], date )
   ELSE
      "VolumeToFlow"( $ "Nevada_CU_Schedules.LMNRA Mohave" [date], date )
   ENDIF;

            $ "AzDvsToPkr:BullheadCity.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.BullheadCity" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.BullheadCity" [date], date )
   ENDIF;

            $ "CaDvsToPkr:Chemehuevi.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "California_CU_Actual.Chemehuevi" [date], date )
   ELSE
      "VolumeToFlow"( $ "California_CU_Schedules.Chemehuevi" [date], date )
   ENDIF;

            $ "CaDvsToPkr:Needles.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "California_CU_Actual.Needles" [date], date )
   ELSE
      "VolumeToFlow"( $ "California_CU_Schedules.Needles" [date], date )
   ENDIF;

            $ "CaDvsToPkr:OtherLCWSP.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "California_CU_Actual.OtherLCWSP" [date], date )
   ELSE
      "VolumeToFlow"( $ "California_CU_Schedules.OtherLCWSP" [date], date )
   ENDIF;

            $ "OthersMeadToMohave:DavisDamProject.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.DavisDamProject" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.DavisDamProject" [date], date )
   ENDIF;

            $ "AzDvsToPkr:GoldenShores.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.GoldenShores" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.GoldenShores" [date], date )
   ENDIF;

            $ "AzDvsToPkr:HavasuNWR.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.HavasuNWR" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.HavasuNWR" [date], date )
   ENDIF;

            $ "AzDvsToPkr:LakeHavasuCity.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.LakeHavasuCity" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.LakeHavasuCity" [date], date )
   ENDIF;

            $ "AzDvsToPkr:MohaveValleyIID.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.MohaveValleyIID" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.MohaveValleyIID" [date], date )
   ENDIF;

            $ "AzDvsToPkr:MohaveWaterConsDist.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.MohaveWaterConsDist" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.MohaveWaterConsDist" [date], date )
   ENDIF;

            $ "AzDvsToPkr:AzPumpersDvsToPkr.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.AzPumpersDvsToPkr" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.AzPumpersDvsToPkr" [date], date )
   ENDIF;

            $ "PumpingFromLakeMead:LMNRA Az Mead.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.LMNRA Az Mead" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.LMNRA Az Mead" [date], date )
   ENDIF;

            $ "PumpingFromLakeMead:LMNRA Az Mead.Depletion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.LMNRA Az Mead" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.LMNRA Az Mead" [date], date )
   ENDIF;

            $ "OthersMeadToMohave:LMNRA Az Mohave.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
   THEN
      "VolumeToFlow"( $ "Arizona_CU_Actual.LMNRA Az Mohave" [date], date )
   ELSE
      "VolumeToFlow"( $ "Arizona_CU_Schedules.LMNRA Az Mohave" [date], date )
   ENDIF;

      ENDFOREACH;

    END;

    RULE                 "Set LC Actuals";
    DESCRIPTION          "This rule sets the historical flows for California MWD and Nevada SNWP for January of the start year to the month before the start timestep. <br>This rule fires on the start timestep of the first runcycle. -CE 9/17/13";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      FOREACH (DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"Start Timestep - 1") DO
            $ "California_CU_Actual.MWD" [date] := IF ( IsNaN $ "California_CU_Actual.MWD" [date] AND NOT IsNaN $ "California_CU_Actual.MWDDiversion" [date] )
   THEN
      $ "California_CU_Actual.MWDDiversion" [date] - $ "California_CU_Actual.MWDReturns" [date]
   ENDIF;

            $ "Nevada_CU_Actual.SNWP" [date] := $ "Nevada_CU_Actual.SNWADiversion" [date] + $ "Nevada_CU_Actual.BasicManagement" [date] + $ "Nevada_CU_Actual.LMNRA Mead" [date] + $ "Nevada_CU_Actual.BoulderCanyonProject" [date] + $ "Nevada_CU_Actual.NvDeptFishGame" [date] + $ "Nevada_CU_Actual.PacificCoastBuilding" [date] + $ "Nevada_CU_Actual.City of Henderson" [date] - $ "Nevada_CU_Actual.LVWashReturns" [date];

      ENDFOREACH;

    END;

    RULE                 "Set Actuals to Zero In Future";
    DESCRIPTION          "This rule sets the actual water use to zero over the run period for the each user in the lower basin. <br>This rule fires at the start timestep of the first runcycle. -CE 9/17/13";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      FOREACH (DATETIME date IN @"Start Timestep" TO @"Finish Timestep") DO
            $ "AnnualWaterUse.AzNoCAPTotalMonthlyActual" [date] := 0.00000000 "acre-ft";

            $ "AnnualWaterUse.CaNoPVYPIIDTotalMonthlyActual" [date] := 0.00000000 "acre-ft";

            $ "AnnualWaterUse.NvTotalMonthlyActual" [date] := 0.00000000 "acre-ft";

            $ "AnnualWaterUse.P123bTotalMonthlyActual" [date] := 0.00000000 "acre-ft";

            FOREACH (STRING state IN { "California" , "Arizona" , "Nevada" }) DO
            FOREACH (STRING user IN "SlotToString"( "GetObject"( state CONCAT "_CU_Actual" ) )) DO
            "GetObject"( state CONCAT "_CU_Actual" ) & user [date] := 0.00000000 "acre-ft";

      ENDFOREACH;

      ENDFOREACH;

      ENDFOREACH;

    END;

    RULE                 "Set NaN Actuals To Schedule";
    DESCRIPTION          "This rule sets the annual consumptive use schedules for California, Arizona, Nevada and Mexico for the period from January of the start year to the month before the start timestep.<br>This rule fires only on the start timestep of the first run cycle. - CE 9/17/13";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      FOREACH (DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"Start Timestep - 1") DO
            FOREACH (STRING state IN { "California" , "Arizona" , "Nevada" , "Mexico" }) DO
            FOREACH (STRING user IN "SlotToString"( "GetObject"( state CONCAT "_CU_Actual" ) )) DO
            "GetObject"( state CONCAT "_CU_Actual" ) & user [date] := IF ( user != "SNWP" )
   THEN
      IF ( IsNaN "GetObject"( state CONCAT "_CU_Actual" ) & user [date] )
      THEN
         "GetObject"( state CONCAT "_CU_Schedules" ) & user [date]
      ENDIF
   ENDIF;

      ENDFOREACH;

      ENDFOREACH;

      ENDFOREACH;

    END;

    RULE                 "Set LC Annual Schedules";
    DESCRIPTION          "This rule calculates the annual consumptive use (CU) schedules for Nevada and California.<br>This rule fires for all run cycles. -CE 9/17/13";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 1.00000000;
    BEGIN

      $ "Nevada_CU_AnnualApproval.SNWP" [@"24:00:00 December 31, Current Year"] := "AnnualVolumeSlot"( $ "Nevada_CU_Schedules.SNWP" );

      $ "California_CU_AnnualApproval.MWDReturns" [@"24:00:00 December 31, Current Year"] := "AnnualVolumeSlot"( $ "California_CU_Schedules.MWDReturns" );

      $ "California_CU_AnnualApproval.MWD" [@"24:00:00 December 31, Current Year"] := "AnnualVolumeSlot"( $ "California_CU_Schedules.MWD" );

    END;

    RULE                 "Set LC Monthly Schedules";
    DESCRIPTION          "This rule sets the consumptive use schedules for Nevada and California. -CE 9/17/13";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) >= 1.00000000;
    BEGIN

      FOREACH (DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO "Dec31ofYear"( @"Finish Timestep" ) COMMENTED_BY "This is for testing purposes, this should be Finish timestep<br>when the model is actually moved forward and all input<br>is taken care of") DO
            $ "Nevada_CU_Schedules.SNWP" [date] := $ "Nevada_CU_Schedules.SNWADiversion" [date] + $ "Nevada_CU_Schedules.BasicManagement" [date] + $ "Nevada_CU_Schedules.LMNRA Mead" [date] + $ "Nevada_CU_Schedules.BoulderCanyonProject" [date] + $ "Nevada_CU_Schedules.NvDeptFishGame" [date] + $ "Nevada_CU_Schedules.PacificCoastBuilding" [date] + $ "Nevada_CU_Schedules.City of Henderson" [date] - $ "Nevada_CU_Schedules.LVWashReturns" [date];

            $ "California_CU_Schedules.MWDReturns" [date] := 8.50000000 "acre-feet" * ( "GetDaysInMonth"( date ) / 1.00000000 "day" );

            $ "California_CU_Schedules.MWD" [date] := $ "California_CU_Schedules.MWDDiversion" [date] - 8.50000000 "acre-feet" * ( "GetDaysInMonth"( date ) / 1.00000000 "day" );

      ENDFOREACH;

    END;

    RULE                 "Set Below Imp Outflow";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT IsNaN $ "FloodControlOutput.Flood Control Flag" [] AND "GetRunCycleIndex"(  ) >= 2.00000000;
    BEGIN

      FOREACH (DATETIME index IN @"t" TO @"Finish Timestep") DO
            $ "BelowImperialDam.Outflow" [index] := 0.00000000 "acre-ft/month";

      ENDFOREACH;

    END;

  END;

  POLICY_GROUP   "Data Setup";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  BEGIN

    RULE                 "Compute Upper Basin Gains";
    DESCRIPTION          "This rule calculates the local gains for each reservoir and local inflow in the upper basin from the relevent RFC forecasts. - CE 9/17/13";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    BEGIN

      FOREACH (DATETIME index IN @"Start Timestep" TO @"Finish Timestep") DO
            $ "ColoradoAbovePowell:InterveningAbovePowell.Local Inflow" [index] := $ "PowellInflow.Unregulated" [index] + ( $ "NavajoIndianIrrigationProjectNIIP.Diversion Requested" [index] + $ "Azotea Tunnel.Diversion Requested" [index] + $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" [index] ) - ( ( $ "CrystalInflow.Unregulated" [index] + $ "FlamingGorgeInflow.Unregulated" [index] + $ "NavajoInflow.ModUnregulated" [index] + NaNToZero ( $ "NorthForkRiverInflow.NorthFork_at_Somerset" [index] ) + NaNToZero ( $ "AnimasRiverInflow.Animas_at_Durango" [index] ) ) + NaNToZero ( $ "YampaRiverInflow.Yampa_at_Deerlodge" [index] ) );

            $ "UpperSanJuan.Inflow" [index] := $ "NavajoInflow.ModUnregulated" [index] - $ "Vallecito.Inflow" [index];

            $ "GreenBelowFlamingGorge:YampaRiver.Local Inflow" [index] := NaNToZero ( $ "YampaRiverInflow.Yampa_at_Deerlodge" [index] );

            $ "SanJuanBelowNavajo:AnimasRiver.Local Inflow" [index] := NaNToZero ( $ "AnimasRiverInflow.Animas_at_Durango" [index] );

            $ "GunnisonBelowCrystal:NorthForkGunnisonInflow.Local Inflow" [index] := NaNToZero ( $ "NorthForkRiverInflow.NorthFork_at_Somerset" [index] );

            $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [index] := $ "MorrowPointInflow.Unregulated" [index] - $ "BlueMesaInflow.Unregulated" [index];

            $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [index] := $ "CrystalInflow.Unregulated" [index] - $ "MorrowPointInflow.Unregulated" [index];

            $ "GunnisonAboveBlueMesa:InterveningAboveBlueMesa.Local Inflow" [index] := $ "BlueMesaInflow.Unregulated" [index] - $ "TaylorPark.Inflow" [index];

          DESCRIPTION          "This assignment is necessary for RW 6.6. Per <br>instruction from BoR this value is set to 0 for <br>all timesteps. LJ 03/19/2015.";
      $ "Azotea Tunnel.Fractional Return Flow" [index] := 0.00000000;

      ENDFOREACH;

      FOREACH (DATETIME index IN "OffsetDate"( "RunStartDate"(  ), - 12.00000000, "1 months" ) TO "OffsetDate"( "RunEndDate"(  ), 12.00000000, "1 months" )) DO
            $ "GreenAboveFlamingGorge:InterveningAboveFlamingGorge.Local Inflow" [index] := $ "FlamingGorgeInflow.Unregulated" [index] - $ "Fontenelle.Inflow" [index];

      ENDFOREACH;

      FOREACH (DATETIME index IN "OffsetDate"( "RunStartDate"(  ), - 12.00000000, "1 months" ) TO "OffsetDate"( "RunStartDate"(  ), - 1.00000000, "1 months" )) DO
            $ "GreenAboveFlamingGorge.Outflow" [index] := $ "FlamingGorgeInflow.Unregulated" [index] - $ "Fontenelle.Inflow" [index] + $ "Fontenelle.Outflow" [index];

      ENDFOREACH;

    END;

    RULE                 "INPUT MISSING NOTIFICATION";
    DESCRIPTION          "This rule checks if the necessary RFC inflow information has been entered. This includes inflow information for all upper basin reserviors. -CE 9/17/13";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    BEGIN

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "BlueMesaInflow.Unregulated" [] )
   THEN
      STOP_RUN "Run Stopped, Gain Calculation Failed: BlueMesaInflow.Unregulated Missing"
   ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "TaylorPark.Inflow" [] )
   THEN
      STOP_RUN "Run Stopped, Gain Calculation Failed: TaylorPark.Inflow Missing"
   ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "MorrowPointInflow.Unregulated" [] )
   THEN
      STOP_RUN "Run Stopped, Gain Calculation Failed: MorrowPointInflow.Unregulated Missing"
   ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "CrystalInflow.Unregulated" [] )
   THEN
      STOP_RUN "Run Stopped, Gain Calculation Failed: CrystalInflow.Unregulated Missing"
   ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "FlamingGorgeInflow.Unregulated" [] )
   THEN
      STOP_RUN "Run Stopped, Gain Calculation Failed: FlamingGorgeInflow.Unregulated Missing"
   ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "Fontenelle.Inflow" [] )
   THEN
      STOP_RUN "Run Stopped, Gain Calculation Failed: Fontenelle.Inflow Missing"
   ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "NavajoInflow.ModUnregulated" [] )
   THEN
      STOP_RUN "Run Stopped, Gain Calculation Failed: NavajoInflow.ModUnregulated Missing"
   ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "Vallecito.Inflow" [] )
   THEN
      STOP_RUN "Run Stopped, Gain Calculation Failed: Vallecito.Inflow Missing"
   ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "PowellInflow.Unregulated" [] )
   THEN
      STOP_RUN "Run Stopped, Gain Calculation Failed: PowellInflow.Unregulated Missing"
   ENDIF;

    INACTIVE      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "NavajoIndianIrrigationProjectNIIP.Diversion Requested" [] )
   THEN
      STOP_RUN "Run Stopped, Gain Calculation Failed: NavajoIndianIrrigationProjectNIIP.Diversion Requested Missing"
   ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "Azotea Tunnel.Diversion Requested" [] )
   THEN
      STOP_RUN "Run Stopped, Gain Calculation Failed: AzoteaTunnel.Diversion Requested Missing"
   ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" [] )
   THEN
      STOP_RUN "Run Stopped, Gain Calculation Failed: TunnelDiversionBelowCrystalForAg.Diversion Requested Missing"
   ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "SanJuanBelowNavajo:AnimasRiver.Local Inflow" [] )
   THEN
      STOP_RUN "Run Stopped, Gain Calculation Failed: SanJuanBelowNavajo:AnimasRiver.Local Inflow Missing"
   ENDIF;

    END;

    RULE                 "DebuggingRule";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    BEGIN

      PRINT "AcreFeetPerMonthPrint"( $ "BlueMesaInflow.Unregulated" [] - $ "TaylorPark.Inflow" [] );

    END;

    RULE                 "Set Extended Forecasts to Historic Average Hydrology";
    DESCRIPTION          "This rule set the inflows above Fontenelle, the unregulated inflow to Flaming Gorge, and the Yampa River Inflow for the 12 months beyond the run end date.  These values are needed by the operations rules for Flaming Gorge and Fontenelle as written by CADSWES.  Would be nice to review these rules and see if this is absolutely necessary. - sc 12/1/11";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep";
    BEGIN

      FOREACH (DATETIME index IN @"Start Timestep" TO @"Finish Timestep + 12") DO
            $ "Fontenelle.Inflow" [index] := IF ( IsNaN $ "Fontenelle.Inflow" [index] )
   THEN
      $ "HistoricData.HistoricAverageMonthlyInflows" [index, "FontenelleMonthlyAveInflow"]
   ENDIF;

            $ "YampaRiverInflow.Maybelle" [index] := IF ( IsNaN $ "YampaRiverInflow.Maybelle" [index] )
   THEN
      $ "HistoricData.HistoricAverageMonthlyInflows" [index, "YampaMonthlyAveFlow"]
   ENDIF;

            $ "FlamingGorgeInflow.Unregulated" [index] := IF ( IsNaN $ "FlamingGorgeInflow.Unregulated" [index] )
   THEN
      $ "HistoricData.HistoricAverageMonthlyInflows" [index, "FlamingGorgeMonthlyAveUnregInflow"]
   ENDIF;

      ENDFOREACH;

    END;

    RULE                 "Run Cycle Counter Print Message";
    DESCRIPTION          "This rule records the run cycle in the diagnostic output window for debugging purposes. -CE 9/17/13";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep";
    BEGIN

      PRINT "******************************************************";

      PRINT "Begin Run Cycle # " CONCAT "GetRunCycleIndex"(  );

      PRINT "******************************************************";

    END;

    RULE                 "Set LB Demand Variability Triggers Above Parker";
    DESCRIPTION          "This rule fires in the beginning timestep but sets the trigger values for the whole run.  The rule fires on the beginning timestep.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "ThisRule" );
    BEGIN

      FOREACH (DATETIME date IN "GetDates"( @"Start Timestep", @"Finish Timestep", "1 Months" )) DO
            IF_STATEMENT (date == @"Start Timestep" OR "GetMonth"( date ) == 9.00000000 AND "OffsetDate"( date, 4.00000000, "1 Months" ) <= @"Finish Timestep") THEN
            IF_STATEMENT (date == @"Start Timestep") THEN
            IF_STATEMENT ("GetMonth"( date ) < 10.00000000) THEN
            WITH_STATEMENT (NUMERIC sideInflowAboveHooverVol = "SumFlowsToVolume"( $ "PowellToMead:GainsAboveHoover.Local Inflow", @"24:00:00 January 31, Current Year", "Dec31ofYear"( date ) ) + "SumFlowsToVolume"( $ "PowellToMead:GainsGrandCanyon.Local Inflow", @"24:00:00 January 31, Current Year", "Dec31ofYear"( date ) ) + "SumFlowsToVolume"( $ "PowellToMead:LeesFerryGage.Local Inflow", @"24:00:00 January 31, Current Year", "Dec31ofYear"( date ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowAboveHooverTrigger" ["Dec31ofYear"( date )] := sideInflowAboveHooverVol;

      END_WITH_STATEMENT;

          INACTIVE      WITH_STATEMENT (NUMERIC unregInflowPowell = "SumFlowsToVolume"( $ "PowellInflow.Unregulated", @"24:00:00 October 31, Current Year - 12", "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( 1.00000000 ) ) )) DO
            $ "LowerBasinDemandVariability.PowellUnregulatedInflowTrigger" ["Dec31ofYear"( date )] := unregInflowPowell;

      END_WITH_STATEMENT;

            WITH_STATEMENT (NUMERIC sideInflowAboveHooverVolYr2 = "SumFlowsToVolume"( $ "PowellToMead:GainsAboveHoover.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) ) + "SumFlowsToVolume"( $ "PowellToMead:GainsGrandCanyon.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) ) + "SumFlowsToVolume"( $ "PowellToMead:LeesFerryGage.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowAboveHooverTrigger" ["Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" )] := sideInflowAboveHooverVolYr2;

      END_WITH_STATEMENT;

            WITH_STATEMENT (NUMERIC unregInflowPowellYr2 = "SumFlowsToVolume"( $ "PowellInflow.Unregulated", @"24:00:00 October 31, Current Year", "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( 2.00000000 ) ) )) DO
            $ "LowerBasinDemandVariability.PowellUnregulatedInflowTrigger" ["Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" )] := unregInflowPowellYr2;

      END_WITH_STATEMENT;

      ELSE
            WITH_STATEMENT (NUMERIC sideInflowAboveHooverVol = "SumFlowsToVolume"( $ "PowellToMead:GainsAboveHoover.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) ) + "SumFlowsToVolume"( $ "PowellToMead:GainsGrandCanyon.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) ) + "SumFlowsToVolume"( $ "PowellToMead:LeesFerryGage.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowAboveHooverTrigger" ["Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" )] := sideInflowAboveHooverVol;

      END_WITH_STATEMENT;

            WITH_STATEMENT (NUMERIC unregInflowPowell = "SumFlowsToVolume"( $ "PowellInflow.Unregulated", @"24:00:00 October 31, Current Year", "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( 1.00000000 ) ) )) DO
            $ "LowerBasinDemandVariability.PowellUnregulatedInflowTrigger" ["Dec31ofYear"( "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( 1.00000000 ) ) )] := unregInflowPowell;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      ELSE
            WITH_STATEMENT (NUMERIC sideInflowAboveHooverVol = "SumFlowsToVolume"( $ "PowellToMead:GainsAboveHoover.Local Inflow", "OffsetDate"( "Dec31ofYear"( date ), 1.00000000, "1 Months" ), "OffsetDate"( "Dec31ofYear"( date ), 12.00000000, "1 Months" ) ) + "SumFlowsToVolume"( $ "PowellToMead:GainsGrandCanyon.Local Inflow", "OffsetDate"( "Dec31ofYear"( date ), 1.00000000, "1 Months" ), "OffsetDate"( "Dec31ofYear"( date ), 12.00000000, "1 Months" ) ) + "SumFlowsToVolume"( $ "PowellToMead:LeesFerryGage.Local Inflow", "OffsetDate"( "Dec31ofYear"( date ), 1.00000000, "1 Months" ), "OffsetDate"( "Dec31ofYear"( date ), 12.00000000, "1 Months" ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowAboveHooverTrigger" ["OffsetDate"( "Dec31ofYear"( date ), 12.00000000, "1 Months" )] := sideInflowAboveHooverVol;

      END_WITH_STATEMENT;

            WITH_STATEMENT (NUMERIC waterYearNumber = "GetYear"( date ) - "GetYear"( @"Start Timestep" ) + IF ( "GetMonth"( @"Start Timestep" ) > 9.00000000 )
   THEN
      1.00000000
   ELSE
      2.00000000
   ENDIF) DO
            WITH_STATEMENT (NUMERIC unregInflowPowell = "SumFlowsToVolume"( $ "PowellInflow.Unregulated", "OffsetDate"( "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( waterYearNumber ) ), - 11.00000000, "1 Months" ), "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( waterYearNumber ) ) )) DO
            $ "LowerBasinDemandVariability.PowellUnregulatedInflowTrigger" ["Dec31ofYear"( "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( waterYearNumber ) ) )] := unregInflowPowell;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ENDFOREACH;

    END;

    RULE                 "Set LB Demand Variability Triggers Below Parker";
    DESCRIPTION          "This rule fires in the beginning timestep but sets the trigger values for the whole run.  The rule fires on the beginning timestep.";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "ThisRule" );
    BEGIN

      FOREACH (DATETIME date IN "GetDates"( @"Start Timestep", @"Finish Timestep", "1 Months" )) DO
            IF_STATEMENT (date == @"Start Timestep" OR "GetMonth"( date ) == 9.00000000 AND "OffsetDate"( date, 4.00000000, "1 Months" ) <= @"Finish Timestep") THEN
            IF_STATEMENT (date == @"Start Timestep") THEN
            IF_STATEMENT ("GetMonth"( date ) < 10.00000000) THEN
            WITH_STATEMENT (NUMERIC sideInflowBelowParkerVol = "SumFlowsToVolume"( $ "LowerBasinDemandVariability.Trace_GainsImpToNIBLocalInflow", @"24:00:00 January 31, Current Year", "Dec31ofYear"( date ) ) + "SumFlowsToVolume"( $ "LowerBasinDemandVariability.Trace_GainsPkrToImpLocalInflow", @"24:00:00 January 31, Current Year", "Dec31ofYear"( date ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["Dec31ofYear"( date )] := sideInflowBelowParkerVol;

      END_WITH_STATEMENT;

            WITH_STATEMENT (NUMERIC sideInflowBelowParkerVolYr2 = "SumFlowsToVolume"( $ "LowerBasinDemandVariability.Trace_GainsImpToNIBLocalInflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) ) + "SumFlowsToVolume"( $ "LowerBasinDemandVariability.Trace_GainsPkrToImpLocalInflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" )] := sideInflowBelowParkerVolYr2;

      END_WITH_STATEMENT;

      ELSE
            WITH_STATEMENT (NUMERIC sideInflowBelowParkerVol = "SumFlowsToVolume"( $ "LowerBasinDemandVariability.Trace_GainsImpToNIBLocalInflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) ) + "SumFlowsToVolume"( $ "LowerBasinDemandVariability.Trace_GainsPkrToImpLocalInflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" )] := sideInflowBelowParkerVol;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      ELSE
            WITH_STATEMENT (NUMERIC sideInflowBelowParkerVol = "SumFlowsToVolume"( $ "LowerBasinDemandVariability.Trace_GainsImpToNIBLocalInflow", "OffsetDate"( "Dec31ofYear"( date ), 1.00000000, "1 Months" ), "OffsetDate"( "Dec31ofYear"( date ), 12.00000000, "1 Months" ) ) + "SumFlowsToVolume"( $ "LowerBasinDemandVariability.Trace_GainsPkrToImpLocalInflow", "OffsetDate"( "Dec31ofYear"( date ), 1.00000000, "1 Months" ), "OffsetDate"( "Dec31ofYear"( date ), 12.00000000, "1 Months" ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["OffsetDate"( "Dec31ofYear"( date ), 12.00000000, "1 Months" )] := sideInflowBelowParkerVol;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ENDFOREACH;

    END;

  END;

  UTILITY_GROUP "Powell Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  BEGIN

    FUNCTION       "B1_Branch_UpperBalancingTeirVolume" ( DATETIME eowyDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      IF ( $ "Mead.Pool Elevation" [eowyDate] <= 1075.00000000 "ft" AND $ "Powell.Pool Elevation" [eowyDate] > 3575.00000000 "ft" )
   THEN
      "EnsureReleaseLimits"( "EqualizationRelease"( eowyDate ), 8230.00000000 "1000 acre-ft", 9000.00000000 "1000 acre-ft" )
   ELSE
      8230.00000000 "1000 acre-ft"
   ENDIF COMMENTED_BY "If Mead's EOWY elevation is less than 1075' and Powell's EOWY elevation is greater than 3575' then release enough to balance <br>the storages up to 9.0 MAF and no less than 8.23 MAF annual release volume.  Otherwise just release 8.23 MAF.";

    END;

    FUNCTION       "B2_Branch_UpperBalancingTeirVolume" ( DATETIME eowyDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      "EnsureReleaseLimits"( "EqualizationRelease"( eowyDate ), 7000.00000000 "1000 acre-ft", 9000.00000000 "1000 acre-ft" );

    END;

    FUNCTION       "CalcPrelimReleaseAmt_PreventModelCrash" ( LIST waterYearDates )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "this function calculates a minimum annual volume needed to be released from Powell in order to keep the reservoir from overfilling and crashing the run during the preliminary annual volume setting phase.  The preliminary volume will be 8.23 MAF in most cases, but if the inflows are high or the starting storage in Powell is high and 8.23 MAF is not enough to keep Powell from overfilling, then this function calculates the annual volume needing to be released in order to just prevent overfilling and crashing the model (does not currently include terms for evap and bankstorage).  An exact annual release volume will be calculated in subsequent rules. - sc 03/25/11";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    MIN_CONSTRAINT 0.00000000 "acre-ft";
    BEGIN

      WITH DATETIME firstTimestep = GET @INDEX 0.00000000 FROM waterYearDates DO
      WITH DATETIME lastTimestep = IF ( ( LENGTH waterYearDates ) >= 3.00000000 )
      THEN
         GET @INDEX ( LENGTH waterYearDates ) - 3.00000000 FROM waterYearDates
      ELSE
         GET @INDEX ( LENGTH waterYearDates ) - 1.00000000 FROM waterYearDates
      ENDIF DO
         ( $ "Powell.Storage" ["OffsetDate"( firstTimestep, - 1.00000000, " 1 months" )] + "SumFlowsToVolume"( $ "Powell.Inflow", firstTimestep, lastTimestep ) - "ElevationToStorage"( % "Powell", 3711.00000000 "feet" ) ) / ( ( ( lastTimestep - firstTimestep ) + 1.00000000 "month" ) * 0.60000000 )
      ENDWITH
   ENDWITH * 1.00000000 "year";

    END;

    FUNCTION       "CurrentAnnualVolume" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "This function takes a datetime and returns the annual release volume for Powell for the water year in which the passed-in date lies. - sc 02/15/11";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( date ) )];

    END;

    FUNCTION       "EqualizationRelease" ( DATETIME EOWYDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] + ( $ "Powell.Storage" [EOWYDate] - $ "Mead.Storage" [EOWYDate] ) / 2.00000000;

    END;

    FUNCTION       "LowerTierEqualizationRelease" ( DATETIME EOWYDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] + ( $ "Powell.Storage" [EOWYDate] - $ "Mead.Storage" [EOWYDate] ) / 2.00000000;

    END;

    FUNCTION       "EqualizationTeirCalculationForRelease_Orig" ( DATETIME EOWYDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH NUMERIC PowellVolumeOverEqLevel = "Max"( $ "Powell.Storage" [EOWYDate] - "ElevationToStorage"( % "Powell", "EqLevel"( EOWYDate ) ), 0.00000000 "acre-ft" ) DO
      WITH NUMERIC equalizationReleaseVolume = "EqualizationRelease"( EOWYDate ) DO
         WITH NUMERIC preliminaryReleaseVolume = "Min"( PowellVolumeOverEqLevel + $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )], equalizationReleaseVolume ) DO
            WITH NUMERIC meadElevationWithPrelimRelease = IF ( $ "Mead.Storage" [EOWYDate] + ( preliminaryReleaseVolume - $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] ) >= "ElevationToStorage"( % "Mead", 1229.00000000 "feet" ) )
            THEN
               1229.00000000 "feet"
            ELSE
               "StorageToElevation"( % "Mead", $ "Mead.Storage" [EOWYDate] + ( preliminaryReleaseVolume - $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] ) )
            ENDIF DO
               IF ( meadElevationWithPrelimRelease < 1105.00000000 "ft" )
               THEN
                  WITH NUMERIC totalVolumeToRaiseMeadTo1105 = "Max"( "ElevationToStorage"( % "Mead", 1105.00000000 "ft" ) - $ "Mead.Storage" [EOWYDate], 0.00000000 "acre-ft" ) DO
                     WITH NUMERIC PowellVolumeOverEqLevelLess20ft = "Max"( $ "Powell.Storage" [EOWYDate] - "ElevationToStorage"( % "Powell", "EqLevel"( EOWYDate ) - 20.00000000 "ft" ), 0.00000000 "acre-ft" ) DO
                        ( "MinItem"( { equalizationReleaseVolume , totalVolumeToRaiseMeadTo1105 , PowellVolumeOverEqLevelLess20ft } ) + 8230.00000000 "1000 acre-feet" ) COMMENTED_BY "Choose the minimum of the equalization release, the release to take Mead to 1105 and the release to take Powell down to the equalization level less 20'"
                     ENDWITH COMMENTED_BY "Volume of Powell storage above the equalization level minus 20 feet"
                  ENDWITH COMMENTED_BY "Volume needed to release from Powell to raise Mead elevation to 1105'"
               ELSE
                  preliminaryReleaseVolume
               ENDIF COMMENTED_BY "Check if the preliminary release volume takes Mead above 1105'.  If so the preliminary volume is chosen, if not continue."
            ENDWITH COMMENTED_BY "EOWY Elevation of Mead with the preliminaryReleaseVolume release from Powell"
         ENDWITH COMMENTED_BY "Preliminary annual volume release before the Mead elevation check."
      ENDWITH COMMENTED_BY "Total volume that would need to be released to equalize storage"
   ENDWITH COMMENTED_BY "Total Volume in Powell above the Current Equalization Level";

    END;

    FUNCTION       "EqualizationTeirCalculationForRelease" ( DATETIME EOWYDate )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH NUMERIC PowellVolumeOverEqLevel = "Max"( $ "Powell.Storage" [EOWYDate] - "ElevationToStorage"( % "Powell", "EqLevel"( EOWYDate ) ), 0.00000000 "acre-ft" ) DO
      WITH NUMERIC equalizationReleaseVolume = "EqualizationRelease"( EOWYDate ) DO
         WITH NUMERIC preliminaryReleaseVolume = "Min"( PowellVolumeOverEqLevel + $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )], equalizationReleaseVolume ) DO
            WITH NUMERIC meadElevationWithPrelimRelease = IF ( $ "Mead.Storage" [EOWYDate] + ( preliminaryReleaseVolume - $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] ) >= "ElevationToStorage"( % "Mead", 1229.00000000 "feet" ) )
            THEN
               1229.00000000 "feet"
            ELSE
               "StorageToElevation"( % "Mead", $ "Mead.Storage" [EOWYDate] + ( preliminaryReleaseVolume - $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] ) )
            ENDIF DO
               IF ( meadElevationWithPrelimRelease < 1105.00000000 "ft" )
               THEN
                  WITH NUMERIC totalVolumeToRaiseMeadTo1105 = "Max"( "ElevationToStorage"( % "Mead", 1105.00000000 "ft" ) - $ "Mead.Storage" [EOWYDate], 0.00000000 "acre-ft" ) DO
                     WITH NUMERIC PowellVolumeOverEqLevelLess20ft = "Max"( $ "Powell.Storage" [EOWYDate] - "ElevationToStorage"( % "Powell", "EqLevel"( EOWYDate ) - 20.00000000 "ft" ), 0.00000000 "acre-ft" ) DO
                        IF ( equalizationReleaseVolume < totalVolumeToRaiseMeadTo1105 AND equalizationReleaseVolume < PowellVolumeOverEqLevelLess20ft )
                        THEN
                           { equalizationReleaseVolume + $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] , 0.30000000 }
                        ELSE
                           IF ( totalVolumeToRaiseMeadTo1105 < equalizationReleaseVolume AND totalVolumeToRaiseMeadTo1105 < PowellVolumeOverEqLevelLess20ft )
                           THEN
                              { totalVolumeToRaiseMeadTo1105 + $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] , 0.40000000 }
                           ELSE
                              { PowellVolumeOverEqLevelLess20ft + $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] , 0.50000000 }
                           ENDIF
                        ENDIF COMMENTED_BY "Choose the minimum of the equalization release, the release to take Mead to 1105 and the release to take Powell down to the equalization level less 20'"
                     ENDWITH COMMENTED_BY "Volume of Powell storage above the equalization level minus 20 feet"
                  ENDWITH COMMENTED_BY "Volume needed to release from Powell to raise Mead elevation to 1105'"
               ELSE
                  IF ( preliminaryReleaseVolume == PowellVolumeOverEqLevel + $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] )
                  THEN
                     { preliminaryReleaseVolume , 0.10000000 }
                  ELSE
                     { preliminaryReleaseVolume , 0.20000000 }
                  ENDIF
               ENDIF COMMENTED_BY "Check if the preliminary release volume takes Mead above 1105'.  If so the preliminary volume is chosen, if not continue."
            ENDWITH COMMENTED_BY "EOWY Elevation of Mead with the preliminaryReleaseVolume release from Powell"
         ENDWITH COMMENTED_BY "Preliminary annual volume release before the Mead elevation check."
      ENDWITH COMMENTED_BY "Total volume that would need to be released to equalize storage"
   ENDWITH COMMENTED_BY "Total Volume in Powell above the Current Equalization Level";

    END;

    FUNCTION       "FindReleaseUpperBoundColumn" ( NUMERIC release )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This function takes a annual release volume value and returns the column number";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WHILE ( release - $ "PowellData.PowellMonthlyReleaseTable" ["AnnualTotal", result] > 0.01000000 "1000 acre-ft" ) WITH NUMERIC result = 0.00000000 DO
      result + 1.00000000
   ENDWHILE;

    END;

    FUNCTION       "FindReleaseLowerBoundColumn" ( NUMERIC release, NUMERIC upperbound )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This function takes a annual release volume value and returns the column number";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      IF ( $ "PowellData.PowellMonthlyReleaseTable" ["AnnualTotal", upperbound] - release < 0.10000000 "1000 acre-ft" )
   THEN
      upperbound
   ELSE
      upperbound - 1.00000000
   ENDIF;

    END;

    FUNCTION       "GetInterpolatedPowellMonthlyRelease" ( NUMERIC annualVolume, NUMERIC UpperColumnBound, NUMERIC monthsSinceEOWY )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-ft";
    DESCRIPTION    "This function takes an annual volume release value, a value for the release volume on the table that is the first column that has a volume higher than the passed in annual release volume, and an integer row number corresponding to the current month.  The function returns the release value for the passed-in month that is interpolated linearly between the column for the annual volume just below the passed-in value and just above it. - sc 03/25/11";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      "Interpolate"( annualVolume, $ "PowellData.PowellMonthlyReleaseTable" [0.00000000, UpperColumnBound - 1.00000000], $ "PowellData.PowellMonthlyReleaseTable" [0.00000000, UpperColumnBound], $ "PowellData.PowellMonthlyReleaseTable" [monthsSinceEOWY + 1.00000000, UpperColumnBound - 1.00000000], $ "PowellData.PowellMonthlyReleaseTable" [monthsSinceEOWY + 1.00000000, UpperColumnBound] );

    END;

    FUNCTION       "GetMeadPowellElevDiff" ( STRING res, DATETIME eowyDate, STRING elevOrStorage )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This function allows the model to resolve the Powell release by simulating what the elevations would be if the Powell Annual Release was 8.23 MAF so that if there is Lower Demand Variability and the rules that need to refire after that refire, we need to simulate an 8.23 MAF release from Powell. TP 1/28/2015";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WITH NUMERIC powellAnnVol = $ "PowellData.AnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( IF ( @"t" == @"Start Timestep" )
   THEN
      @"t"
   ELSE
      @"t + 2"
   ENDIF ) )] DO
      IF ( res == "Powell" )
      THEN
         IF ( elevOrStorage == "elev" )
         THEN
            IF ( powellAnnVol == 8230000.00000000 "acre-ft" )
            THEN
               $ "Powell.Pool Elevation" [eowyDate]
            ELSE
               "StorageToElevation"( % "Powell", $ "Powell.Storage" [eowyDate] + ( powellAnnVol - 8230000.00000000 "acre-ft" ) )
            ENDIF
         ELSE
            $ "Powell.Storage" [eowyDate] + ( powellAnnVol - 8230000.00000000 "acre-ft" )
         ENDIF
      ELSE
         IF ( elevOrStorage == "elev" )
         THEN
            IF ( powellAnnVol == 8230000.00000000 "acre-ft" )
            THEN
               $ "Mead.Pool Elevation" [eowyDate]
            ELSE
               "StorageToElevation"( % "Mead", $ "Mead.Storage" [eowyDate] - ( powellAnnVol - 8230000.00000000 "acre-ft" ) )
            ENDIF
         ELSE
            $ "Mead.Storage" [eowyDate] - ( powellAnnVol - 8230000.00000000 "acre-ft" )
         ENDIF
      ENDIF
   ENDWITH;

    END;

    FUNCTION       "GetPowellMonthlyRelease_Old" ( NUMERIC annualVolume, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WITH NUMERIC monthsSinceEOWY = "MonthsSinceEOWY"( date ) DO
      WITH NUMERIC UpperColumnBound = "FindReleaseUpperBoundColumn"( annualVolume ) DO
         "GetInterpolatedPowellMonthlyRelease"( annualVolume, UpperColumnBound, monthsSinceEOWY ) / "GetDaysInMonth"( date )
      ENDWITH
   ENDWITH;

    END;

    FUNCTION       "GetPowellMonthlyReleases_old" ( LIST datesToEOWY )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "This function takes a list of dates that go from the current timestep to the end of the Water Year.  It returns a list of two item lists each of the form &lcub;date, release&rcub; for each date in the passed-in list of dates.  It does this by taking the annual volume calculated for the passed in water years dates and then using the table for monthly releases given an annual volume does a linear interpolation on that table to find releases that sum up exactly to the annual volume set for Powell.  If the passed in set of dates is the first water year in the run, ie starts with the run's start timestep, then this function will make an adjustment to the releases that were calculated by doing the linear interpolation to account for what was released int he months that are in the current water year, but occurred before the run start.  The releases must be adjusted because the actual releases from Powell will not match those prescribed in the table and so an adjustment to the actual remaining volume for the current year from the expected remaining volume for the current water year must be made.  The adjustment preserves the proportions of the total annual volume that come from each month in the table, but scales the volume in the remaining months so that the annual volume is met exactly- sc 03/25/11";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH NUMERIC annualVolume = "CurrentAnnualVolume"( GET @INDEX 0.00000000 FROM datesToEOWY ) DO
      WITH LIST unalteredReleasesFromTable = WITH NUMERIC UpperColumnBound = "FindReleaseUpperBoundColumn"( annualVolume ) DO
         FOR ( DATETIME date IN datesToEOWY ) WITH LIST result = {  } DO
            WITH NUMERIC monthsSinceEOWY = "MonthsSinceEOWY"( date ) DO
               APPEND { date , "GetInterpolatedPowellMonthlyRelease"( annualVolume, UpperColumnBound, monthsSinceEOWY ) / "GetDaysInMonth"( date ) } ONTO result
            ENDWITH
         ENDFOR
      ENDWITH DO
         IF ( ( GET @INDEX 0.00000000 FROM datesToEOWY ) == @"Start Timestep" AND ( GET @INDEX 0.00000000 FROM datesToEOWY ) != @"October 31" )
         THEN
            WITH NUMERIC sumAllRemainingReleases = FOR ( LIST monthlyReleaseVol IN unalteredReleasesFromTable ) STAT_SUM
               GET @INDEX 1.00000000 FROM monthlyReleaseVol
            ENDFOR DO
               WITH LIST listOfPercentagesOfTotalVolume = MAPLIST ( LIST monthlyReleaseVol IN unalteredReleasesFromTable ) DO
                  ( GET @INDEX 1.00000000 FROM monthlyReleaseVol ) / sumAllRemainingReleases
               ENDMAPLIST DO
                  WITH NUMERIC totalVolumeReleasedPreRunStart = "SumFlowsToVolume"( $ "Powell.Outflow", "OffsetDate"( GET @INDEX 0.00000000 FROM datesToEOWY, "MonthsSinceEOWY"( GET @INDEX 0.00000000 FROM datesToEOWY ), "-1 months" ), @"Start Timestep - 1" ) DO
                     WITH NUMERIC remainingVolumeToEOWY = annualVolume - totalVolumeReleasedPreRunStart DO
                        FOR ( DATETIME date IN datesToEOWY ) WITH LIST result = {  } DO
                           APPEND { date , "Max"( ( GET @INDEX LENGTH result FROM listOfPercentagesOfTotalVolume ) * remainingVolumeToEOWY, 450000.00000000 "acre-ft" ) / "GetDaysInMonth"( date ) } ONTO result
                        ENDFOR
                     ENDWITH
                  ENDWITH
               ENDWITH
            ENDWITH
         ELSE
            unalteredReleasesFromTable
         ENDIF
      ENDWITH
   ENDWITH;

    END;

    FUNCTION       "GetPowellMonthlyReleases" ( LIST datesToEOWY )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "This function takes a list of dates that go from the current timestep to the end of the Water Year.  It returns a list of two item lists each of the form &lcub;date, release&rcub; for each date in the passed-in list of dates.  It does this by taking the annual volume calculated for the passed in water years dates and then using the table for monthly releases given an annual volume does a linear interpolation on that table to find releases that sum up exactly to the annual volume set for Powell.  If the passed in set of dates is the first water year in the run, ie starts with the run's start timestep, then this function will make an adjustment to the releases that were calculated by doing the linear interpolation to account for what was released int he months that are in the current water year, but occurred before the run start.  The releases must be adjusted because the actual releases from Powell will not match those prescribed in the table and so an adjustment to the actual remaining volume for the current year from the expected remaining volume for the current water year must be made.  The adjustment preserves the proportions of the total annual volume that come from each month in the table, but scales the volume in the remaining months so that the annual volume is met exactly- sc 03/25/11";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH NUMERIC annualVolume = "CurrentAnnualVolume"( GET @INDEX 0.00000000 FROM datesToEOWY ) DO
      WITH NUMERIC UpperColumnBound = "FindReleaseUpperBoundColumn"( annualVolume ) DO
         WITH NUMERIC totalVolReleasedPreRunInit = IF ( "GetMonth"( @"Start Timestep" ) == 10.00000000 OR ( GET @INDEX 0.00000000 FROM datesToEOWY ) != @"Start Timestep" )
         THEN
            0.00000000 "acre-ft"
         ELSE
            "SumFlowsToVolume"( $ "Powell.Outflow", "OffsetDate"( GET @INDEX 0.00000000 FROM datesToEOWY, "MonthsSinceEOWY"( GET @INDEX 0.00000000 FROM datesToEOWY ), "-1 months" ), @"Start Timestep - 1" )
         ENDIF DO
            WITH NUMERIC LowerColumnBound = "FindReleaseLowerBoundColumn"( annualVolume, UpperColumnBound ) DO
               WITH LIST AdjustedMonthlyRel = "CalculatePowellMonthlyRelease"( datesToEOWY, UpperColumnBound, LowerColumnBound, annualVolume - totalVolReleasedPreRunInit ) DO
                  IF ( ( GET @INDEX 0.00000000 FROM datesToEOWY ) == @"Start Timestep" )
                  THEN
                     WITH NUMERIC sumAllRemainingReleases = FOR ( LIST monthlyReleaseVol IN AdjustedMonthlyRel ) STAT_SUM
                        "FlowToVolume"( GET @INDEX 1.00000000 FROM monthlyReleaseVol, GET @INDEX 0.00000000 FROM monthlyReleaseVol )
                     ENDFOR DO
                        WITH NUMERIC totalVolumeReleasedPreRunStart = IF ( "GetMonth"( @"Start Timestep" ) == 10.00000000 )
                        THEN
                           0.00000000 "acre-ft"
                        ELSE
                           "SumFlowsToVolume"( $ "Powell.Outflow", "OffsetDate"( GET @INDEX 0.00000000 FROM datesToEOWY, "MonthsSinceEOWY"( GET @INDEX 0.00000000 FROM datesToEOWY ), "-1 months" ), @"Start Timestep - 1" )
                        ENDIF DO
                           WITH NUMERIC remainingVolumeToEOWY = annualVolume - totalVolumeReleasedPreRunStart DO
                              IF ( remainingVolumeToEOWY == sumAllRemainingReleases )
                              THEN
                                 AdjustedMonthlyRel
                              ELSE
                                 WITH NUMERIC noMonths = LENGTH AdjustedMonthlyRel DO
                                    WITH NUMERIC alreadySetForRemainingMonths = FOR ( LIST alreadyResList IN AdjustedMonthlyRel ) STAT_SUM
                                       ( GET @INDEX 1.00000000 FROM alreadyResList ) * 1.00000000 "month"
                                    ENDFOR DO
                                       WITH NUMERIC volDiff = annualVolume - totalVolumeReleasedPreRunStart - alreadySetForRemainingMonths DO
                                          WITH NUMERIC newAmt = volDiff / noMonths DO
                                             WITH LIST newAdjustedMonthlyRel = FOR ( LIST subRelList IN AdjustedMonthlyRel ) WITH LIST result = { { 0.00000000 , 0.00000000 , volDiff } } DO
                                                WITH NUMERIC index = ( LENGTH result ) - 1.00000000 DO
                                                   WITH NUMERIC diffinVol = ( GET @INDEX 2.00000000 FROM GET @INDEX index FROM result ) - newAmt DO
                                                      APPEND { GET @INDEX 0.00000000 FROM subRelList , "VolumeToFlow"( ( ( GET @INDEX 1.00000000 FROM subRelList ) + newAmt ), GET @INDEX 0.00000000 FROM subRelList ) , diffinVol } ONTO result
                                                   ENDWITH
                                                ENDWITH
                                             ENDFOR DO
                                                REMOVE ITEM @INDEX 0.00000000 FROM newAdjustedMonthlyRel
                                             ENDWITH
                                          ENDWITH
                                       ENDWITH
                                    ENDWITH
                                 ENDWITH
                              ENDIF
                           ENDWITH
                        ENDWITH
                     ENDWITH
                  ELSE
                     AdjustedMonthlyRel
                  ENDIF
               ENDWITH
            ENDWITH
         ENDWITH
      ENDWITH
   ENDWITH;

    END;

    FUNCTION       "GetPowellReleasesCorrectedForBypass" ( LIST initialDateRelease )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "This Function takes a list in the form of &lcub;Date, Release&rcub; and estimates a pool elevation each month with those releases.  The function creates a series of three item lists in the form &lcub;date, Release, pool elevation&rcub; where if the estimated pool elevation is too low a bypass release is calculated.  the pool elevation that goes into the three item list is the calculated pool elevation from the lesser of the outflow that was passed in or the determined bypass outflow. THis is passed into the rule and the outflow for Powell is set with these values.  tp 7/1/2013<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH LIST initList = GET @INDEX 0.00000000 FROM initialDateRelease DO
      WITH DATETIME initDate = "OffsetDate"( GET @INDEX 0.00000000 FROM initList, - 1.00000000, "1 Months" ) DO
         WITH LIST listWithInitDate = FOR ( LIST index IN initialDateRelease ) WITH LIST result = { { initDate , "null" , $ "Powell.Pool Elevation" [initDate] } } DO
            WITH LIST prevResultList = GET @INDEX ( LENGTH result ) - 1.00000000 FROM result DO
               WITH NUMERIC prevResultPE = GET @INDEX 2.00000000 FROM prevResultList DO
                  WITH DATETIME prevDate = GET @INDEX 0.00000000 FROM prevResultList DO
                     WITH DATETIME curDate = "OffsetDate"( prevDate, 1.00000000, "1 Months" ) DO
                        WITH LIST curEstReleaseList = GET @INDEX ( LENGTH result ) - 1.00000000 FROM initialDateRelease DO
                           WITH NUMERIC curEstRelease = GET @INDEX 1.00000000 FROM curEstReleaseList DO
                              WITH NUMERIC maxBypassRelease = IF ( prevResultPE <= 3500.00000000 "ft" )
                              THEN
                                 "TableInterpolation"( $ "PowellMinObjRelData.Bypass Tube Capacity", 0.00000000, 1.00000000, prevResultPE, curDate )
                              ELSE
                                 curEstRelease
                              ENDIF DO
                                 WITH NUMERIC nextOutflow = "Min"( curEstRelease, maxBypassRelease ) DO
                                    WITH NUMERIC newPE = "StorageToElevation"( % "Powell", "ElevationToStorage"( % "Powell", prevResultPE ) + "FlowToVolume"( $ "Powell.Inflow" [curDate], curDate ) - "EstimateEvaporation"( % "Powell", "ElevationToStorage"( % "Powell", prevResultPE ), "ElevationToStorage"( % "Powell", prevResultPE ), prevDate, curDate ) - "FlowToVolume"( nextOutflow, curDate ) ) DO
                                       APPEND { curDate , nextOutflow , newPE } ONTO result
                                    ENDWITH
                                 ENDWITH
                              ENDWITH
                           ENDWITH
                        ENDWITH
                     ENDWITH
                  ENDWITH
               ENDWITH
            ENDWITH
         ENDFOR DO
            REMOVE ITEM @INDEX 0.00000000 FROM listWithInitDate
         ENDWITH
      ENDWITH
   ENDWITH;

    END;

    FUNCTION       "CalculatePowellMonthlyRelease" ( LIST datesToEOWY, NUMERIC UpperColumn, NUMERIC LowerColumn, NUMERIC AnnVol )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "This function takes a list of dates that go from the current timestep to the end of the Water Year.  It returns a list of two item lists each of the form &lcub;date, release&rcub; for each date in the passed-in list of dates.  It does this by taking the annual volume calculated for the passed in water years dates and then using the table for monthly releases given an annual volume does a linear interpolation on that table to find releases that sum up exactly to the annual volume set for Powell.  If the passed in set of dates is the first water year in the run, ie starts with the run's start timestep, then this function will make an adjustment to the releases that were calculated by doing the linear interpolation to account for what was released int he months that are in the current water year, but occurred before the run start.  The releases must be adjusted because the actual releases from Powell will not match those prescribed in the table and so an adjustment to the actual remaining volume for the current year from the expected remaining volume for the current water year must be made.  The adjustment preserves the proportions of the total annual volume that come from each month in the table, but scales the volume in the remaining months so that the annual volume is met exactly- sc 03/25/11";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH LIST UpperBoundList = FOR ( DATETIME date IN datesToEOWY ) WITH LIST result = {  } DO
      WITH NUMERIC monthsSinceEOWY = "MonthsSinceEOWY"( date ) DO
         APPEND $ "PowellData.PowellMonthlyReleaseTable" [monthsSinceEOWY + 1.00000000, UpperColumn] ONTO result
      ENDWITH
   ENDFOR DO
      WITH LIST LowerBoundList = FOR ( DATETIME date IN datesToEOWY ) WITH LIST result = {  } DO
         WITH NUMERIC monthsSinceEOWY = "MonthsSinceEOWY"( date ) DO
            APPEND $ "PowellData.PowellMonthlyReleaseTable" [monthsSinceEOWY + 1.00000000, LowerColumn] ONTO result
         ENDWITH
      ENDFOR DO
         WITH NUMERIC DiffInVolsBetweenColumns = AnnVol - "Sum"( LowerBoundList ) DO
            WITH LIST differenceList = FOR ( NUMERIC index IN UpperBoundList ) WITH LIST result = {  } DO
               WITH NUMERIC diff = ( GET @INDEX LENGTH result FROM UpperBoundList ) - GET @INDEX LENGTH result FROM LowerBoundList DO
                  APPEND diff ONTO result
               ENDWITH
            ENDFOR DO
               WITH LIST tempList = WHILE ( ( LENGTH result ) < LENGTH differenceList ) WITH LIST result = {  } DO
                  APPEND { { GET @INDEX LENGTH result FROM datesToEOWY , GET @INDEX LENGTH result FROM differenceList , GET @INDEX LENGTH result FROM LowerBoundList } , GET @INDEX LENGTH result FROM differenceList } ONTO result
               ENDWHILE DO
                  WITH LIST sortedList = "SortPairsDescending"( tempList ) DO
                     WITH LIST AlteredReleaseFromTable = FOR ( DATETIME date IN datesToEOWY ) WITH LIST result = { { 0.00000000 , 0.00000000 , DiffInVolsBetweenColumns } } DO
                        WITH NUMERIC index = ( LENGTH result ) - 1.00000000 DO
                           WITH NUMERIC addedRelease = "Min"( GET @INDEX 1.00000000 FROM GET @INDEX index FROM sortedList, GET @INDEX 2.00000000 FROM GET @INDEX index FROM result ) DO
                              WITH NUMERIC diffinVol = ( GET @INDEX 2.00000000 FROM GET @INDEX index FROM result ) - addedRelease DO
                                 APPEND { GET @INDEX 0.00000000 FROM GET @INDEX index FROM sortedList , "VolumeToFlow"( ( addedRelease + GET @INDEX 2.00000000 FROM GET @INDEX index FROM sortedList ), GET @INDEX 0.00000000 FROM GET @INDEX index FROM sortedList ) , diffinVol } ONTO result
                              ENDWITH
                           ENDWITH
                        ENDWITH
                     ENDFOR DO
                        WITH LIST AdjMonthlyReleases = REMOVE ITEM @INDEX 0.00000000 FROM AlteredReleaseFromTable DO
                           AdjMonthlyReleases
                        ENDWITH
                     ENDWITH
                  ENDWITH
               ENDWITH
            ENDWITH
         ENDWITH
      ENDWITH
   ENDWITH;

    END;

    FUNCTION       "MonthDayRatio" ( NUMERIC days )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      ( 31.00000000 "day" / days );

    END;

    FUNCTION       "MonthsSinceEOWY" ( DATETIME time )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      $ "PowellData.MonthsToFromEOWY" ["GetMonthAsString"( time ), "Since"];

    END;

    FUNCTION       "MonthsUntilEOWY" ( DATETIME time )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      $ "PowellData.MonthsToFromEOWY" ["GetMonthAsString"( time ), "Until"];

    END;

    FUNCTION       "PowellReleaseTier" ( NUMERIC Jan1Elev, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      IF ( Jan1Elev >= "EqLevel"( date ) )
   THEN
      0.00000000 COMMENTED_BY "Equalization"
   ELSE
      IF ( Jan1Elev >= $ "PowellData.TierBreaks" ["UpperMid", 0.00000000] )
      THEN
         1.00000000 COMMENTED_BY "Upper Elevation Balancing"
      ELSE
         IF ( Jan1Elev >= $ "PowellData.TierBreaks" ["MidLower", 0.00000000] )
         THEN
            2.00000000 COMMENTED_BY "Mid-Elevation Release"
         ELSE
            3.00000000 COMMENTED_BY "Lower Elevation Balancing"
         ENDIF
      ENDIF
   ENDIF;

    END;

    FUNCTION       "TierIs" ( STRING tier, DATETIME date, BOOLEAN startYear )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      IF ( startYear AND date <= @"24:00:00 September 30" )
   THEN
      $ "PowellData.ReleaseTier" [@"24:00:00 December 31, Current Year"] == $ "PowellData.TeirNames" [tier, 0.00000000]
   ELSE
      $ "PowellData.ReleaseTier" [@"24:00:00 December 31, Next Year"] == $ "PowellData.TeirNames" [tier, 0.00000000]
   ENDIF;

    END;

    FUNCTION       "UpperElevationBalancingBranchCalculation" ( DATETIME eowyDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "See the &quot;Interim Guidelines Flow Chart&quot; for reference.  This slot shows the branch within the Upper Elevation Balancing Tier that was taken for each year's calculation of Powell annual release volume.  It can take the following values for the following conditions:<br>1.1 - Upper Elev Bal Tier, B1 branch (8.23 MAF release)<br>1.2 - Upper Elev Bal Tier, B2 branch (release between 7 MAF and 9MAF)<br>1.3 - Upper Elev Bal Tier, B3 branch (Equalization Tier Calc)<br>1.4 - Upper Elev Bal Tier, B4 branch (release between 8.23 MAF and 9MAF)<br>999 - Any other Tier<br><br>SC - 06/01/12";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WITH DATETIME meadProjecetionDate = IF ( @"t" <= @"September 30" )
   THEN
      @"24:00:00 December 31, Previous Year"
   ELSE
      @"24:00:00 December 31, Current Year"
   ENDIF DO
      IF ( $ "Powell.Pool Elevation" [eowyDate] > "EqLevel"( eowyDate ) )
      THEN
         1.30000000
      ELSE
         IF ( $ "Mead.Pool Elevation" [meadProjecetionDate] >= 1075.00000000 "ft" )
         THEN
            IF ( $ "Mead.Pool Elevation" [eowyDate] <= 1075.00000000 "ft" AND $ "Powell.Pool Elevation" [eowyDate] > 3575.00000000 "ft" )
            THEN
               1.40000000
            ELSE
               1.10000000
            ENDIF COMMENTED_BY "If Mead's EOWY elevation is less than 1075' and Powell's EOWY elevation is greater than 3575' then release enough to balance <br>the storages up to 9.0 MAF and no less than 8.23 MAF annual release volume.  Otherwise just release 8.23 MAF."
         ELSE
            IF ( "EnsureReleaseLimits"( "EqualizationRelease"( eowyDate ), 7000.00000000 "1000 acre-ft", 9000.00000000 "1000 acre-ft" ) > 8230.00000000 "1000 acre-ft" )
            THEN
               1.29000000
            ELSE
               1.27000000
            ENDIF
         ENDIF
      ENDIF
   ENDWITH;

    END;

    FUNCTION       "VolumeDeviationFromEOWYTarget" ( DATETIME EOWYDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This function calculates the volume deviation of the end-of-water-year storage at Powell and Mead from their appropriate target levels according to the Equalization Tier logic.  The condition that is operative for setting the annual volume in a given year is stored in the PowellData.ControllingEqualizationCondition slot.  See the slot for further description of what the values actually mean.  This deviation volume is then added to the annual release volume to more precisely hit the eowy target.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      IF ( NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWYDate )] ) == 0.10000000 )
   THEN
      $ "Powell.Storage" [EOWYDate] - "ElevationToStorage"( % "Powell", "EqLevel"( EOWYDate ) )
   ELSE
      IF ( NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWYDate )] ) == 0.20000000 OR NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWYDate )] ) == 0.30000000 )
      THEN
         ( $ "Powell.Storage" [EOWYDate] - $ "Mead.Storage" [EOWYDate] ) / 2.00000000
      ELSE
         IF ( NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWYDate )] ) == 0.40000000 )
         THEN
            "ElevationToStorage"( % "Mead", 1105.00000000 "ft" ) - $ "Mead.Storage" [EOWYDate]
         ELSE
            IF ( NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWYDate )] ) == 0.50000000 )
            THEN
               $ "Powell.Storage" [EOWYDate] - "ElevationToStorage"( % "Powell", "EqLevel"( EOWYDate ) - 20.00000000 "ft" )
            ELSE
               0.00000000 "acre-ft"
            ENDIF COMMENTED_BY "Fourth possible condition is that Powell elevation needs to be at 20ft below the equalization level by the end-of-water-year"
         ENDIF COMMENTED_BY "Third possible condition is that Mead needs to be at elevation 1105 ft by the end-of-water-year"
      ENDIF COMMENTED_BY "Second possible condition is that the end-of-water-year storages need to be equal between Powell and Mead."
   ENDIF COMMENTED_BY "First condition is that Powell needs to be to its equalization level by end-of-water-year";

    END;

    FUNCTION       "WaterYearDatesByGroup" ( NUMERIC inputGroupNumber )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH LIST prelimList = FOR ( DATETIME date IN @"Start Timestep + 1" TO @"Finish Timestep" ) WITH LIST result = { { @"Start Timestep" , 1.00000000 } } DO
      WITH NUMERIC groupNumber = GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result DO
         IF ( "GetMonthAsString"( date ) == "October" )
         THEN
            APPEND { date , groupNumber + 1.00000000 } ONTO result
         ELSE
            APPEND { date , groupNumber } ONTO result
         ENDIF
      ENDWITH
   ENDFOR DO
      IF ( ( inputGroupNumber == 7.00000000 AND @"Start Timestep" == @"October 31" ) COMMENTED_BY "If the start month is October then there is no third water year in the run window.  Thus we need this function to be <br>non-empty and return a date that will definitely be outside of the run window. - sc 11/03/11" )
      THEN
         { @"24:00:00 December 31, 1900" }
      ELSE
         FOR ( LIST dateGroupNumber IN prelimList ) WITH LIST result = {  } DO
            IF ( ( GET @INDEX 1.00000000 FROM dateGroupNumber ) == inputGroupNumber )
            THEN
               APPEND GET @INDEX 0.00000000 FROM dateGroupNumber ONTO result
            ELSE
               result
            ENDIF
         ENDFOR
      ENDIF
   ENDWITH;

    END;

    FUNCTION       "CalendarYearDatesByGroup" ( NUMERIC inputGroupNumber )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH LIST prelimList = FOR ( DATETIME date IN @"Start Timestep + 1" TO @"Finish Timestep" ) WITH LIST result = { { @"Start Timestep" , 1.00000000 } } DO
      WITH NUMERIC groupNumber = GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result DO
         IF ( "GetMonthAsString"( date ) == "October" )
         THEN
            APPEND { date , groupNumber + 1.00000000 } ONTO result
         ELSE
            APPEND { date , groupNumber } ONTO result
         ENDIF
      ENDWITH
   ENDFOR DO
      IF ( ( inputGroupNumber == 3.00000000 AND @"Start Timestep" == @"October 31" ) COMMENTED_BY "If the start month is October then there is no third water year in the run window.  Thus we need this function to be <br>non-empty and return a date that will definitely be outside of the run window. - sc 11/03/11" )
      THEN
         { @"24:00:00 December 31, 1900" }
      ELSE
         FOR ( LIST dateGroupNumber IN prelimList ) WITH LIST result = {  } DO
            IF ( ( GET @INDEX 1.00000000 FROM dateGroupNumber ) == inputGroupNumber )
            THEN
               APPEND GET @INDEX 0.00000000 FROM dateGroupNumber ONTO result
            ELSE
               result
            ENDIF
         ENDFOR
      ENDIF
   ENDWITH;

    END;

  END;

  UTILITY_GROUP "Powell Steady Flow Experiment Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  BEGIN

    FUNCTION       "GetSeptemberSteadyFlowRelease" ( NUMERIC AnnualReleaseVolume )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      $ "PowellData.SteadyFlowExperimentRelease" ["SteadyFlowTableRow"( AnnualReleaseVolume ), 1.00000000];

    END;

    FUNCTION       "GetOctoberSteadyFlowRelease" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This function returns the october release volume of the current water year under steady flow experiment conditions. ";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      IF ( "MonthIs"( { "October" , "November" , "December" } ) )
   THEN
      $ "Powell.Outflow" [@"24:00:00 September Max DayOfMonth, Current Year"]
   ELSE
      $ "Powell.Outflow" [@"24:00:00 September Max DayOfMonth, Previous Year"]
   ENDIF;

    END;

    FUNCTION       "GetInitialPowellMonthlyVolumes" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      APPEND "FlowToVolume"( "GetSeptemberSteadyFlowRelease"( $ "PowellData.AnnualReleaseVolume" [] ), @"24:00:00 September Max DayOfMonth, Current Year" ) ONTO INSERT "FlowToVolume"( "GetOctoberSteadyFlowRelease"(  ), @"24:00:00 October Max DayOfMonth, Current Year" ) INTO FOR ( NUMERIC i IN "GetNumbers"( 2.00000000, 11.00000000, 1.00000000 ) ) WITH LIST result = {  } DO
      APPEND "Interpolate"( "CurrentAnnualVolume"( @"t" ), $ "PowellData.PowellMonthlyReleaseTable" [0.00000000, "FindReleaseUpperBoundColumn"( "CurrentAnnualVolume"( @"t" ) )], $ "PowellData.PowellMonthlyReleaseTable" [0.00000000, "FindReleaseUpperBoundColumn"( "CurrentAnnualVolume"( @"t" ) ) + 1.00000000], $ "PowellData.PowellMonthlyReleaseTable" [i, "FindReleaseUpperBoundColumn"( "CurrentAnnualVolume"( @"t" ) )], $ "PowellData.PowellMonthlyReleaseTable" [i, "FindReleaseUpperBoundColumn"( "CurrentAnnualVolume"( @"t" ) ) + 1.00000000] ) ONTO result
   ENDFOR;

    END;

    FUNCTION       "SteadyFlowTableRow" ( NUMERIC AnnualReleaseVolume )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WHILE ( AnnualReleaseVolume >= $ "PowellData.SteadyFlowExperimentRelease" [i, 0.00000000] ) WITH NUMERIC i = 0.00000000 DO
      i + 1.00000000
   ENDWHILE;

    END;

    FUNCTION       "SteadyFlowReduce_1_July" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WITH LIST monthlyRelease = "Reverse"( "GetInitialPowellMonthlyVolumes"(  ) ) DO
      IF ( "Sum"( monthlyRelease ) - $ "PowellData.AnnualReleaseVolume" [] >= 0.00000000 "acre-ft" )
      THEN
         "Min"( "GetElement"( monthlyRelease, 2.00000000 ) - 800.00000000 "1000 acre-ft", "Sum"( monthlyRelease ) - $ "PowellData.AnnualReleaseVolume" [] ) COMMENTED_BY "Return either the amount of reduction in july down to 800 kaf <br>or the total reduction (if it all occurs in July)"
      ELSE
         "Sum"( monthlyRelease ) - $ "PowellData.AnnualReleaseVolume" []
      ENDIF COMMENTED_BY "If the monthly releases exceed the annual release volume, then decrease july first"
   ENDWITH;

    END;

    FUNCTION       "SteadyFlowReduce_2_August" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WITH LIST monthlyRelease = "Reverse"( "GetInitialPowellMonthlyVolumes"(  ) ) DO
      "Min"( "Max"( "GetElement"( monthlyRelease, 1.00000000 ) COMMENTED_BY "1 in reverse order is august" - 800.00000000 "1000 acre-ft", 0.00000000 "acre-ft" ), "Max"( "Sum"( monthlyRelease ) - $ "PowellData.AnnualReleaseVolume" [] - "SteadyFlowReduce_1_July"(  ), 0.00000000 "acre-ft" ) ) COMMENTED_BY "Return either the amount of reduction in August down to 800 kaf <br>or the total reduction (if it all occurs in August)"
   ENDWITH;

    END;

    FUNCTION       "SteadyFlowReduce_3_June1" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WITH LIST monthlyRelease = "Reverse"( "GetInitialPowellMonthlyVolumes"(  ) ) DO
      "Min"( "Max"( "GetElement"( monthlyRelease, 3.00000000 ) - 800.00000000 "1000 acre-ft", 0.00000000 "acre-ft" ), "Max"( "Sum"( monthlyRelease ) - $ "PowellData.AnnualReleaseVolume" [] - "SteadyFlowReduce_1_July"(  ) - "SteadyFlowReduce_2_August"(  ), 0.00000000 "acre-ft" ) ) COMMENTED_BY "Return either the amount of reduction in June down to 800 kaf <br>or the total reduction (if it all occurs in June), In both cases negatives <br>can occur, so zero these out "
   ENDWITH;

    END;

    FUNCTION       "SteadyFlowReduce_4_June2" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WITH LIST monthlyRelease = "Reverse"( "GetInitialPowellMonthlyVolumes"(  ) ) DO
      "Min"( "Max"( "GetElement"( monthlyRelease, 3.00000000 ) COMMENTED_BY "3 in reverse order is june" - 600.00000000 "1000 acre-ft", 0.00000000 "acre-ft" ), "Max"( "Sum"( monthlyRelease ) - $ "PowellData.AnnualReleaseVolume" [] - "SteadyFlowReduce_1_July"(  ) - "SteadyFlowReduce_2_August"(  ) - "SteadyFlowReduce_3_June1"(  ), 0.00000000 "acre-ft" ) ) COMMENTED_BY "Return either the amount of reduction in June down to 600 kaf <br>or the total reduction (if it all occurs in June)"
   ENDWITH;

    END;

    FUNCTION       "SteadyFlowReduce_5_April" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WITH LIST monthlyRelease = "Reverse"( "GetInitialPowellMonthlyVolumes"(  ) ) DO
      "Min"( "Max"( "GetElement"( monthlyRelease, 5.00000000 ) COMMENTED_BY "5 in reverse order is april" - 500.00000000 "1000 acre-ft", 0.00000000 "acre-ft" ), "Max"( "Sum"( monthlyRelease ) - $ "PowellData.AnnualReleaseVolume" [] - "SteadyFlowReduce_1_July"(  ) - "SteadyFlowReduce_2_August"(  ) - "SteadyFlowReduce_3_June1"(  ) - "SteadyFlowReduce_4_June2"(  ), 0.00000000 "acre-ft" ) ) COMMENTED_BY "Return either the amount of reduction in April down to 500 kaf<br>or the total reduction (if it all occurs in June)"
   ENDWITH;

    END;

    FUNCTION       "SteadyFlowReduce_6_May" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WITH LIST monthlyRelease = "Reverse"( "GetInitialPowellMonthlyVolumes"(  ) ) DO
      "Min"( "Max"( "GetElement"( monthlyRelease, 4.00000000 ) COMMENTED_BY "4 in reverse order is may" - 500.00000000 "1000 acre-ft", 0.00000000 "acre-ft" ), "Max"( "Sum"( monthlyRelease ) - $ "PowellData.AnnualReleaseVolume" [] - "SteadyFlowReduce_1_July"(  ) - "SteadyFlowReduce_2_August"(  ) - "SteadyFlowReduce_3_June1"(  ) - "SteadyFlowReduce_4_June2"(  ) - "SteadyFlowReduce_5_April"(  ), 0.00000000 "acre-ft" ) ) COMMENTED_BY "Return either the amount of reduction in June down to 600 kaf <br>or the total reduction (if it all occurs in June)"
   ENDWITH;

    END;

    FUNCTION       "DepletionToDiversionRatio" ( STRING depletionSlot, STRING diversionSlot, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      IF ( depletionSlot [date] == 0.00000000 "cms" )
   THEN
      0.00000000
   ELSE
      diversionSlot [date] / depletionSlot [date]
   ENDIF;

    END;

    FUNCTION       "SubbasinShortage" ( STRING subbasin, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      FOR ( OBJECT obj IN "ListSubbasin"( subbasin ) SET_INTERSECTION ( "ListSubbasin"( "AggDiversionSite" ) COMMENTED_BY "Can eliminate after bug 4914 is fixed.  Have to do this now because we are <br>expecting only aggregate diversion sites not individual water users" ) ) WITH NUMERIC totalShortage = 0.00000000 "acre-ft" DO
      FOR ( DATETIME date IN startDate TO endDate ) WITH NUMERIC userShortage = 0.00000000 "acre-ft" DO
         userShortage + ( "FlowToVolume"( % "SanJuanNewMexicoDiversionSchedules" & ( ( STRINGIFY obj ) CONCAT "_" CONCAT "Depletion" ) [date], date ) - "FlowToVolume"( obj & "Total Depletion Requested" [date], date ) ) COMMENTED_BY "Subtract off depletion requested because this slot <br>has already been reduced by the WSA rule"
      ENDFOR + totalShortage
   ENDFOR;

    END;

  END;

  UTILITY_GROUP "NavajoFunctions_New";
  DESCRIPTION   "";
  ACTIVE        FALSE;
  BEGIN

    FUNCTION       "DetermineNavajoEoWYReleaseLevelNew" ( DATETIME date )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "This Function returns the value of the release level for the Navajo Release<br>0 = No Release<br>1 = Release of 114,000 AF<br>2 = Relase greater of 166,000 or SpillAF<br>3 = Release of > 344,000 AF to get the reservoir back to full<br><br><br>The policy is based on the decision Tree used by the Navajo Dam Operator and is within the Flow Recomendations For the San Juan River published by the San Juan River Basin Recovery Implementation Program *1999 ";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH NUMERIC waterRqdForEOWYTPE = "Max"( IF ( @"t" == @"Start Timestep" )
   THEN
      IF ( "GetMonth"( @"t" ) <= 2.00000000 OR "GetMonth"( @"t" ) >= 10.00000000 )
      THEN
         0.00000000 "acre-ft"
      ELSE
         IF ( "GetMonth"( @"t" ) >= 3.00000000 AND "GetMonth"( @"t" ) <= 5.00000000 )
         THEN
            "WaterToAchieveEOYTPE"( @"24:00:00 September 30, Current Year" )
         ELSE
            "WaterToAchieveEOYTPE"( @"24:00:00 September 30, Current Year" )
         ENDIF
      ENDIF
   ELSE
      "WaterToAchieveEOYTPE"( @"24:00:00 September 30, Current Year" ) COMMENTED_BY "If the timestep is not the start timestep, it has to be March"
   ENDIF, 0.00000000 "acre-ft" ) DO
      WITH NUMERIC releaseLevel = FOR ( NUMERIC iter IN "GetNumbers"( 1.00000000, 4.00000000, 1.00000000 ) ) WITH NUMERIC result = 0.00000000 DO
         IF ( waterRqdForEOWYTPE >= $ "NavajoDataNew.SpringPeakReleaseLevels" ["Volume", iter - 1.00000000] )
         THEN
            iter
         ELSE
            result
         ENDIF
      ENDFOR DO
         WITH NUMERIC noseLevel = IF ( releaseLevel == 4.00000000 )
         THEN
            FOR ( NUMERIC iter IN "GetNumbers"( 0.00000000, 10.00000000, 1.00000000 ) ) WITH NUMERIC result = 0.00000000 DO
               IF ( waterRqdForEOWYTPE - $ "NavajoDataNew.SpringPeakReleaseLevels" ["Volume", 3.00000000] >= $ "NavajoDataNew.SpringNoseLevels" ["Volume", iter] )
               THEN
                  iter
               ELSE
                  result
               ENDIF
            ENDFOR
         ELSE
            0.00000000
         ENDIF DO
            WITH NUMERIC noseVolume = IF ( releaseLevel == 4.00000000 )
            THEN
               waterRqdForEOWYTPE - $ "NavajoDataNew.SpringPeakReleaseLevels" ["Volume", 3.00000000]
            ELSE
               0.00000000 "acre-ft"
            ENDIF DO
               WITH NUMERIC excessOfRelease = IF ( releaseLevel == 4.00000000 )
               THEN
                  noseVolume - $ "NavajoDataNew.SpringNoseLevels" ["Volume", noseLevel]
               ELSE
                  IF ( NOT releaseLevel == 0.00000000 )
                  THEN
                     waterRqdForEOWYTPE - $ "NavajoDataNew.SpringPeakReleaseLevels" ["Volume", releaseLevel - 1.00000000]
                  ELSE
                     "WaterToAchieveEOYTPE"( @"24:00:00 September 30, Current Year" )
                  ENDIF
               ENDIF DO
                  { waterRqdForEOWYTPE , releaseLevel , noseLevel , noseVolume , excessOfRelease }
               ENDWITH
            ENDWITH
         ENDWITH
      ENDWITH
   ENDWITH;

    END;

    FUNCTION       "DetermineNavajoMonthlyFlowVolumeNew" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Sums flows for each month using the NavajoData.NavajoOuflowWithScale Slot.  These values will be returned as volume per month in Acre-ft and will become the Navajo.Outflow monthly values. TP 8/7/2012";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      "SumFlowsToVolume"( $ "NavajoDataNew.MarchThruJulyDaily", "OffsetDate"( date, ( "GetDaysInMonth"( date ) / 1.00000000 "day" - 1.00000000 ) * - 1.00000000, "1 days" ), date );

    END;

    FUNCTION       "DailyOutflowsForNavajo" ( DATETIME date, NUMERIC releaseLevel, NUMERIC noseLevel, NUMERIC excessOfRelease )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH NUMERIC peakReleaseVal = $ "NavajoDataNew.SpringPeakReleaseByLevel" [date, releaseLevel] DO
      WITH NUMERIC noseReleaseVal = $ "NavajoDataNew.SpringPeakNoseByLevel" [date, noseLevel] DO
         WITH NUMERIC peakAndNoseVal = peakReleaseVal + noseReleaseVal DO
            WITH LIST baseFlowDate = { 0.00000000 "day" , 6.00000000 "day" , 9.00000000 "day" , 13.00000000 "day" , 25.00000000 "day" } DO
               WITH NUMERIC baseFlowDays = "GetDayOfYear"( @"24:00:00 October 1, Current Year" ) - ( 155.00000000 "day" + GET @INDEX releaseLevel FROM baseFlowDate ) DO
                  WITH NUMERIC baseFlowChange = excessOfRelease / baseFlowDays DO
                     WITH NUMERIC flowVal = IF ( peakAndNoseVal > 0.00000000 "cfs" )
                     THEN
                        peakAndNoseVal
                     ELSE
                        IF ( "GetDayOfYear"( date ) < 155.00000000 "day" OR date > @"24:00:00 September 30, Current Year" )
                        THEN
                           $ "NavajoDataNew.BaseRelease" []
                        ELSE
                           "Max"( "Min"( $ "NavajoDataNew.BaseRelease" [] + baseFlowChange, 1000.00000000 "cfs" ), $ "NavajoDataNew.BaseRelease" [] )
                        ENDIF
                     ENDIF DO
                        flowVal
                     ENDWITH
                  ENDWITH
               ENDWITH
            ENDWITH
         ENDWITH
      ENDWITH
   ENDWITH;

    END;

  END;

  UTILITY_GROUP "Navajo Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  BEGIN

    FUNCTION       "AnticipatedInflowNavajo" ( DATETIME dateToStart, DATETIME dateToProject )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-ft";
    DESCRIPTION    "This function calculates the inflow to Navajo for the entire run period TP 8/07/2012";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      "SumFlowsToVolume"( $ "Navajo.Inflow", dateToStart, dateToProject );

    END;

    FUNCTION       "CalcAprStorforAvalWatNavajo" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      $ "Navajo.Storage" [@"t - 1"] + "AnticipatedInflowNavajo"( @"24:00:00 April 1, Current Year", @"24:00:00 April Max DayOfMonth, Current Year" ) - "SumNavajoBaseRelease"( @"24:00:00 April Max DayOfMonth, Current Year" ) - "FlowToVolume"( "StorageToArea"( % "Navajo", $ "Navajo.Storage" [@"t - 1"] + "AnticipatedInflowNavajo"( @"24:00:00 April 1, Current Year", @"24:00:00 April Max DayOfMonth, Current Year" ) - "SumNavajoBaseRelease"( @"24:00:00 April Max DayOfMonth, Current Year" ) - $ "NavajoData.NIIPAnnualRequest" [@"24:00:00 December 31, Current Year"] * $ "NavajoData.NIIPMonthlyDistribution" [4.00000000] ) * $ "Navajo.Evaporation Coefficients" [3.00000000], @"24:00:00 April 30, Current Year" ) - $ "NavajoData.NIIPAnnualRequest" [@"24:00:00 December 31, Current Year"] * $ "NavajoData.NIIPMonthlyDistribution" [4.00000000];

    END;

    FUNCTION       "CalcFlowAboveBaseForDSDiversions" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WITH NUMERIC AnimasFlow = IF ( IsNaN $ "SanJuanBelowNavajo:AnimasRiver.Local Inflow" ["MaxDayOfMonth"( date )] )
   THEN
      0.00000000 "acre-foot" / 1.00000000 "month"
   ELSE
      $ "SanJuanBelowNavajo:AnimasRiver.Local Inflow" ["MaxDayOfMonth"( date )]
   ENDIF DO
      WITH NUMERIC DSDailyDepletions = IF ( IsNaN $ "SanJuanBelowNavajo.Total Diversion" ["MaxDayOfMonth"( date )] )
      THEN
         0.00000000 "acre-foot" / 1.00000000 "month"
      ELSE
         $ "SanJuanBelowNavajo.Total Diversion" ["MaxDayOfMonth"( date )]
      ENDIF DO
         IF ( @"t" == @"Start Timestep" )
         THEN
            IF ( date > @"24:00:00 June 30, Current Year" )
            THEN
               "Max"( $ "NavajoData.DesiredDownStreamFlow" [] - AnimasFlow + DSDailyDepletions, $ "NavajoData.BaseRelease" [] )
            ELSE
               $ "NavajoData.BaseRelease" []
            ENDIF
         ELSE
            "Max"( $ "NavajoData.DesiredDownStreamFlow" [] - AnimasFlow + DSDailyDepletions, $ "NavajoData.BaseRelease" [] )
         ENDIF
      ENDWITH
   ENDWITH;

    END;

    FUNCTION       "CalcJunStorforAvalWatNavajo" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      $ "Navajo.Storage" [@"t - 1"] + "AnticipatedInflowNavajo"( @"24:00:00 June 1, Current Year", @"24:00:00 June Max DayOfMonth, Current Year" ) - "SumNavajoBaseRelease"( @"24:00:00 June Max DayOfMonth, Current Year" ) - "FlowToVolume"( "StorageToArea"( % "Navajo", $ "Navajo.Storage" [@"t - 1"] + "AnticipatedInflowNavajo"( @"24:00:00 June 1, Current Year", @"24:00:00 June Max DayOfMonth, Current Year" ) - "SumNavajoBaseRelease"( @"24:00:00 June Max DayOfMonth, Current Year" ) - $ "NavajoData.NIIPAnnualRequest" [@"24:00:00 December 31, Current Year"] * $ "NavajoData.NIIPMonthlyDistribution" [6.00000000] ) * $ "Navajo.Evaporation Coefficients" [5.00000000], @"24:00:00 March 31, Current Year" ) - $ "NavajoData.NIIPAnnualRequest" [@"24:00:00 December 31, Current Year"] * $ "NavajoData.NIIPMonthlyDistribution" [5.00000000];

    END;

    FUNCTION       "CalcMarStorforAvalWatNavajo" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      $ "Navajo.Storage" [@"t - 1"] + "AnticipatedInflowNavajo"( @"24:00:00 March 31, Current Year", @"24:00:00 March Max DayOfMonth, Current Year" ) - "SumNavajoBaseRelease"( @"24:00:00 March Max DayOfMonth, Current Year" ) - "FlowToVolume"( "StorageToArea"( % "Navajo", $ "Navajo.Storage" [@"t - 1"] + "AnticipatedInflowNavajo"( @"24:00:00 March 31, Current Year", @"24:00:00 March Max DayOfMonth, Current Year" ) - "SumNavajoBaseRelease"( @"24:00:00 March Max DayOfMonth, Current Year" ) - $ "NavajoData.NIIPAnnualRequest" [@"24:00:00 December 31, Current Year"] * $ "NavajoData.NIIPMonthlyDistribution" [@"24:00:00 March 31, Current Year", 0.00000000] ) * $ "Navajo.Evaporation Coefficients" [2.00000000, 0.00000000], @"24:00:00 March 31, Current Year" ) - $ "NavajoData.NIIPAnnualRequest" [@"24:00:00 December 31, Current Year"] * $ "NavajoData.NIIPMonthlyDistribution" [@"24:00:00 March 31, Current Year", 0.00000000];

    END;

    FUNCTION       "CalcMayStorforAvalWatNavajo" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      $ "Navajo.Storage" [@"t - 1"] + "AnticipatedInflowNavajo"( @"24:00:00 May 1, Current Year", @"24:00:00 May Max DayOfMonth, Current Year" ) - "SumNavajoBaseRelease"( @"24:00:00 May Max DayOfMonth, Current Year" ) - "FlowToVolume"( "StorageToArea"( % "Navajo", $ "Navajo.Storage" [@"t - 1"] + "AnticipatedInflowNavajo"( @"24:00:00 May 1, Current Year", @"24:00:00 May Max DayOfMonth, Current Year" ) - "SumNavajoBaseRelease"( @"24:00:00 May Max DayOfMonth, Current Year" ) - $ "NavajoData.NIIPAnnualRequest" [@"24:00:00 December 31, Current Year"] * $ "NavajoData.NIIPMonthlyDistribution" [5.00000000] ) * $ "Navajo.Evaporation Coefficients" [4.00000000], @"24:00:00 March 31, Current Year" ) - $ "NavajoData.NIIPAnnualRequest" [@"24:00:00 December 31, Current Year"] * $ "NavajoData.NIIPMonthlyDistribution" [5.00000000];

    END;

    FUNCTION       "ComputeWaterReqdForEOYTPE" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This function will take a date and return the Annual release, given the inflows and estimated evaporation that will get Navajo to the End of Year Target Pool Elevation. TP 6/20/2014<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      IF ( date == @"Start Timestep" )
   THEN
      IF ( "GetMonth"( @"t" ) <= 2.00000000 OR "GetMonth"( @"t" ) >= 10.00000000 )
      THEN
         0.00000000 "acre-ft"
      ELSE
         IF ( "GetMonth"( @"t" ) >= 3.00000000 AND "GetMonth"( @"t" ) <= 5.00000000 )
         THEN
            "WaterToAchieveEOYTPE"( @"24:00:00 July 31, Current Year" )
         ELSE
            "WaterToAchieveEOYTPE"( @"24:00:00 September 30, Current Year" )
         ENDIF
      ENDIF
   ELSE
      "WaterToAchieveEOYTPE"( @"24:00:00 July 31, Current Year" ) COMMENTED_BY "If the timestep is not the start timestep, it has to be March"
   ENDIF;

    END;

    FUNCTION       "ComputeWaterReqdForAnnRelease" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This function will take a date and calculates the available storage using the storage above the Desired pool elevation in September carry over storage plus the inflow less the base release for any given year to determine the amount of available water there is for a peak release in the spring.. TP 6/20/2014<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      IF ( date == @"Start Timestep" )
   THEN
      IF ( "GetMonth"( @"t" ) <= 2.00000000 OR "GetMonth"( @"t" ) >= 10.00000000 )
      THEN
         0.00000000 "acre-ft"
      ELSE
         IF ( "GetMonth"( @"t" ) >= 3.00000000 AND "GetMonth"( @"t" ) <= 5.00000000 )
         THEN
            "WaterAvialable"( @"24:00:00 July 31, Current Year" )
         ELSE
            "WaterAvialable"( @"24:00:00 September 30, Current Year" )
         ENDIF
      ENDIF
   ELSE
      "WaterAvialable"( @"24:00:00 July 31, Current Year" ) COMMENTED_BY "If the timestep is not the start timestep, it has to be March"
   ENDIF;

    END;

    FUNCTION       "DaysofRampBeforeAdditionalRelease" ( NUMERIC ExtendFlow, NUMERIC RampUpIncrease, NUMERIC NumberOfDaysatFlowRmpUp )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Determines the amount of ramp up that occurs before the additional flow volume starts.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      "Floor"( ExtendFlow / RampUpIncrease, 1.00000000 ) * NumberOfDaysatFlowRmpUp;

    END;

    FUNCTION       "DetermineLevelRelease" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Cacluates the release for the water year including the release that is calcuated using the level policy matrix. TP May312012";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      IF ( @"t" == @"Start Timestep" )
   THEN
      IF ( "GetMonth"( @"t" ) <= 2.00000000 )
      THEN
         0.00000000 "acre-ft"
      ELSE
         IF ( "GetMonth"( @"t" ) >= 4.00000000 AND "GetMonth"( @"t" ) <= 7.00000000 )
         THEN
            "SumFlowsToVolume"( $ "NavajoData.MarchThruJulyDaily", "OffsetDate"( @"t", ( "GetDaysInMonth"( @"t" ) / 1.00000000 "day" - 1.00000000 ) * - 1.00000000, "1 days" ), @"24:00:00 July 31, Current Year" )
         ELSE
            IF ( "GetMonth"( @"t" ) == 3.00000000 )
            THEN
               "SumFlowsToVolume"( $ "NavajoData.MarchThruJulyDaily", @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year" )
            ELSE
               0.00000000 "acre-ft"
            ENDIF
         ENDIF
      ENDIF
   ELSE
      "SumFlowsToVolume"( $ "NavajoData.MarchThruJulyDaily", @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year" )
   ENDIF;

    END;

    FUNCTION       "DetermineNavajoEoWYReleaseLevel" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This Function returns the value of the release level for the Navajo Release<br>0 = No Release<br>1 = Release of 114,000 AF<br>2 = Relase greater of 166,000 or SpillAF<br>3 = Release of > 344,000 AF to get the reservoir back to full<br><br><br>The policy is based on the decision Tree used by the Navajo Dam Operator and is within the Flow Recomendations For the San Juan River published by the San Juan River Basin Recovery Implementation Program *1999 ";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH NUMERIC RelVol = "ComputeWaterReqdForEOYTPE"( @"t" ) DO
      IF ( ( RelVol < IF ( IsNaN $ "NavajoData.MinimumLevelOneFlowChartLevel" [date] )
      THEN
         114000.00000000 "acre-ft"
      ELSE
         $ "NavajoData.MinimumLevelOneFlowChartLevel" [date]
      ENDIF ) COMMENTED_BY "If the total available water is less than 114,000 AF then no release is required" )
      THEN
         "DetermineNavajoReleaseLevel"( "Dec31ofYear"( @"t" ) )
      ELSE
         IF ( ( RelVol + $ "Navajo.Storage" [@"t - 1"] - "ElevationToStorage"( % "Navajo", $ "NavajoData.MaxPE" [] ) > 0.00000000 "acre-ft" ) COMMENTED_BY "If a Spill is Probable" )
         THEN
            IF ( ( RelVol + $ "Navajo.Storage" [@"t - 1"] - "ElevationToStorage"( % "Navajo", $ "NavajoData.MaxPE" [] ) >= 344000.00000000 "acre-ft" ) COMMENTED_BY "If the total spill is greater than 344,000 AF then Release the full Spring Release" )
            THEN
               3.00000000 COMMENTED_BY "Release the full hydrograph to account for the large amount of spill that would occur"
            ELSE
               IF ( "Releaseof356KLast3Years"(  ) COMMENTED_BY "If a release in the last three years was equal to or greater than 344,000 AF, then don't release the full release but continue on " )
               THEN
                  IF ( "Releaseof166KLastYear"(  ) COMMENTED_BY "If there was a release of 166,000 last year" )
                  THEN
                     IF ( ( $ "NavajoData.Puturbation" ["Dec31ofYear"( @"t" )] == 1.00000000 ) COMMENTED_BY "If the year has perturbation (See the Navajodata.Perturbation Slot for details)" )
                     THEN
                        2.00000000 COMMENTED_BY "Release which is the greater, 116,000 AF or the Spill to keep the reservoir full"
                     ELSE
                        1.00000000 COMMENTED_BY "Release greater than 114,000 AF that will account for all of the spill but keep the reservoir full"
                     ENDIF
                  ELSE
                     2.00000000 COMMENTED_BY "if the release last year was not greater than 166,000 AF"
                  ENDIF
               ELSE
                  3.00000000 COMMENTED_BY "Release Full Hydrograph Path 7"
               ENDIF
            ENDIF
         ELSE
            IF ( ( $ "NavajoData.Puturbation" ["Dec31ofYear"( @"t" )] == 1.00000000 ) COMMENTED_BY "If the year has perturbation (See the Navajodata.Perturbation Slot for details)" )
            THEN
               1.00000000 COMMENTED_BY "Release of 114,000 Path 2"
            ELSE
               IF ( "Releaseof356KLast3Years"(  ) COMMENTED_BY "If there was a release greater than 344,000 AF in one of the last three years" )
               THEN
                  IF ( "ReleaseLastYear"(  ) COMMENTED_BY "If there was any release in the last two years then" )
                  THEN
                     0.00000000 COMMENTED_BY "No Release Path 5<br>"
                  ELSE
                     1.00000000 COMMENTED_BY "Release of 114,000 Path 14"
                  ENDIF
               ELSE
                  IF ( "Releaseof166KLastYear"(  ) COMMENTED_BY "If there was a release greater than 166,000 AF last year" )
                  THEN
                     0.00000000 COMMENTED_BY "No Release, Path 4"
                  ELSE
                     1.00000000 COMMENTED_BY "Release of 114,000 AF, Path 3<br>"
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDIF
   ENDWITH;

    END;

    FUNCTION       "DetermineNavajoMonthlyFlowVolume" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Sums flows for each month using the NavajoData.NavajoOuflowWithScale Slot.  These values will be returned as volume per month in Acre-ft and will become the Navajo.Outflow monthly values. TP 8/7/2012";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      "SumFlowsToVolume"( $ "NavajoData.NavajoOutflowWithScale", "OffsetDate"( date, ( "GetDaysInMonth"( date ) / 1.00000000 "day" - 1.00000000 ) * - 1.00000000, "1 days" ), date );

    END;

    FUNCTION       "DetermineNumberOfDaysToExtend" ( NUMERIC DiffInVol, NUMERIC MaxDays )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns the number of days of extended flow needed to match the available water<br>TP 6/6/2012<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      IF ( DiffInVol / ( 2000.00000000 "cfs" * ( 1.98340000 "acre-ft" / 1.00000000 "cfs" ) ) <= MaxDays )
   THEN
      DiffInVol / ( 2000.00000000 "cfs" * ( 1.98340000 "acre-ft" / 1.00000000 "cfs" ) ) * 1.00000000 "day"
   ELSE
      IF ( DiffInVol / ( 2500.00000000 "cfs" * ( 1.98340000 "acre-ft" / 1.00000000 "cfs" ) ) <= MaxDays )
      THEN
         DiffInVol / ( 2500.00000000 "cfs" * ( 1.98340000 "acre-ft" / 1.00000000 "cfs" ) ) * 1.00000000 "day"
      ELSE
         IF ( DiffInVol / ( 3000.00000000 "cfs" * ( 1.98340000 "acre-ft" / 1.00000000 "cfs" ) ) <= MaxDays )
         THEN
            DiffInVol / ( 3000.00000000 "cfs" * ( 1.98340000 "acre-ft" / 1.00000000 "cfs" ) ) * 1.00000000 "day"
         ELSE
            IF ( DiffInVol / ( 3500.00000000 "cfs" * ( 1.98340000 "acre-ft" / 1.00000000 "cfs" ) ) <= MaxDays )
            THEN
               DiffInVol / ( 3500.00000000 "cfs" * ( 1.98340000 "acre-ft" / 1.00000000 "cfs" ) ) * 1.00000000 "day"
            ELSE
               IF ( DiffInVol / ( 4000.00000000 "cfs" * ( 1.98340000 "acre-ft" / 1.00000000 "cfs" ) ) <= MaxDays )
               THEN
                  DiffInVol / ( 4000.00000000 "cfs" * ( 1.98340000 "acre-ft" / 1.00000000 "cfs" ) ) * 1.00000000 "day"
               ELSE
                  IF ( DiffInVol / ( 4500.00000000 "cfs" * ( 1.98340000 "acre-ft" / 1.00000000 "cfs" ) ) <= MaxDays )
                  THEN
                     DiffInVol / ( 4500.00000000 "cfs" * ( 1.98340000 "acre-ft" / 1.00000000 "cfs" ) ) * 1.00000000 "day"
                  ELSE
                     IF ( DiffInVol / ( 5000.00000000 "cfs" * ( 1.98340000 "acre-ft" / 1.00000000 "cfs" ) ) <= MaxDays )
                     THEN
                        DiffInVol / ( 5000.00000000 "cfs" * ( 1.98340000 "acre-ft" / 1.00000000 "cfs" ) ) * 1.00000000 "day"
                     ELSE
                        55.00000000 * 1.00000000 "day"
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDIF
   ENDIF;

    END;

    FUNCTION       "DetermineNavajoReleaseLevel" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This Function returns the value of the release level for the Navajo Release<br>0 = No Release<br>1 = Release of 114,000 AF<br>2 = Relase greater of 166,000 or SpillAF<br>3 = Release of > 344,000 AF to get the reservoir back to full<br><br><br>The policy is based on the decision Tree used by the Navajo Dam Operator and is within the Flow Recomendations For the San Juan River published by the San Juan River Basin Recovery Implementation Program *1999 ";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH NUMERIC RelVol = "ComputeWaterReqdForAnnRelease"( @"t" ) DO
      IF ( ( RelVol < IF ( IsNaN $ "NavajoData.MinimumLevelOneFlowChartLevel" [date] )
      THEN
         114000.00000000 "acre-ft"
      ELSE
         $ "NavajoData.MinimumLevelOneFlowChartLevel" [date]
      ENDIF ) COMMENTED_BY "If the total available water is less than 114,000 AF then no release is required" )
      THEN
         0.00000000
      ELSE
         IF ( ( RelVol + $ "Navajo.Storage" [@"t - 1"] - "ElevationToStorage"( % "Navajo", $ "NavajoData.MaxPE" [] ) > 0.00000000 "acre-ft" ) COMMENTED_BY "If a Spill is Probable" )
         THEN
            IF ( ( RelVol + $ "Navajo.Storage" [@"t - 1"] - "ElevationToStorage"( % "Navajo", $ "NavajoData.MaxPE" [] ) >= 344000.00000000 "acre-ft" ) COMMENTED_BY "If the total spill is greater than 344,000 AF then Release the full Spring Release" )
            THEN
               3.00000000 COMMENTED_BY "Release the full hydrograph to account for the large amount of spill that would occur"
            ELSE
               IF ( "Releaseof356KLast3Years"(  ) COMMENTED_BY "If a release in the last three years was equal to or greater than 344,000 AF, then don't release the full release but continue on " )
               THEN
                  IF ( "Releaseof166KLastYear"(  ) COMMENTED_BY "If there was a release of 166,000 last year" )
                  THEN
                     IF ( ( $ "NavajoData.Puturbation" ["Dec31ofYear"( @"t" )] == 1.00000000 ) COMMENTED_BY "If the year has perturbation (See the Navajodata.Perturbation Slot for details)" )
                     THEN
                        2.00000000 COMMENTED_BY "Release which is the greater, 116,000 AF or the Spill to keep the reservoir full"
                     ELSE
                        1.00000000 COMMENTED_BY "Release greater than 114,000 AF that will account for all of the spill but keep the reservoir full"
                     ENDIF
                  ELSE
                     2.00000000 COMMENTED_BY "if the release last year was not greater than 166,000 AF"
                  ENDIF
               ELSE
                  3.00000000 COMMENTED_BY "Release Full Hydrograph Path 7"
               ENDIF
            ENDIF
         ELSE
            IF ( ( $ "NavajoData.Puturbation" ["Dec31ofYear"( @"t" )] == 1.00000000 ) COMMENTED_BY "If the year has perturbation (See the Navajodata.Perturbation Slot for details)" )
            THEN
               1.00000000 COMMENTED_BY "Release of 114,000 Path 2"
            ELSE
               IF ( "Releaseof356KLast3Years"(  ) COMMENTED_BY "If there was a release greater than 344,000 AF in one of the last three years" )
               THEN
                  IF ( "ReleaseLastYear"(  ) COMMENTED_BY "If there was any release in the last two years then" )
                  THEN
                     0.00000000 COMMENTED_BY "No Release Path 5<br>"
                  ELSE
                     1.00000000 COMMENTED_BY "Release of 114,000 Path 14"
                  ENDIF
               ELSE
                  IF ( "Releaseof166KLastYear"(  ) COMMENTED_BY "If there was a release greater than 166,000 AF last year" )
                  THEN
                     0.00000000 COMMENTED_BY "No Release, Path 4"
                  ELSE
                     1.00000000 COMMENTED_BY "Release of 114,000 AF, Path 3<br>"
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDIF
   ENDWITH;

    END;

    FUNCTION       "DetermineReleaseScaleCurrentYear" ( DATETIME date, NUMERIC AvailH20, NUMERIC Release4Now )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This function uses the number of days proir to the peak date that the ramping and peak flows are suggested to happen and applies them in a way that the appropriate flows are calculated for the release. The value 126,316,800.609375 is calculated as a constant to match the RiverWare Value of the peak date to the current year value.  This value shoudl be challenged and another method of calculating this should be revisited. <br><br>86,400 are the number of seconds in a day and are used to convert days to seconds for use in RiverWare<br><br>The equation of Ceiling (.....)*RampUp/DwnIncrease/Decrease+Constant   is the equation used to apply values to a date if it is within the appropriate ramp up, max flow and ramp down dates.  The information for this table is found in the NavajoData.DaysOfSpringRelease Table. <br><br>TP May31/2012<br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WITH DATETIME YearScale = @"24:00:00 December 31, Previous Year" + 1.00000000 "day" DO
      WITH DATETIME PeakDate = "CompletePartialDate"( "NumberToDate"( $ "NavajoData.SpringPeakFlowDate" [@"24:00:00 December 31, Current Year"] ), @"24:00:00 December 31, Current Year" ) DO
         WITH NUMERIC DaysbtAprandPeak = PeakDate - @"24:00:00 April 1, Current Year" DO
            WITH NUMERIC DaysbtPeakandJul = @"24:00:00 July 31, Current Year" - PeakDate DO
               WITH NUMERIC level = $ "NavajoData.ReleaseLevel" [@"24:00:00 December 31, Current Year"] DO
                  WITH NUMERIC DaysBeforePeakOfRamp = % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT level ) [@"24:00:00 December 31, Current Year", 0.00000000] DO
                     WITH NUMERIC DaysBeforePeakOfPeak = % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT level ) [@"24:00:00 December 31, Current Year", 1.00000000] DO
                        WITH NUMERIC DaysAfterPeakOfPeak = % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT level ) [@"24:00:00 December 31, Current Year", 2.00000000] DO
                           WITH NUMERIC DaysAfterPeakofRampDwn = % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT level ) [@"24:00:00 December 31, Current Year", 3.00000000] DO
                              WITH NUMERIC NumberOfDaysatFlowRmpUp = % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT level ) [@"24:00:00 December 31, Current Year", 4.00000000] DO
                                 WITH NUMERIC NumberOfDaysFlowRmpDwn = % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT level ) [@"24:00:00 December 31, Current Year", 5.00000000] DO
                                    WITH NUMERIC RampUpIncrease = % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT level ) [@"24:00:00 December 31, Current Year", 6.00000000] DO
                                       WITH NUMERIC RampDwnDecrease = % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT level ) [@"24:00:00 December 31, Current Year", 7.00000000] DO
                                          WITH NUMERIC Flowat5000 = IF ( date >= PeakDate - DaysBeforePeakOfPeak AND date <= PeakDate + DaysAfterPeakOfPeak )
                                          THEN
                                             "SumFlowsToVolume"( $ "NavajoData.MarchThruJulyDaily", date, PeakDate + DaysAfterPeakOfPeak )
                                          ELSE
                                             "SumFlowsToVolume"( $ "NavajoData.MarchThruJulyDaily", PeakDate - DaysBeforePeakOfPeak, PeakDate + DaysAfterPeakOfPeak )
                                          ENDIF DO
                                             WITH NUMERIC VolofBaseFlowDuringHigherflow = ( DaysBeforePeakOfRamp - DaysBeforePeakOfPeak ) / 1.00000000 "day" * $ "NavajoData.BaseRelease" [] * ( 1.98347100 "acre-ft" / 1.00000000 "cfs" ) + ( DaysAfterPeakofRampDwn - DaysAfterPeakOfPeak ) / 1.00000000 "day" * $ "NavajoData.BaseRelease" [] * ( 1.98347100 "acre-ft" / 1.00000000 "cfs" ) DO
                                                IF ( level == 0.00000000 )
                                                THEN
                                                   1.00000000
                                                ELSE
                                                   IF ( ( ( AvailH20 - Flowat5000 ) - VolofBaseFlowDuringHigherflow ) / ( ( Release4Now - Flowat5000 ) - VolofBaseFlowDuringHigherflow ) < 0.00000000 )
                                                   THEN
                                                      1.00000000
                                                   ELSE
                                                      ( ( AvailH20 - Flowat5000 ) - VolofBaseFlowDuringHigherflow ) / ( ( Release4Now - Flowat5000 ) - VolofBaseFlowDuringHigherflow )
                                                   ENDIF
                                                ENDIF
                                             ENDWITH
                                          ENDWITH
                                       ENDWITH
                                    ENDWITH
                                 ENDWITH
                              ENDWITH
                           ENDWITH
                        ENDWITH
                     ENDWITH
                  ENDWITH
               ENDWITH
            ENDWITH
         ENDWITH
      ENDWITH
   ENDWITH;

    END;

    FUNCTION       "DetermineSpringReleaseExtentionCurrentYear" ( DATETIME date, NUMERIC AvailH20, NUMERIC Release4Now )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This function uses the number of days proir to the peak date that the ramping and peak flows are suggested to happen and applies them in a way that the appropriate flows are calculated for the release. The value 126,316,800.609375 is calculated as a constant to match the RiverWare Value of the peak date to the current year value.  This value shoudl be challenged and another method of calculating this should be revisited. <br><br>86,400 are the number of seconds in a day and are used to convert days to seconds for use in RiverWare<br><br>The equation of Ceiling (.....)*RampUp/DwnIncrease/Decrease+Constant   is the equation used to apply values to a date if it is within the appropriate ramp up, max flow and ramp down dates.  The information for this table is found in the NavajoData.DaysOfSpringRelease Table. <br><br>TP May31/2012<br><br>2000 cfs is the first step of additional flow to be added to the spring hydrograph as said in the Flow Recomendations for the San Juan River, 1999. If that does not work, then add in increments of 500 cfs with the ramping at the beginning to March 1.  THe maximum flow can be 5,000 cfs and the ramping can be taken to March first with the maximum ramping being 1,000 cfs per day. TP 6/6/2012<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH DATETIME YearScale = IF ( "GetMonth"( @"t" ) >= 10.00000000 )
   THEN
      @"24:00:00 December 31, Current Year" + 1.00000000 "day"
   ELSE
      @"24:00:00 December 31, Previous Year" + 1.00000000 "day"
   ENDIF DO
      WITH NUMERIC offsetYear = IF ( "GetMonth"( @"t" ) >= 10.00000000 )
      THEN
         1.00000000
      ELSE
         0.00000000
      ENDIF DO
         WITH DATETIME PeakDate = IF ( "GetMonth"( @"t" ) >= 10.00000000 )
         THEN
            "CompletePartialDate"( "NumberToDate"( $ "NavajoData.SpringPeakFlowDate" [@"24:00:00 December 31, Current Year + 12"] ), @"24:00:00 December 31, Current Year + 24" )
         ELSE
            "CompletePartialDate"( "NumberToDate"( $ "NavajoData.SpringPeakFlowDate" [@"24:00:00 December 31, Current Year"] ), @"24:00:00 December 31, Current Year" )
         ENDIF DO
            WITH NUMERIC level = IF ( "GetMonth"( @"t" ) >= 10.00000000 )
            THEN
               $ "NavajoData.ReleaseLevel" [@"24:00:00 December 31, Current Year + 12"]
            ELSE
               $ "NavajoData.ReleaseLevel" [@"24:00:00 December 31, Current Year"]
            ENDIF DO
               WITH NUMERIC DaysBeforePeakOfRamp = % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT level ) [@"24:00:00 December 31, Current Year", 0.00000000] DO
                  WITH NUMERIC DaysBeforePeakOfPeak = % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT level ) [@"24:00:00 December 31, Current Year", 1.00000000] DO
                     WITH NUMERIC DaysAfterPeakOfPeak = % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT level ) [@"24:00:00 December 31, Current Year", 2.00000000] DO
                        WITH NUMERIC DaysAfterPeakofRampDwn = % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT level ) [@"24:00:00 December 31, Current Year", 3.00000000] DO
                           WITH NUMERIC NumberOfDaysatFlowRmpUp = % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT level ) [@"24:00:00 December 31, Current Year", 4.00000000] DO
                              WITH NUMERIC NumberOfDaysFlowRmpDwn = % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT level ) [@"24:00:00 December 31, Current Year", 5.00000000] DO
                                 WITH NUMERIC RampUpIncrease = % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT level ) [@"24:00:00 December 31, Current Year", 6.00000000] DO
                                    WITH NUMERIC RampDwnDecrease = % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT level ) [@"24:00:00 December 31, Current Year", 7.00000000] DO
                                       WITH NUMERIC DiffInVol = AvailH20 - Release4Now + ( DaysBeforePeakOfRamp + DaysAfterPeakofRampDwn + 1.00000000 "day" ) / 1.00000000 "day" * $ "NavajoData.BaseRelease" [] * ( 1.98347100 "acre-ft" / 1.00000000 "cfs" ) DO
                                          WITH NUMERIC MaxNoIncreaseDays = IF ( "GetMonth"( @"t" ) >= 10.00000000 )
                                          THEN
                                             ( PeakDate - DaysBeforePeakOfRamp - @"24:00:00 March 1, Current Year + 12" ) / 1.00000000 "day"
                                          ELSE
                                             ( PeakDate - DaysBeforePeakOfRamp - @"24:00:00 March 1, Current Year" ) / 1.00000000 "day"
                                          ENDIF DO
                                             WITH NUMERIC IncreasedDays = "Ceiling"( "DetermineNumberOfDaysToExtend"( DiffInVol, MaxNoIncreaseDays ), 1.00000000 "day" ) DO
                                                WITH NUMERIC ExtendFlow = "DetermineVolumeToExtend"( DiffInVol, MaxNoIncreaseDays ) DO
                                                   WITH NUMERIC DaysofRampBeforAddRelease = "DaysofRampBeforeAdditionalRelease"( ExtendFlow, RampUpIncrease, NumberOfDaysatFlowRmpUp ) DO
                                                      WITH NUMERIC AnimasFlow = IF ( IsNaN $ "SanJuanBelowNavajo:AnimasRiver.Local Inflow" ["MaxDayOfMonth"( date )] )
                                                      THEN
                                                         0.00000000 "acre-foot" / 1.00000000 "month"
                                                      ELSE
                                                         $ "SanJuanBelowNavajo:AnimasRiver.Local Inflow" ["MaxDayOfMonth"( date )]
                                                      ENDIF DO
                                                         WITH NUMERIC DSDiversion = IF ( IsNaN $ "SanJuanBelowNavajo.Total Diversion" ["MaxDayOfMonth"( date )] )
                                                         THEN
                                                            0.00000000 "acre-foot" / 1.00000000 "month"
                                                         ELSE
                                                            $ "SanJuanBelowNavajo.Total Diversion" ["MaxDayOfMonth"( date )]
                                                         ENDIF DO
                                                            IF ( level == 3.00000000 )
                                                            THEN
                                                               IF ( ( date >= PeakDate - DaysBeforePeakOfRamp - IncreasedDays AND date < PeakDate - DaysBeforePeakOfRamp - ( ( IncreasedDays - DaysofRampBeforAddRelease ) + 1.00000000 "day" ) ) COMMENTED_BY "Ramping up before the increased amount of flow in the dates before the original ramping" )
                                                               THEN
                                                                  "Min"( "Ceiling"( ( date + IncreasedDays + ( DaysBeforePeakOfRamp + 1.00000000 "day" ) - PeakDate ) / NumberOfDaysatFlowRmpUp, 1.00000000 ) * RampUpIncrease + IF ( RampUpIncrease < 1000.00000000 "cfs" )
                                                                  THEN
                                                                     $ "NavajoData.BaseRelease" []
                                                                  ELSE
                                                                     0.00000000 "cfs"
                                                                  ENDIF, $ "NavajoData.SpringPeakRelease" [] )
                                                               ELSE
                                                                  IF ( ( date >= PeakDate - DaysBeforePeakOfRamp - ( ( IncreasedDays - DaysofRampBeforAddRelease ) + 1.00000000 "day" ) AND date < PeakDate - ( DaysBeforePeakOfRamp - DaysofRampBeforAddRelease ) ) COMMENTED_BY "ExtendedFlowperiod" )
                                                                  THEN
                                                                     "Min"( ExtendFlow, $ "NavajoData.SpringPeakRelease" [] )
                                                                  ELSE
                                                                     IF ( ( date >= PeakDate - ( DaysBeforePeakOfRamp - DaysofRampBeforAddRelease ) AND date <= PeakDate - DaysBeforePeakOfPeak ) COMMENTED_BY "Rest of Ramping Period" )
                                                                     THEN
                                                                        "Min"( "Ceiling"( ( date + ( DaysBeforePeakOfRamp + 1.00000000 "day" ) - PeakDate ) / NumberOfDaysatFlowRmpUp, 1.00000000 ) * RampUpIncrease + IF ( RampUpIncrease < 1000.00000000 "cfs" )
                                                                        THEN
                                                                           $ "NavajoData.BaseRelease" []
                                                                        ELSE
                                                                           0.00000000 "cfs"
                                                                        ENDIF, $ "NavajoData.SpringPeakRelease" [] )
                                                                     ELSE
                                                                        IF ( ( date >= PeakDate - DaysBeforePeakOfPeak AND date <= PeakDate + DaysAfterPeakOfPeak ) )
                                                                        THEN
                                                                           $ "NavajoData.SpringPeakRelease" []
                                                                        ELSE
                                                                           IF ( ( date > PeakDate + DaysAfterPeakOfPeak AND date <= PeakDate + DaysAfterPeakofRampDwn ) COMMENTED_BY "Ramp Down" )
                                                                           THEN
                                                                              $ "NavajoData.MarchThruJulyDaily" [date]
                                                                           ELSE
                                                                              IF ( level < 2.00000000 )
                                                                              THEN
                                                                                 IF ( date > @"24:00:00 June 30, Current Year" )
                                                                                 THEN
                                                                                    "Max"( $ "NavajoData.DesiredDownStreamFlow" [] - AnimasFlow + DSDiversion, $ "NavajoData.BaseRelease" [] )
                                                                                 ELSE
                                                                                    $ "NavajoData.BaseRelease" []
                                                                                 ENDIF
                                                                              ELSE
                                                                                 $ "NavajoData.BaseRelease" []
                                                                              ENDIF
                                                                           ENDIF
                                                                        ENDIF
                                                                     ENDIF
                                                                  ENDIF
                                                               ENDIF
                                                            ELSE
                                                               IF ( ( date >= PeakDate - DaysBeforePeakOfRamp AND date < PeakDate - DaysBeforePeakOfPeak ) COMMENTED_BY "Ramping Up" )
                                                               THEN
                                                                  "Min"( $ "NavajoData.MarchThruJulyDaily" [date], $ "NavajoData.SpringPeakRelease" [] )
                                                               ELSE
                                                                  IF ( ( date >= PeakDate - DaysBeforePeakOfPeak AND date <= PeakDate + DaysAfterPeakOfPeak ) COMMENTED_BY "Peak Period" )
                                                                  THEN
                                                                     $ "NavajoData.SpringPeakRelease" []
                                                                  ELSE
                                                                     IF ( ( date > PeakDate + DaysAfterPeakOfPeak AND date <= PeakDate + DaysAfterPeakofRampDwn ) COMMENTED_BY "Ramping Down" )
                                                                     THEN
                                                                        "Min"( $ "NavajoData.MarchThruJulyDaily" [date], $ "NavajoData.SpringPeakRelease" [] )
                                                                     ELSE
                                                                        IF ( level < 2.00000000 )
                                                                        THEN
                                                                           IF ( date > @"24:00:00 June 30, Current Year" )
                                                                           THEN
                                                                              "Max"( $ "NavajoData.DesiredDownStreamFlow" [] - AnimasFlow + DSDiversion, $ "NavajoData.BaseRelease" [] )
                                                                           ELSE
                                                                              $ "NavajoData.BaseRelease" []
                                                                           ENDIF
                                                                        ELSE
                                                                           $ "NavajoData.BaseRelease" []
                                                                        ENDIF
                                                                     ENDIF
                                                                  ENDIF
                                                               ENDIF
                                                            ENDIF COMMENTED_BY "if the scale value is less than 1.25, then apply the scale value to the release, otherwise some additional flows will have to be added to the release"
                                                         ENDWITH COMMENTED_BY "These diversions are set to 0 right now. They have been added so that in the future if diversions are added down stream of Navajo Reservoir, they will go into here. "
                                                      ENDWITH COMMENTED_BY "If there ever is an animas forecasted flow this is where a reference to it would be. The forecast would most likely be monthly so it would have to be aggregated to daily so it can be used in this function. "
                                                   ENDWITH
                                                ENDWITH
                                             ENDWITH
                                          ENDWITH
                                       ENDWITH
                                    ENDWITH
                                 ENDWITH
                              ENDWITH
                           ENDWITH
                        ENDWITH
                     ENDWITH
                  ENDWITH
               ENDWITH
            ENDWITH
         ENDWITH
      ENDWITH
   ENDWITH;

    END;

    FUNCTION       "DetermineSpringReleaseExtentionForwardYears" ( DATETIME date, NUMERIC AvailH20, NUMERIC Release4Now )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This function uses the number of days proir to the peak date that the ramping and peak flows are suggested to happen and applies them in a way that the appropriate flows are calculated for the release. The value 126,316,800.609375 is calculated as a constant to match the RiverWare Value of the peak date to the current year value.  This value shoudl be challenged and another method of calculating this should be revisited. <br><br>86,400 are the number of seconds in a day and are used to convert days to seconds for use in RiverWare<br><br>The equation of Ceiling (.....)*RampUp/DwnIncrease/Decrease+Constant   is the equation used to apply values to a date if it is within the appropriate ramp up, max flow and ramp down dates.  The information for this table is found in the NavajoData.DaysOfSpringRelease Table. <br><br>TP May31/2012<br><br>2000 cfs is the first step of additional flow to be added to the spring hydrograph as said in the Flow Recomendations for the San Juan River, 1999. If that does not work, then add in increments of 500 cfs with the ramping at the beginning to March 1.  THe maximum flow can be 5,000 cfs and the ramping can be taken to March first with the maximum ramping being 1,000 cfs per day. TP 6/6/2012<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH DATETIME YearScale = @"24:00:00 December 31, Previous Year" + 1.00000000 "day" DO
      WITH NUMERIC offsetYear = IF ( "GetYear"( @"t" ) == "GetYear"( @"Start Timestep" ) )
      THEN
         1.00000000
      ELSE
         2.00000000
      ENDIF DO
         WITH DATETIME PeakDate = "CompletePartialDate"( "NumberToDate"( $ "NavajoData.SpringPeakFlowDate" [@"24:00:00 December 31, Current Year"] ), @"24:00:00 December 31, Current Year" ) DO
            WITH NUMERIC level = $ "NavajoData.ReleaseLevel" [@"24:00:00 December 31, Current Year"] DO
               WITH NUMERIC DaysBeforePeakOfRamp = % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT level ) [@"24:00:00 December 31, Current Year", 0.00000000] DO
                  WITH NUMERIC DaysBeforePeakOfPeak = % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT level ) [@"24:00:00 December 31, Current Year", 1.00000000] DO
                     WITH NUMERIC DaysAfterPeakOfPeak = % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT level ) [@"24:00:00 December 31, Current Year", 2.00000000] DO
                        WITH NUMERIC DaysAfterPeakofRampDwn = % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT level ) [@"24:00:00 December 31, Current Year", 3.00000000] DO
                           WITH NUMERIC NumberOfDaysatFlowRmpUp = % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT level ) [@"24:00:00 December 31, Current Year", 4.00000000] DO
                              WITH NUMERIC NumberOfDaysFlowRmpDwn = % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT level ) [@"24:00:00 December 31, Current Year", 5.00000000] DO
                                 WITH NUMERIC RampUpIncrease = % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT level ) [@"24:00:00 December 31, Current Year", 6.00000000] DO
                                    WITH NUMERIC RampDwnDecrease = % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT level ) [@"24:00:00 December 31, Current Year", 7.00000000] DO
                                       WITH NUMERIC DiffInVol = AvailH20 - Release4Now + ( DaysBeforePeakOfRamp + DaysAfterPeakofRampDwn + 1.00000000 "day" ) / 1.00000000 "day" * $ "NavajoData.BaseRelease" [] * ( 1.98347100 "acre-ft" / 1.00000000 "cfs" ) DO
                                          WITH NUMERIC MaxNoIncreaseDays = ( PeakDate - DaysBeforePeakOfRamp - @"24:00:00 March 1, Current Year" ) / 1.00000000 "day" DO
                                             WITH NUMERIC IncreasedDays = "Ceiling"( "DetermineNumberOfDaysToExtend"( DiffInVol, MaxNoIncreaseDays ), 1.00000000 "day" ) DO
                                                WITH NUMERIC ExtendFlow = "DetermineVolumeToExtend"( DiffInVol, MaxNoIncreaseDays ) DO
                                                   WITH NUMERIC DaysofRampBeforAddRelease = "DaysofRampBeforeAdditionalRelease"( ExtendFlow, RampUpIncrease, NumberOfDaysatFlowRmpUp ) DO
                                                      WITH NUMERIC AnimasFlow = 0.00000000 "acre-foot" / 1.00000000 "month" DO
                                                         WITH NUMERIC DSDiversion = IF ( IsNaN $ "SanJuanBelowNavajo.Total Diversion" ["MaxDayOfMonth"( date )] )
                                                         THEN
                                                            0.00000000 "acre-foot" / 1.00000000 "month"
                                                         ELSE
                                                            $ "SanJuanBelowNavajo.Total Diversion" ["MaxDayOfMonth"( date )] / "GetDaysInMonth"( date ) * 1.00000000 "day"
                                                         ENDIF DO
                                                            IF ( level == 3.00000000 )
                                                            THEN
                                                               IF ( ( date >= PeakDate - DaysBeforePeakOfRamp - IncreasedDays AND date < PeakDate - DaysBeforePeakOfRamp - ( ( IncreasedDays - DaysofRampBeforAddRelease ) + 1.00000000 "day" ) ) COMMENTED_BY "Ramping up before the increased amount of flow in the dates before the original ramping" )
                                                               THEN
                                                                  "Min"( "Ceiling"( ( date + IncreasedDays + ( DaysBeforePeakOfRamp + 1.00000000 "day" ) - PeakDate ) / NumberOfDaysatFlowRmpUp, 1.00000000 ) * RampUpIncrease + IF ( RampUpIncrease < 1000.00000000 "cfs" )
                                                                  THEN
                                                                     $ "NavajoData.BaseRelease" []
                                                                  ELSE
                                                                     0.00000000 "cfs"
                                                                  ENDIF, $ "NavajoData.SpringPeakRelease" [] )
                                                               ELSE
                                                                  IF ( ( date >= PeakDate - DaysBeforePeakOfRamp - ( ( IncreasedDays - DaysofRampBeforAddRelease ) + 1.00000000 "day" ) AND date < PeakDate - ( DaysBeforePeakOfRamp - DaysofRampBeforAddRelease ) ) COMMENTED_BY "ExtendedFlowperiod" )
                                                                  THEN
                                                                     "Min"( ExtendFlow, $ "NavajoData.SpringPeakRelease" [] )
                                                                  ELSE
                                                                     IF ( ( date >= PeakDate - ( DaysBeforePeakOfRamp - DaysofRampBeforAddRelease ) AND date <= PeakDate - DaysBeforePeakOfPeak ) COMMENTED_BY "Rest of Ramping Period" )
                                                                     THEN
                                                                        "Min"( "Ceiling"( ( date + ( DaysBeforePeakOfRamp + 1.00000000 "day" ) - PeakDate ) / NumberOfDaysatFlowRmpUp, 1.00000000 ) * RampUpIncrease + IF ( RampUpIncrease < 1000.00000000 "cfs" )
                                                                        THEN
                                                                           $ "NavajoData.BaseRelease" []
                                                                        ELSE
                                                                           0.00000000 "cfs"
                                                                        ENDIF, $ "NavajoData.SpringPeakRelease" [] )
                                                                     ELSE
                                                                        IF ( ( date >= PeakDate - DaysBeforePeakOfPeak AND date <= PeakDate + DaysAfterPeakOfPeak ) )
                                                                        THEN
                                                                           $ "NavajoData.SpringPeakRelease" []
                                                                        ELSE
                                                                           IF ( ( date > PeakDate + DaysAfterPeakOfPeak AND date <= PeakDate + DaysAfterPeakofRampDwn ) COMMENTED_BY "Ramping Down" )
                                                                           THEN
                                                                              $ "NavajoData.MarchThruJulyDaily" [date]
                                                                           ELSE
                                                                              IF ( level < 2.00000000 )
                                                                              THEN
                                                                                 IF ( date > @"24:00:00 June 30, Current Year" )
                                                                                 THEN
                                                                                    "Max"( $ "NavajoData.DesiredDownStreamFlow" [] - AnimasFlow + DSDiversion, $ "NavajoData.BaseRelease" [] )
                                                                                 ELSE
                                                                                    $ "NavajoData.BaseRelease" []
                                                                                 ENDIF
                                                                              ELSE
                                                                                 $ "NavajoData.BaseRelease" []
                                                                              ENDIF
                                                                           ENDIF
                                                                        ENDIF
                                                                     ENDIF
                                                                  ENDIF
                                                               ENDIF
                                                            ELSE
                                                               IF ( ( date >= PeakDate - DaysBeforePeakOfRamp AND date < PeakDate - DaysBeforePeakOfPeak ) COMMENTED_BY "Ramping Up" )
                                                               THEN
                                                                  "Min"( $ "NavajoData.MarchThruJulyDaily" [date], $ "NavajoData.SpringPeakRelease" [] )
                                                               ELSE
                                                                  IF ( ( date >= PeakDate - DaysBeforePeakOfPeak AND date <= PeakDate + DaysAfterPeakOfPeak ) COMMENTED_BY "Peak Period" )
                                                                  THEN
                                                                     $ "NavajoData.SpringPeakRelease" []
                                                                  ELSE
                                                                     IF ( ( date > PeakDate + DaysAfterPeakOfPeak AND date <= PeakDate + DaysAfterPeakofRampDwn ) COMMENTED_BY "Ramping Down" )
                                                                     THEN
                                                                        "Min"( $ "NavajoData.MarchThruJulyDaily" [date], $ "NavajoData.SpringPeakRelease" [] )
                                                                     ELSE
                                                                        IF ( $ "NavajoData.BaseRelease" [] + AnimasFlow - DSDiversion >= 500.00000000 "cfs" )
                                                                        THEN
                                                                           $ "NavajoData.BaseRelease" [] - ( $ "NavajoData.BaseRelease" [] + AnimasFlow - DSDiversion - 500.00000000 "cfs" )
                                                                        ELSE
                                                                           IF ( level < 2.00000000 )
                                                                           THEN
                                                                              IF ( date > @"24:00:00 June 30, Current Year" )
                                                                              THEN
                                                                                 "Max"( $ "NavajoData.DesiredDownStreamFlow" [] - AnimasFlow + DSDiversion, $ "NavajoData.BaseRelease" [] )
                                                                              ELSE
                                                                                 $ "NavajoData.BaseRelease" []
                                                                              ENDIF
                                                                           ELSE
                                                                              $ "NavajoData.BaseRelease" []
                                                                           ENDIF
                                                                        ENDIF
                                                                     ENDIF
                                                                  ENDIF
                                                               ENDIF
                                                            ENDIF COMMENTED_BY "if the scale value is less than 1.25, then apply the scale value to the release, otherwise some additional flows will have to be added to the release"
                                                         ENDWITH COMMENTED_BY "These diversions are set to 0 right now. They have been added so that in the future if diversions are added down stream of Navajo Reservoir, they will go into here. "
                                                      ENDWITH COMMENTED_BY "If there ever is an animas forecasted flow this is where a reference to it would be. The forecast would most likely be monthly so it would have to be aggregated to daily so it can be used in this function. "
                                                   ENDWITH
                                                ENDWITH
                                             ENDWITH
                                          ENDWITH
                                       ENDWITH
                                    ENDWITH
                                 ENDWITH
                              ENDWITH
                           ENDWITH
                        ENDWITH
                     ENDWITH
                  ENDWITH
               ENDWITH
            ENDWITH
         ENDWITH
      ENDWITH
   ENDWITH;

    END;

    FUNCTION       "DetermineVolumeToExtend" ( NUMERIC DiffInVol, NUMERIC MaxDays )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns the number of days of extended flow needed to match the available water<br>TP 6/6/2012<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      IF ( DiffInVol / ( 1500.00000000 "cfs" * ( 1.98340000 "acre-ft" / 1.00000000 "cfs" ) ) <= MaxDays )
   THEN
      1500.00000000 "cfs" + $ "NavajoData.BaseRelease" []
   ELSE
      IF ( DiffInVol / ( 2000.00000000 "cfs" * ( 1.98340000 "acre-ft" / 1.00000000 "cfs" ) ) <= MaxDays )
      THEN
         2000.00000000 "cfs" + $ "NavajoData.BaseRelease" []
      ELSE
         IF ( DiffInVol / ( 2500.00000000 "cfs" * ( 1.98340000 "acre-ft" / 1.00000000 "cfs" ) ) <= MaxDays )
         THEN
            2500.00000000 "cfs" + $ "NavajoData.BaseRelease" []
         ELSE
            IF ( DiffInVol / ( 3000.00000000 "cfs" * ( 1.98340000 "acre-ft" / 1.00000000 "cfs" ) ) <= MaxDays )
            THEN
               3000.00000000 "cfs" + $ "NavajoData.BaseRelease" []
            ELSE
               IF ( DiffInVol / ( 3500.00000000 "cfs" * ( 1.98340000 "acre-ft" / 1.00000000 "cfs" ) ) <= MaxDays )
               THEN
                  3500.00000000 "cfs" + $ "NavajoData.BaseRelease" []
               ELSE
                  IF ( DiffInVol / ( 4000.00000000 "cfs" * ( 1.98340000 "acre-ft" / 1.00000000 "cfs" ) ) <= MaxDays )
                  THEN
                     4000.00000000 "cfs" + $ "NavajoData.BaseRelease" []
                  ELSE
                     IF ( DiffInVol / ( 4500.00000000 "cfs" * ( 1.98340000 "acre-ft" / 1.00000000 "cfs" ) ) <= MaxDays )
                     THEN
                        4500.00000000 "cfs" + $ "NavajoData.BaseRelease" []
                     ELSE
                        5000.00000000 "cfs"
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDIF
   ENDIF;

    END;

    FUNCTION       "DetermineLowFlowsatNavajo" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      FOR ( DATETIME date IN "GetDates"( @"t", "DateMin"( @"24:00:00 February Max DayOfMonth, Current Year + 12", @"Finish Timestep" ), "1 months" ) ) WITH LIST result = {  } DO
      WITH LIST DateAndDiffStor = FOR ( DATETIME dateb IN "GetDates"( @"t", "DateMin"( @"24:00:00 February Max DayOfMonth, Current Year + 12", @"Finish Timestep" ), "1 months" ) ) WITH LIST DateAndDiffStor = {  } DO
         APPEND { dateb , "Max"( "ElevationToStorage"( % "Navajo", $ "NavajoData.MinDesiredPoolElevation" [] ) - $ "Navajo.Storage" [dateb], 0.00000000 "acre-ft" ) } ONTO DateAndDiffStor
      ENDFOR DO
         WITH LIST DiffList = MAPLIST ( LIST DiffListCheck IN DateAndDiffStor ) DO
            GET @INDEX 1.00000000 FROM DiffListCheck
         ENDMAPLIST DO
            WITH NUMERIC MaxDiff = "MaxItem"( DiffList ) DO
               WITH NUMERIC MaxIndex = FIND MaxDiff WITHIN DiffList DO
                  WITH NUMERIC MaxDiffWithEvap = MaxDiff + "SumSlot"( $ "Navajo.Evaporation", @"t", "DateMin"( @"24:00:00 February Max DayOfMonth, Current Year + 12", @"Finish Timestep" ) ) DO
                     WITH LIST MaxDateLists = GET @INDEX MaxIndex FROM DateAndDiffStor DO
                        WITH DATETIME MaxDate = "DateMin"( GET @INDEX 0.00000000 FROM MaxDateLists, @"Finish Timestep" ) DO
                           WITH NUMERIC SummedOutflowValuesFromNavajo = "SumFlowsToVolume"( $ "Navajo.Outflow", @"t", MaxDate ) DO
                              WITH NUMERIC SummedNIIPDiversions = "SumFlowsToVolume"( $ "NavajoIndianIrrigationProjectNIIP.Depletion Requested", @"t", MaxDate ) DO
                                 WITH NUMERIC PercentChangeForOutflowandNIIP = "Max"( ( SummedOutflowValuesFromNavajo + SummedNIIPDiversions - MaxDiffWithEvap ) / ( SummedOutflowValuesFromNavajo + SummedNIIPDiversions ), 0.00000000 ) DO
                                    IF ( date > MaxDate )
                                    THEN
                                       APPEND { date , $ "Navajo.Outflow" [date] , $ "Navajo.Diversion" [date] } ONTO result
                                    ELSE
                                       APPEND { date , "Max"( $ "Navajo.Outflow" [date] * PercentChangeForOutflowandNIIP, $ "NavajoData.MinimumOutflow" [] ) , "Max"( $ "NavajoIndianIrrigationProjectNIIP.Diversion Requested" [date] * PercentChangeForOutflowandNIIP, 0.00000000 "cfs" ) } ONTO result
                                    ENDIF
                                 ENDWITH
                              ENDWITH
                           ENDWITH
                        ENDWITH
                     ENDWITH
                  ENDWITH
               ENDWITH
            ENDWITH
         ENDWITH
      ENDWITH
   ENDFOR;

    END;

    FUNCTION       "EstimateEvaporationNavajoApril" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "This Function estimates the evaporation from April to July for the available water calculation.  The evaporation is calculated based on the total inflow to the reservoir and  a release of only the base flow.  An error was occuring where the area volume table was limiting the solving of the reservoir because taking an inflow and releasing only the base flow can result in higher storage levels than the table implies.  So the Min function with the equation and the 1,976,849 acre-ft is used right now because 1,977,850.0000999999 acre-ft is the maximum storage in the area volume table.  This limits the evaporation to be calculated based on the largest area in the table.  If the area volume curve is extended, then this min function can be removed. TP 8/14/2012";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH NUMERIC MarEvap = "FlowToVolume"( "StorageToArea"( % "Navajo", "Min"( "CalcMarStorforAvalWatNavajo"(  ) + "AnticipatedInflowNavajo"( @"24:00:00 April 30, Current Year", @"24:00:00 April Max DayOfMonth, Current Year" ) - FOR ( DATETIME date IN "GetDates"( @"24:00:00 April 30, Current Year", @"24:00:00 April Max DayOfMonth, Current Year", "1 Months" ) ) WITH NUMERIC result = 0.00000000 "acre-ft" DO
      result + "FlowToVolume"( $ "NavajoData.BaseRelease" [], date )
   ENDFOR - $ "NavajoData.NIIPAnnualRequest" [@"24:00:00 December 31, Current Year"] * FOR ( DATETIME date IN @"24:00:00 April 30, Current Year" TO @"24:00:00 April 30, Current Year" ) STAT_SUM
      $ "NavajoData.NIIPMonthlyDistribution" [date]
   ENDFOR, 1976849.00000000 "acre-ft" ) ) * $ "Navajo.Evaporation Coefficients" [3.00000000, 0.00000000], @"24:00:00 April 30, Current Year" ) DO
      WITH NUMERIC AprEvap = "FlowToVolume"( "StorageToArea"( % "Navajo", "Min"( $ "Navajo.Storage" [@"t - 1"] + "AnticipatedInflowNavajo"( @"24:00:00 April 30, Current Year", @"24:00:00 May Max DayOfMonth, Current Year" ) - FOR ( DATETIME date IN "GetDates"( @"24:00:00 April 30, Current Year", @"24:00:00 May Max DayOfMonth, Current Year", "1 Months" ) ) WITH NUMERIC result = 0.00000000 "acre-ft" DO
         result + "FlowToVolume"( $ "NavajoData.BaseRelease" [], date )
      ENDFOR - $ "NavajoData.NIIPAnnualRequest" [@"24:00:00 December 31, Current Year"] * FOR ( DATETIME date IN @"24:00:00 April 30, Current Year" TO @"24:00:00 May 31, Current Year" ) STAT_SUM
         $ "NavajoData.NIIPMonthlyDistribution" [date]
      ENDFOR - MarEvap, 1976849.00000000 "acre-ft" ) ) * $ "Navajo.Evaporation Coefficients" [4.00000000, 0.00000000], @"24:00:00 May 31, Current Year" ) DO
         WITH NUMERIC MayEvap = "FlowToVolume"( "StorageToArea"( % "Navajo", "Min"( $ "Navajo.Storage" [@"t - 1"] + "AnticipatedInflowNavajo"( @"24:00:00 April 30, Current Year", @"24:00:00 June Max DayOfMonth, Current Year" ) - FOR ( DATETIME date IN "GetDates"( @"24:00:00 April 30, Current Year", @"24:00:00 June Max DayOfMonth, Current Year", "1 Months" ) ) WITH NUMERIC result = 0.00000000 "acre-ft" DO
            result + "FlowToVolume"( $ "NavajoData.BaseRelease" [], date )
         ENDFOR - $ "NavajoData.NIIPAnnualRequest" [@"24:00:00 December 31, Current Year"] * FOR ( DATETIME date IN @"24:00:00 April 30, Current Year" TO @"24:00:00 June 30, Current Year" ) STAT_SUM
            $ "NavajoData.NIIPMonthlyDistribution" [date]
         ENDFOR - AprEvap, 1976849.00000000 "acre-ft" ) ) * $ "Navajo.Evaporation Coefficients" [5.00000000, 0.00000000], @"24:00:00 June 30, Current Year" ) DO
            WITH NUMERIC JunEvap = "FlowToVolume"( "StorageToArea"( % "Navajo", "Min"( $ "Navajo.Storage" [@"t - 1"] + "AnticipatedInflowNavajo"( @"24:00:00 April 30, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" ) - FOR ( DATETIME date IN "GetDates"( @"24:00:00 April 30, Current Year", @"24:00:00 July Max DayOfMonth, Current Year", "1 Months" ) ) WITH NUMERIC result = 0.00000000 "acre-ft" DO
               result + "FlowToVolume"( $ "NavajoData.BaseRelease" [], date )
            ENDFOR - $ "NavajoData.NIIPAnnualRequest" [@"24:00:00 December 31, Current Year"] * FOR ( DATETIME date IN @"24:00:00 April 30, Current Year" TO @"24:00:00 July 31, Current Year" ) STAT_SUM
               $ "NavajoData.NIIPMonthlyDistribution" [date]
            ENDFOR - MayEvap, 1976849.00000000 "acre-ft" ) ) * $ "Navajo.Evaporation Coefficients" [6.00000000, 0.00000000], @"24:00:00 July 31, Current Year" ) DO
               MarEvap + AprEvap + MayEvap + JunEvap
            ENDWITH
         ENDWITH
      ENDWITH
   ENDWITH;

    END;

    FUNCTION       "EstimateEvaporationNavajoMarch" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "This Function estimates the evaporation from March to July for the available water calculation.  The evaporation is calculated based on the total inflow to the reservoir and  a release of only the base flow.  An error was occuring where the area volume table was limiting the solving of the reservoir because taking an inflow and releasing only the base flow can result in higher storage levels than the table implies.  So the Min function with the equation and the 1,976,849 acre-ft is used right now because 1,977,850.0000999999 acre-ft is the maximum storage in the area volume table.  This limits the evaporation to be calculated based on the largest area in the table.  If the area volume curve is extended, then this min function can be removed. TP 8/14/2012";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH NUMERIC MarEvap = "FlowToVolume"( "StorageToArea"( % "Navajo", "Min"( "CalcMarStorforAvalWatNavajo"(  ) + "AnticipatedInflowNavajo"( @"24:00:00 April 30, Current Year", @"24:00:00 April Max DayOfMonth, Current Year" ) - FOR ( DATETIME date IN "GetDates"( @"24:00:00 April 30, Current Year", @"24:00:00 April Max DayOfMonth, Current Year", "1 Months" ) ) WITH NUMERIC result = 0.00000000 "acre-ft" DO
      result + "FlowToVolume"( $ "NavajoData.BaseRelease" [], date )
   ENDFOR - $ "NavajoData.NIIPAnnualRequest" [@"24:00:00 December 31, Current Year"] * FOR ( DATETIME date IN @"24:00:00 April 30, Current Year" TO @"24:00:00 April 30, Current Year" ) STAT_SUM
      $ "NavajoData.NIIPMonthlyDistribution" [date]
   ENDFOR, 1976849.00000000 "acre-ft" ) ) * $ "Navajo.Evaporation Coefficients" [3.00000000, 0.00000000], @"24:00:00 April 30, Current Year" ) DO
      WITH NUMERIC AprEvap = "FlowToVolume"( "StorageToArea"( % "Navajo", "Min"( "CalcMarStorforAvalWatNavajo"(  ) + "AnticipatedInflowNavajo"( @"24:00:00 April 30, Current Year", @"24:00:00 May Max DayOfMonth, Current Year" ) - FOR ( DATETIME date IN "GetDates"( @"24:00:00 April 30, Current Year", @"24:00:00 May Max DayOfMonth, Current Year", "1 Months" ) ) WITH NUMERIC result = 0.00000000 "acre-ft" DO
         result + "FlowToVolume"( $ "NavajoData.BaseRelease" [], date )
      ENDFOR - $ "NavajoData.NIIPAnnualRequest" [@"24:00:00 December 31, Current Year"] * FOR ( DATETIME date IN @"24:00:00 April 30, Current Year" TO @"24:00:00 May 31, Current Year" ) STAT_SUM
         $ "NavajoData.NIIPMonthlyDistribution" [date]
      ENDFOR - MarEvap, 1976849.00000000 "acre-ft" ) ) * $ "Navajo.Evaporation Coefficients" [4.00000000, 0.00000000], @"24:00:00 May 31, Current Year" ) DO
         WITH NUMERIC MayEvap = "FlowToVolume"( "StorageToArea"( % "Navajo", "Min"( "CalcMarStorforAvalWatNavajo"(  ) + "AnticipatedInflowNavajo"( @"24:00:00 April 30, Current Year", @"24:00:00 June Max DayOfMonth, Current Year" ) - FOR ( DATETIME date IN "GetDates"( @"24:00:00 April 30, Current Year", @"24:00:00 June Max DayOfMonth, Current Year", "1 Months" ) ) WITH NUMERIC result = 0.00000000 "acre-ft" DO
            result + "FlowToVolume"( $ "NavajoData.BaseRelease" [], date )
         ENDFOR - $ "NavajoData.NIIPAnnualRequest" [@"24:00:00 December 31, Current Year"] * FOR ( DATETIME date IN @"24:00:00 April 30, Current Year" TO @"24:00:00 June 30, Current Year" ) STAT_SUM
            $ "NavajoData.NIIPMonthlyDistribution" [date]
         ENDFOR - AprEvap, 1976849.00000000 "acre-ft" ) ) * $ "Navajo.Evaporation Coefficients" [5.00000000, 0.00000000], @"24:00:00 June 30, Current Year" ) DO
            WITH NUMERIC JunEvap = "FlowToVolume"( "StorageToArea"( % "Navajo", "Min"( "CalcMarStorforAvalWatNavajo"(  ) + "AnticipatedInflowNavajo"( @"24:00:00 April 30, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" ) - FOR ( DATETIME date IN "GetDates"( @"24:00:00 April 30, Current Year", @"24:00:00 July Max DayOfMonth, Current Year", "1 Months" ) ) WITH NUMERIC result = 0.00000000 "acre-ft" DO
               result + "FlowToVolume"( $ "NavajoData.BaseRelease" [], date )
            ENDFOR - $ "NavajoData.NIIPAnnualRequest" [@"24:00:00 December 31, Current Year"] * FOR ( DATETIME date IN @"24:00:00 April 30, Current Year" TO @"24:00:00 July 31, Current Year" ) STAT_SUM
               $ "NavajoData.NIIPMonthlyDistribution" [date]
            ENDFOR - MayEvap, 1976849.00000000 "acre-ft" ) ) * $ "Navajo.Evaporation Coefficients" [6.00000000, 0.00000000], @"24:00:00 July 31, Current Year" ) DO
               MarEvap + AprEvap + MayEvap + JunEvap
            ENDWITH
         ENDWITH
      ENDWITH
   ENDWITH;

    END;

    FUNCTION       "EstimateEvaporationNavajo" ( DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "This Function estimates the evaporation from March to July for the available water calculation.  The evaporation is calculated based on the total inflow to the reservoir and  a release of only the base flow.  An error was occuring where the area volume table was limiting the solving of the reservoir because taking an inflow and releasing only the base flow can result in higher storage levels than the table implies.  So the Min function with the equation and the 1,976,849 acre-ft is used right now because 1,977,850.0000999999 acre-ft is the maximum storage in the area volume table.  This limits the evaporation to be calculated based on the largest area in the table.  If the area volume curve is extended, then this min function can be removed. TP 8/14/2012";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      FOR ( DATETIME date IN startDate TO endDate ) WITH NUMERIC evapCalc = 0.00000000 "acre-ft" DO
      evapCalc + "FlowToVolume"( "StorageToArea"( % "Navajo", "Min"( $ "Navajo.Storage" [@"t - 1"] + "AnticipatedInflowNavajo"( startDate, date ) - "SumNavajoBaseRelease_New"( startDate, date ) - FOR ( DATETIME niipDate IN startDate TO date ) WITH NUMERIC result = 0.00000000 "acre-ft" DO
         "FlowToVolume"( $ "NavajoIndianIrrigationProjectNIIP.Diversion Requested" [niipDate], niipDate ) + result
      ENDFOR, 1976849.00000000 "acre-ft" ) ) * $ "Navajo.Evaporation Coefficients" ["GetMonth"( date ) - 1.00000000, 0.00000000], date )
   ENDFOR;

    END;

    FUNCTION       "EstimateEvaporationNavajoMay" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "This Function estimates the evaporation from May to July for the available water calculation.  The evaporation is calculated based on the total inflow to the reservoir and  a release of only the base flow.  An error was occuring where the area volume table was limiting the solving of the reservoir because taking an inflow and releasing only the base flow can result in higher storage levels than the table implies.  So the Min function with the equation and the 1,976,849 acre-ft is used right now because 1,977,850.0000999999 acre-ft is the maximum storage in the area volume table.  This limits the evaporation to be calculated based on the largest area in the table.  If the area volume curve is extended, then this min function can be removed. TP 8/14/2012";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH NUMERIC AprEvap = "FlowToVolume"( "StorageToArea"( % "Navajo", "Min"( $ "Navajo.Storage" [@"t - 1"] + "AnticipatedInflowNavajo"( @"24:00:00 May 31, Current Year", @"24:00:00 May Max DayOfMonth, Current Year" ) - FOR ( DATETIME date IN "GetDates"( @"24:00:00 May 31, Current Year", @"24:00:00 May Max DayOfMonth, Current Year", "1 Months" ) ) WITH NUMERIC result = 0.00000000 "acre-ft" DO
      result + "FlowToVolume"( $ "NavajoData.BaseRelease" [], date )
   ENDFOR - $ "NavajoData.NIIPAnnualRequest" [@"24:00:00 December 31, Current Year"] * FOR ( DATETIME date IN @"24:00:00 May 31, Current Year" TO @"24:00:00 May 31, Current Year" ) STAT_SUM
      $ "NavajoData.NIIPMonthlyDistribution" [date]
   ENDFOR, 1976849.00000000 "acre-ft" ) ) * $ "Navajo.Evaporation Coefficients" [4.00000000, 0.00000000], @"24:00:00 May 31, Current Year" ) DO
      WITH NUMERIC MayEvap = "FlowToVolume"( "StorageToArea"( % "Navajo", "Min"( $ "Navajo.Storage" [@"t - 1"] + "AnticipatedInflowNavajo"( @"24:00:00 May 31, Current Year", @"24:00:00 June Max DayOfMonth, Current Year" ) - FOR ( DATETIME date IN "GetDates"( @"24:00:00 May 31, Current Year", @"24:00:00 June Max DayOfMonth, Current Year", "1 Months" ) ) WITH NUMERIC result = 0.00000000 "acre-ft" DO
         result + "FlowToVolume"( $ "NavajoData.BaseRelease" [], date )
      ENDFOR - $ "NavajoData.NIIPAnnualRequest" [@"24:00:00 December 31, Current Year"] * FOR ( DATETIME date IN @"24:00:00 May 31, Current Year" TO @"24:00:00 June 30, Current Year" ) STAT_SUM
         $ "NavajoData.NIIPMonthlyDistribution" [date]
      ENDFOR - AprEvap, 1976849.00000000 "acre-ft" ) ) * $ "Navajo.Evaporation Coefficients" [5.00000000, 0.00000000], @"24:00:00 June 30, Current Year" ) DO
         WITH NUMERIC JunEvap = "FlowToVolume"( "StorageToArea"( % "Navajo", "Min"( $ "Navajo.Storage" [@"t - 1"] + "AnticipatedInflowNavajo"( @"24:00:00 May 31, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" ) - FOR ( DATETIME date IN "GetDates"( @"24:00:00 May 31, Current Year", @"24:00:00 July Max DayOfMonth, Current Year", "1 Months" ) ) WITH NUMERIC result = 0.00000000 "acre-ft" DO
            result + "FlowToVolume"( $ "NavajoData.BaseRelease" [], date )
         ENDFOR - $ "NavajoData.NIIPAnnualRequest" [@"24:00:00 December 31, Current Year"] * FOR ( DATETIME date IN @"24:00:00 May 31, Current Year" TO @"24:00:00 July Max DayOfMonth, Current Year" ) STAT_SUM
            $ "NavajoData.NIIPMonthlyDistribution" [date]
         ENDFOR - MayEvap, 1976849.00000000 "acre-ft" ) ) * $ "Navajo.Evaporation Coefficients" [6.00000000, 0.00000000], @"24:00:00 July 31, Current Year" ) DO
            AprEvap + MayEvap + JunEvap
         ENDWITH
      ENDWITH
   ENDWITH;

    END;

    FUNCTION       "IsLowFlowAdjustmentNecessary" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      FOR ( DATETIME date IN "GetDates"( @"t", "DateMin"( @"24:00:00 February Max DayOfMonth, Current Year + 12", @"Finish Timestep" ), "1 months" ) ) WITH BOOLEAN result = FALSE DO
      IF ( $ "Navajo.Pool Elevation" [date] < $ "NavajoData.MinDesiredPoolElevation" [] )
      THEN
         TRUE
      ELSE
         result
      ENDIF
   ENDFOR;

    END;

    FUNCTION       "MaxDayOfMonth" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WITH NUMERIC MoNum = "GetMonth"( date ) DO
      IF ( MoNum == 1.00000000 )
      THEN
         "OffsetDate"( date, "Units NONE"( 31.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
      ELSE
         IF ( MoNum == 2.00000000 )
         THEN
            IF ( "LeapYear"( date ) )
            THEN
               "OffsetDate"( date, "Units NONE"( 60.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
            ELSE
               "OffsetDate"( date, "Units NONE"( 59.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
            ENDIF
         ELSE
            IF ( MoNum == 3.00000000 )
            THEN
               IF ( "LeapYear"( date ) )
               THEN
                  "OffsetDate"( date, "Units NONE"( 91.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
               ELSE
                  "OffsetDate"( date, "Units NONE"( 90.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
               ENDIF
            ELSE
               IF ( MoNum == 4.00000000 )
               THEN
                  IF ( "LeapYear"( date ) )
                  THEN
                     "OffsetDate"( date, "Units NONE"( 121.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
                  ELSE
                     "OffsetDate"( date, "Units NONE"( 120.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
                  ENDIF
               ELSE
                  IF ( MoNum == 5.00000000 )
                  THEN
                     IF ( "LeapYear"( date ) )
                     THEN
                        "OffsetDate"( date, "Units NONE"( 152.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
                     ELSE
                        "OffsetDate"( date, "Units NONE"( 151.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
                     ENDIF
                  ELSE
                     IF ( MoNum == 6.00000000 )
                     THEN
                        IF ( "LeapYear"( date ) )
                        THEN
                           "OffsetDate"( date, "Units NONE"( 182.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
                        ELSE
                           "OffsetDate"( date, "Units NONE"( 181.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
                        ENDIF
                     ELSE
                        IF ( MoNum == 7.00000000 )
                        THEN
                           IF ( "LeapYear"( date ) )
                           THEN
                              "OffsetDate"( date, "Units NONE"( 213.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
                           ELSE
                              "OffsetDate"( date, "Units NONE"( 212.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
                           ENDIF
                        ELSE
                           IF ( MoNum == 8.00000000 )
                           THEN
                              IF ( "LeapYear"( date ) )
                              THEN
                                 "OffsetDate"( date, "Units NONE"( 244.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
                              ELSE
                                 "OffsetDate"( date, "Units NONE"( 243.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
                              ENDIF
                           ELSE
                              IF ( MoNum == 9.00000000 )
                              THEN
                                 IF ( "LeapYear"( date ) )
                                 THEN
                                    "OffsetDate"( date, "Units NONE"( 274.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
                                 ELSE
                                    "OffsetDate"( date, "Units NONE"( 273.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
                                 ENDIF
                              ELSE
                                 IF ( MoNum == 10.00000000 )
                                 THEN
                                    IF ( "LeapYear"( date ) )
                                    THEN
                                       "OffsetDate"( date, "Units NONE"( 305.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
                                    ELSE
                                       "OffsetDate"( date, "Units NONE"( 304.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
                                    ENDIF
                                 ELSE
                                    IF ( MoNum == 11.00000000 )
                                    THEN
                                       IF ( "LeapYear"( date ) )
                                       THEN
                                          "OffsetDate"( date, "Units NONE"( 335.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
                                       ELSE
                                          "OffsetDate"( date, "Units NONE"( 334.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
                                       ENDIF
                                    ELSE
                                       IF ( "LeapYear"( date ) )
                                       THEN
                                          "OffsetDate"( date, "Units NONE"( 366.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
                                       ELSE
                                          "OffsetDate"( date, "Units NONE"( 365.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
                                       ENDIF
                                    ENDIF
                                 ENDIF
                              ENDIF
                           ENDIF
                        ENDIF
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDIF
   ENDWITH;

    END;

    FUNCTION       "NavDateOfBaseFlowAfterPeak" (  )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      IF ( "GetMonth"( @"t" ) >= 10.00000000 )
   THEN
      "CompletePartialDate"( "NumberToDate"( $ "NavajoData.SpringPeakFlowDate" [@"24:00:00 December 31, Current Year + 12"] ), @"24:00:00 December 31, Current Year + 12" ) + % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT ( $ "NavajoData.ReleaseLevel" [@"24:00:00 December 31, Current Year"] ) ) [@"24:00:00 December 31, Current Year", 3.00000000]
   ELSE
      "CompletePartialDate"( "NumberToDate"( $ "NavajoData.SpringPeakFlowDate" [@"24:00:00 December 31, Current Year"] ), @"24:00:00 December 31, Current Year" ) + % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT ( $ "NavajoData.ReleaseLevel" [@"24:00:00 December 31, Current Year"] ) ) [@"24:00:00 December 31, Current Year", 3.00000000] COMMENTED_BY "These are the number of days after the peak of peak and ramp down flow, the goal is to add the additional release if needed after the ramping flow ends<br>"
   ENDIF;

    END;

    FUNCTION       "NavEndStorWithEvap" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      "PrevStorage"( % "Navajo" ) + IF ( "GetMonth"( @"t" ) >= 10.00000000 )
   THEN
      "AnticipatedInflowNavajo"( @"t", @"24:00:00 September Max DayOfMonth, Current Year + 12" )
   ELSE
      "AnticipatedInflowNavajo"( @"t", @"24:00:00 September Max DayOfMonth, Current Year" )
   ENDIF - IF ( "GetMonth"( @"t" ) >= 10.00000000 )
   THEN
      "SumFlowsToVolume"( $ "NavajoData.NavajoOutflowWithScale", "OffsetDate"( @"t", "GetDaysInMonth"( @"t" ) / - 1.00000000 "day" + 1.00000000, "1 days" ), @"24:00:00 September Max DayOfMonth, Current Year + 12" )
   ELSE
      "SumFlowsToVolume"( $ "NavajoData.NavajoOutflowWithScale", "OffsetDate"( @"t", "GetDaysInMonth"( @"t" ) / - 1.00000000 "day" + 1.00000000, "1 days" ), @"24:00:00 September Max DayOfMonth, Current Year" )
   ENDIF - IF ( "GetMonth"( @"t" ) >= 10.00000000 )
   THEN
      $ "NavajoData.NIIPAnnualRequest" [@"24:00:00 December 31, Current Year + 12"] * FOR ( DATETIME date IN @"t" TO @"24:00:00 September 30, Current Year + 12" ) STAT_SUM
         $ "NavajoData.NIIPMonthlyDistribution" [date]
      ENDFOR
   ELSE
      $ "NavajoData.NIIPAnnualRequest" [@"24:00:00 December 31, Current Year"] * FOR ( DATETIME date IN @"t" TO @"24:00:00 September 30, Current Year" ) STAT_SUM
         $ "NavajoData.NIIPMonthlyDistribution" [date]
      ENDFOR
   ENDIF - "NavEvap"(  );

    END;

    FUNCTION       "NavEvap" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      IF ( "GetMonth"( @"t" ) >= 10.00000000 )
   THEN
      "EstimateEvaporation"( % "Navajo", "PrevStorage"( % "Navajo" ), "NavStorageWithoutEvap"(  ), @"t", @"24:00:00 September Max DayOfMonth, Current Year + 12" )
   ELSE
      "EstimateEvaporation"( % "Navajo", "PrevStorage"( % "Navajo" ), "NavStorageWithoutEvap"(  ), @"t", @"24:00:00 September Max DayOfMonth, Current Year" )
   ENDIF;

    END;

    FUNCTION       "NavStorageWithoutEvap" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      "PrevStorage"( % "Navajo" ) + IF ( "GetMonth"( @"t" ) >= 10.00000000 )
   THEN
      "AnticipatedInflowNavajo"( @"t", @"24:00:00 September Max DayOfMonth, Current Year + 12" )
   ELSE
      "AnticipatedInflowNavajo"( @"t", @"24:00:00 September Max DayOfMonth, Current Year" )
   ENDIF - IF ( "GetMonth"( @"t" ) >= 10.00000000 )
   THEN
      "SumFlowsToVolume"( $ "NavajoData.NavajoOutflowWithScale", "OffsetDate"( @"t", "GetDaysInMonth"( @"t" ) / - 1.00000000 "day" + 1.00000000, "1 days" ), @"24:00:00 September Max DayOfMonth, Current Year + 12" )
   ELSE
      "SumFlowsToVolume"( $ "NavajoData.NavajoOutflowWithScale", "OffsetDate"( @"t", "GetDaysInMonth"( @"t" ) / - 1.00000000 "day" + 1.00000000, "1 days" ), @"24:00:00 September Max DayOfMonth, Current Year" )
   ENDIF - IF ( "GetMonth"( @"t" ) >= 10.00000000 )
   THEN
      $ "NavajoData.NIIPAnnualRequest" [@"24:00:00 December 31, Current Year + 12"] * FOR ( DATETIME date IN @"t" TO @"24:00:00 September 30, Current Year + 12" ) STAT_SUM
         $ "NavajoData.NIIPMonthlyDistribution" [date]
      ENDFOR
   ELSE
      $ "NavajoData.NIIPAnnualRequest" [@"24:00:00 December 31, Current Year"] * FOR ( DATETIME date IN @"t" TO @"24:00:00 September 30, Current Year" ) STAT_SUM
         $ "NavajoData.NIIPMonthlyDistribution" [date]
      ENDFOR
   ENDIF;

    END;

    FUNCTION       "PeakReleaseatNavajo" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This function uses the number of days proir to the peak date that the ramping and peak flows are suggested to happen and applies them in a way that the appropriate flows are calculated for the release. <br><br>The equation of Ceiling (.....)*RampUp/DwnIncrease/Decrease+Constant   is the equation used to apply values to a date if it is within the appropriate ramp up, max flow and ramp down dates.  The information for this table is found in the NavajoData.DaysOfSpringRelease Table. <br><br>TP May31/2012<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH DATETIME PeakDate = "CompletePartialDate"( "NumberToDate"( $ "NavajoData.SpringPeakFlowDate" [@"24:00:00 December 31, Current Year"] ), @"24:00:00 December 31, Current Year" ) DO
      WITH NUMERIC level = $ "NavajoData.ReleaseLevelforTEoYPE" [@"24:00:00 December 31, Current Year"] DO
         WITH NUMERIC DaysBeforePeakOfRamp = % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT level ) [@"24:00:00 December 31, Current Year", 0.00000000] DO
            WITH NUMERIC DaysBeforePeakOfPeak = % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT level ) [@"24:00:00 December 31, Current Year", 1.00000000] DO
               WITH NUMERIC DaysAfterPeakOfPeak = % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT level ) [@"24:00:00 December 31, Current Year", 2.00000000] DO
                  WITH NUMERIC DaysAfterPeakofRampDwn = % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT level ) [@"24:00:00 December 31, Current Year", 3.00000000] DO
                     WITH NUMERIC NumberOfDaysatFlowRmpUp = % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT level ) [@"24:00:00 December 31, Current Year", 4.00000000] DO
                        WITH NUMERIC NumberOfDaysFlowRmpDwn = % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT level ) [@"24:00:00 December 31, Current Year", 5.00000000] DO
                           WITH NUMERIC RampUpIncrease = % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT level ) [@"24:00:00 December 31, Current Year", 6.00000000] DO
                              WITH NUMERIC RampDwnDecrease = % "NavajoData" & ( "DaysOfSpringReleaseLevel" CONCAT level ) [@"24:00:00 December 31, Current Year", 7.00000000] DO
                                 IF ( date >= PeakDate - DaysBeforePeakOfRamp AND date < PeakDate - DaysBeforePeakOfPeak )
                                 THEN
                                    "Ceiling"( ( date + ( DaysBeforePeakOfRamp + 1.00000000 "day" ) - PeakDate ) / NumberOfDaysatFlowRmpUp, 1.00000000 ) * RampUpIncrease + IF ( RampUpIncrease < 1000.00000000 "cfs" )
                                    THEN
                                       $ "NavajoData.BaseRelease" []
                                    ELSE
                                       0.00000000 "cfs"
                                    ENDIF
                                 ELSE
                                    IF ( date >= PeakDate - DaysBeforePeakOfPeak AND date <= PeakDate + DaysAfterPeakOfPeak )
                                    THEN
                                       $ "NavajoData.SpringPeakRelease" []
                                    ELSE
                                       IF ( date > PeakDate + DaysAfterPeakOfPeak AND date <= PeakDate + DaysAfterPeakofRampDwn )
                                       THEN
                                          "Ceiling"( ( PeakDate + ( DaysAfterPeakofRampDwn + 1.00000000 "day" ) - date ) / NumberOfDaysFlowRmpDwn, 1.00000000 ) * RampDwnDecrease + $ "NavajoData.BaseRelease" []
                                       ELSE
                                          0.00000000 "cfs"
                                       ENDIF
                                    ENDIF
                                 ENDIF
                              ENDWITH
                           ENDWITH
                        ENDWITH
                     ENDWITH
                  ENDWITH
               ENDWITH
            ENDWITH
         ENDWITH
      ENDWITH
   ENDWITH;

    END;

    FUNCTION       "Releaseof166KLastYear" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      IF ( NaNToZero ( $ "NavajoData.ReleaseLevel" [@"24:00:00 December Max DayOfMonth, Current Year - 12"] ) == 2.00000000 )
   THEN
      TRUE
   ELSE
      FALSE
   ENDIF;

    END;

    FUNCTION       "ReleaseLastYear" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      IF ( $ "NavajoData.ReleaseLevel" [@"24:00:00 December Max DayOfMonth, Current Year - 12"] > 0.00000000 )
   THEN
      TRUE
   ELSE
      FALSE
   ENDIF;

    END;

    FUNCTION       "Releaseof356KLast3Years" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      IF ( NaNToZero ( $ "NavajoData.ReleaseLevel" [@"24:00:00 December Max DayOfMonth, Current Year - 12"] ) == 3.00000000 OR NaNToZero ( $ "NavajoData.ReleaseLevel" [@"24:00:00 December Max DayOfMonth, Current Year - 24"] ) == 3.00000000 OR NaNToZero ( $ "NavajoData.ReleaseLevel" [@"24:00:00 December Max DayOfMonth, Current Year - 36"] ) == 3.00000000 )
   THEN
      TRUE
   ELSE
      FALSE
   ENDIF;

    END;

    FUNCTION       "SumNavajoBaseRelease" ( DATETIME dateToProject )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      FOR ( DATETIME date IN @"t + 1" TO dateToProject ) WITH NUMERIC result = 0.00000000 "acre-ft" DO
      result + "FlowToVolume"( $ "NavajoData.BaseRelease" [], date )
   ENDFOR COMMENTED_BY "Determines the volume released from @t+1 through September, Current Year<br>if Navajo is releaseing only the  Base Release.  @t+1 because the current <br>month's inflow has already been accounted for by RiverWare and has <br>impacted Navajo's storage @t.  ";

    END;

    FUNCTION       "SumNavajoBaseRelease_New" ( DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      FOR ( DATETIME date IN startDate TO endDate ) WITH NUMERIC result = 0.00000000 "acre-ft" DO
      result + "FlowToVolume"( $ "NavajoData.BaseRelease" [], date )
   ENDFOR COMMENTED_BY "Determines the volume released from @t+1 through enddate, Current Year<br>if Navajo is releaseing only the  Base Release.    ";

    END;

    FUNCTION       "SumNavajoBaseReleaseAtoJ" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      FOR ( DATETIME date IN @"24:00:00 April 1, Current Year" TO @"24:00:00 July 31, Current Year" ) WITH NUMERIC result = 0.00000000 "acre-ft" DO
      result + "FlowToVolume"( $ "NavajoData.BaseRelease" [], date )
   ENDFOR COMMENTED_BY "Determines the volume released from April 1 to July 31 for the year being analyzed, next year<br>if Navajo is releaseing only the  Base Release.    ";

    END;

    FUNCTION       "WaterToAchieveEOYTPE" ( DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WITH NUMERIC availWatWithEvap = $ "Navajo.Storage" [@"t - 1"] + "AnticipatedInflowNavajo"( @"t", endDate ) - "SumNavajoBaseRelease_New"( @"t", endDate ) - "ElevationToStorage"( % "Navajo", $ "NavajoData.EOWYTargetPE" [] ) - FOR ( DATETIME niipDate IN @"t" TO endDate ) WITH NUMERIC niipVol = 0.00000000 "acre-ft" DO
      "FlowToVolume"( $ "NavajoIndianIrrigationProjectNIIP.Diversion Requested" [niipDate], niipDate ) + niipVol
   ENDFOR - "EstimateEvaporationNavajo"( @"t", endDate ) DO
      availWatWithEvap
   ENDWITH;

    END;

    FUNCTION       "WaterAvialable" ( DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WITH NUMERIC availWatWithEvap = $ "Navajo.Storage" [@"t - 1"] + "AnticipatedInflowNavajo"( @"t", endDate ) - "SumNavajoBaseRelease_New"( @"t", endDate ) - $ "NavajoData.DevelopmentStorageAmount" [] - FOR ( DATETIME niipDate IN @"t" TO endDate ) WITH NUMERIC niipVol = 0.00000000 "acre-ft" DO
      "FlowToVolume"( $ "NavajoIndianIrrigationProjectNIIP.Diversion Requested" [niipDate], niipDate ) + niipVol
   ENDFOR - "EstimateEvaporationNavajo"( @"t", endDate ) DO
      "Max"( availWatWithEvap, 0.00000000 "acre-ft" )
   ENDWITH;

    END;

  END;

  UTILITY_GROUP "Flaming Gorge Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  BEGIN

    FUNCTION       "DaysToDownramp" ( NUMERIC PPC, NUMERIC Baseflow, NUMERIC Rate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Calcualtes the number of days required to downramp from powerplant capacity to baseflow. Baseflow is set by the current hydrologic classification. The unit business is because riverware cannot currently do calculations with the FlowPerTime unit. ";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      ( ( PPC - Baseflow ) / ( Rate / 1.00000000 "day" ) ) COMMENTED_BY "Assuming we are downramping from power plant capacity";

    END;

    FUNCTION       "DaysToRampUp" ( NUMERIC PPC, NUMERIC Baseflow, NUMERIC Rate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "The number of days to ramp up are determined by either the powerplant capacity minus the baseflow divided by the ramp up rate, or 0, whichever is greater. -CE 6/12/13";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      "Max"( ( PPC - Baseflow ) / ( Rate / 1.00000000 "day" ), 0.00000000 "day" );

    END;

    FUNCTION       "ForecastComputeDemandsBelow" ( OBJECT reservoir, DATETIME month )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    MAX_CONSTRAINT "GetMaxRelease"( reservoir );
    BEGIN

      IF ( month <= "RunEndDate"(  ) )
   THEN
      "Max"( "NetSubBasinDiversionRequirement"( "ListSubbasin"( "Below" CONCAT STRINGIFY reservoir ), month ), 0.00000000 "acre-feet/month" )
   ELSE
      "Max"( "NetSubBasinDiversionRequirement"( "ListSubbasin"( "Below" CONCAT STRINGIFY reservoir ), "GetDate"( "GetMonthAsString"( month ) CONCAT ", " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( "RunEndDate"(  ) ), "." ) ) ), 0.00000000 "acre-feet/month" )
   ENDIF;

    END;

    FUNCTION       "ForecastComputeOutflowAtRuleCurveStorage" ( OBJECT reservoir, DATETIME month, NUMERIC previousStorage )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    MAX_CONSTRAINT "GetMaxRelease"( reservoir );
    MIN_CONSTRAINT "GetMinRelease"( reservoir );
    BEGIN

      ( previousStorage - "RuleCurveStorage"( reservoir, month ) ) / 1.00000000 "month" + reservoir & "Inflow" [month] - "VolumeToFlow"( "EstimateEvaporation"( reservoir, previousStorage, previousStorage, month, month ), month );

    END;

    FUNCTION       "ForecastComputeStorageAtGivenOutflow" ( OBJECT reservoir, NUMERIC outflow, DATETIME month, NUMERIC previousStorage )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    MIN_CONSTRAINT "InactiveCapacity"( reservoir );
    MAX_CONSTRAINT "LiveCapacity"( reservoir );
    BEGIN

      IF ( previousStorage + "FlowToVolume"( reservoir & "Inflow" [month], month ) - ( "FlowToVolume"( outflow, month ) + "EstimateEvaporation"( reservoir, previousStorage, previousStorage, month, month ) ) < 0.00000000 "acre-ft" )
   THEN
      "InactiveCapacity"( reservoir )
   ELSE
      "LiveCapacity"( reservoir ) - "FlowToVolume"( outflow, month ) - "EstimateEvaporation"( reservoir, previousStorage, previousStorage, month, month )
   ENDIF;

    END;

    FUNCTION       "ForecastFontenelleRelease" ( DATETIME startMonth, DATETIME endMonth )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WITH NUMERIC totalMonths = IF ( "GetMonth"( endMonth ) - "GetMonth"( startMonth ) < 0.00000000 )
   THEN
      12.00000000 - "Abs"( "GetMonth"( endMonth ) - "GetMonth"( startMonth ) )
   ELSE
      "GetMonth"( endMonth ) - "GetMonth"( startMonth )
   ENDIF DO
      FOR ( NUMERIC month IN "GetNumbers"( 0.00000000, totalMonths, 1.00000000 ) ) WITH LIST result = { { $ "Fontenelle.Storage" ["OffsetDate"( startMonth, - 1.00000000, "1 MONTHS" )] } COMMENTED_BY "the previous storage" , {  } COMMENTED_BY "The new outflow " } DO
         WITH DATETIME currentDate = "OffsetDate"( startMonth, month, "1 MONTHS" ) DO
            WITH NUMERIC newStorage = "ForecastComputeStorageAtGivenOutflow"( % "Fontenelle", "ForecastComputeOutflowAtRuleCurveStorage"( % "Fontenelle", currentDate, GET @INDEX month FROM GET @INDEX 0.00000000 FROM result ), currentDate, GET @INDEX month FROM GET @INDEX 0.00000000 FROM result ) DO
               { APPEND newStorage COMMENTED_BY "New, compute StorageAtGivenOutflow which takes time and previous storage as a parameter" ONTO GET @INDEX 0.00000000 FROM result , APPEND ( ( GET @INDEX month FROM GET @INDEX 0.00000000 FROM result ) - newStorage ) / 1.00000000 "month" + % "Fontenelle" & "Inflow" [currentDate] - "VolumeToFlow"( "EstimateEvaporation"( % "Fontenelle", GET @INDEX month FROM GET @INDEX 0.00000000 FROM result, GET @INDEX month FROM GET @INDEX 0.00000000 FROM result, currentDate, currentDate ), currentDate ) ONTO GET @INDEX 1.00000000 FROM result }
            ENDWITH
         ENDWITH
      ENDFOR
   ENDWITH;

    END;

    FUNCTION       "FutureFontenelleInflow" ( STRING month )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      ( "MonthlyAverageFlowInModel"( $ "GreenRAboveFontenelle.Inflow", month ) - "SumObjectsAggregatedOverTime"( "UsersAboveCP9", "Total Depletion Requested", "SUM", "ALL", FALSE, "GetDate"( month CONCAT ", " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( "RunEndDate"(  ) ), "." ) ), "GetDate"( month CONCAT ", " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( "RunEndDate"(  ) ), "." ) ) ) ) COMMENTED_BY "Calculates the future (after the model end date) inflow into Fontenelle based on <br>average natural flow above Fontenelle for the particular month, and the demands <br>above Fontenelle from the last year of the model run.";

    END;

    FUNCTION       "GetDaysAtBypass" ( NUMERIC HClass )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Determines the number of days at bypass capacity. For mod dry, average and mod wet years, if the number of days that the Yampa is greater than 14000 cfs is greater than the threshold then the standard days at bypass capacity are used. If the days greater than 14000 cfs is less than the threshold then the days at bypass is zero.  For dry years the days at bypass is always zero and for wet years always bypass. -CE 6/12/13";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      IF ( HClass < 4.00000000 AND HClass > 0.00000000 )
   THEN
      IF ( "YampaDaysAbove14000"(  ) > $ "FlamingGorgeData.YampaDaysAbove14000ForBypass" [HClass, 0.00000000] )
      THEN
         $ "FlamingGorgeData.DaysAtBypassCapacity" [HClass, 0.00000000]
      ELSE
         0.00000000 "day"
      ENDIF COMMENTED_BY "If the yampa is very wet then bypass to meet peaks otherwise no bypass"
   ELSE
      IF ( HClass == 0.00000000 )
      THEN
         0.00000000 "day" COMMENTED_BY "In Dry years never bypass"
      ELSE
         $ "FlamingGorgeData.DaysAtBypassCapacity" [HClass, 0.00000000] COMMENTED_BY "In wet years always bypass"
      ENDIF
   ENDIF COMMENTED_BY "Are we in Mod Dry, Ave, or Mod Wet?";

    END;

    FUNCTION       "GetFGBaseFlowMagnitude1" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "Returns the steady base flow magnitude necessary to meet the May1 ULDE.  The magnitude is first projected as if there are no base flow limits, if the necessary base flow is outside of the limits, then the returned flow is within the limits set by the current hydrologic classification. ";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH DATETIME HClassYear = IF ( "MonthIs"( { "May" , "June" , "July" , "August" , "September" , "October" , "November" , "December" } ) OR "StartYear"(  ) COMMENTED_BY "Previous Year's April through July volume is not know during the start year of the run,<br> therefore use the current year's target. -HG 10/3/12" )
   THEN
      @"24:00:00 December Max DayOfMonth, Current Year"
   ELSE
      @"24:00:00 December Max DayOfMonth, Previous Year"
   ENDIF COMMENTED_BY "Selects the correct April through July period to be considered for basefow operations. <br>In actual operations the HClass would be based upon the previous April - July period for baseflow purposes.-HG 9/13/12" DO
      IF ( "GetFGBaseFlowMagnitudeUnconstrained"(  ) < $ "FlamingGorgeData.BaseFlowMagnitudeLimits" [$ "FlamingGorgeData.HClass" [HClassYear], 0.00000000] OR $ "FlamingGorge.Pool Elevation" [@"t - 1"] < $ "FlamingGorgeData.MinBaseFlowTriggerPE" [] )
      THEN
         $ "FlamingGorgeData.BaseFlowMagnitudeLimits" [$ "FlamingGorgeData.HClass" [HClassYear], 0.00000000] COMMENTED_BY "Lower Limit of Base Flow Range"
      ELSE
         IF ( "GetFGBaseFlowMagnitudeUnconstrained"(  ) > $ "FlamingGorgeData.BaseFlowMagnitudeLimits" [$ "FlamingGorgeData.HClass" [HClassYear], 1.00000000] )
         THEN
            $ "FlamingGorgeData.BaseFlowMagnitudeLimits" [$ "FlamingGorgeData.HClass" [HClassYear], 1.00000000] COMMENTED_BY "Upper Limit of Base Flow Range"
         ELSE
            "GetFGBaseFlowMagnitudeUnconstrained"(  ) COMMENTED_BY "Somewhere in between"
         ENDIF
      ENDIF
   ENDWITH;

    END;

    FUNCTION       "GetFGBaseFlowMagnitude" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-ft/month";
    DESCRIPTION    "Returns the steady base flow magnitude necessary to meet the May1 ULDE.  The magnitude is first projected as if there are no base flow limits, if the necessary base flow is outside of the limits, then the returned flow is within the limits set by the current hydrologic classification. ";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      IF ( "GetFGBaseFlowMagnitudeUnconstrained"(  ) < $ "FlamingGorgeData.BaseFlowMagnitudeLimits" [$ "KNN_MTOM.BaseFlowHClass" [], 0.00000000] )
   THEN
      $ "FlamingGorgeData.BaseFlowMagnitudeLimits" [$ "KNN_MTOM.BaseFlowHClass" [], 0.00000000] COMMENTED_BY "Lower Limit of Base Flow Range"
   ELSE
      IF ( "GetFGBaseFlowMagnitudeUnconstrained"(  ) > $ "FlamingGorgeData.BaseFlowMagnitudeLimits" [$ "KNN_MTOM.BaseFlowHClass" [], 1.00000000] )
      THEN
         $ "FlamingGorgeData.BaseFlowMagnitudeLimits" [$ "KNN_MTOM.BaseFlowHClass" [], 1.00000000] COMMENTED_BY "Upper Limit of Base Flow Range"
      ELSE
         "GetFGBaseFlowMagnitudeUnconstrained"(  ) COMMENTED_BY "Somewhere in between"
      ENDIF
   ENDIF;

    END;

    FUNCTION       "GetFGBaseFlowMagnitudeUnconstrained" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    ".acre-ft/month";
    DESCRIPTION    "Returns the exact steady from the current timestep to the next April to meet the May 1 ULDE regardless of base flow restrictions. ";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      IF ( "MonthIs"( { "March" , "April" } ) )
   THEN
      "Max"( "VolumeToFlow"( ( "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorge.Pool Elevation" [@"t - 1"] ) - "ElevationToStorage"( % "FlamingGorge", "GetMay1TargetElevation"(  ) ) + "PredictedFGInflow"( @"24:00:00 Current Month Max DayOfMonth, Current Year", @"24:00:00 April Max DayOfMonth, Current Year" ) ) / "NumberOfMonthsUntilMay"(  ), @"t" ), $ "FlamingGorgeData.MinFlow" [] )
   ELSE
      IF ( "MonthIs"( { "May" , "June" , "July" , "August" , "September" , "October" , "November" , "December" } ) )
      THEN
         "Max"( "VolumeToFlow"( ( "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorge.Pool Elevation" [@"t - 1"] ) - "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorgeData.May1TargetElevation" [0.00000000, 2.00000000] ) COMMENTED_BY "May 1 ULDE (Always 6027 FT until March and where it may be adjusted based upon the Percent Exceedence. -From Heather H.  -HG 5/24/2013" + "PredictedFGInflow"( @"24:00:00 Current Month Max DayOfMonth, Current Year", @"24:00:00 April Max DayOfMonth, Next Year" ) ) / "NumberOfMonthsUntilMay"(  ), @"t" ), $ "FlamingGorgeData.MinFlow" [] )
      ELSE
         "Max"( "VolumeToFlow"( ( "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorge.Pool Elevation" [@"t - 1"] ) - "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorgeData.May1TargetElevation" [0.00000000, 2.00000000] ) COMMENTED_BY "March 1 soft baseflow target is always a pool elevation of 6027 FT. During March this target may be adjusted based upon the Percent Exceedence to get the actual May 1 ULDE. -From Heather Hermansen  -HG 5/24/2013" + "PredictedFGInflow"( @"24:00:00 Current Month Max DayOfMonth, Current Year", @"24:00:00 April Max DayOfMonth, Current Year" ) ) / "NumberOfMonthsUntilMay"(  ), @"t" ), $ "FlamingGorgeData.MinFlow" [] ) COMMENTED_BY "January and February."
      ENDIF
   ENDIF COMMENTED_BY " In actual operations, at March a new forecast would come out for the next April through<br> July volume so we adjust the May 1 ULDE then. For all other months besides March and April<br> the May 1 ULDE is assumed to be the maximum May 1 pool elevation of 6027 FT. -HG 10/9/12";

    END;

    FUNCTION       "GetMay1TargetElevation1" ( DATETIME year )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      FOR ( NUMERIC val IN { 0.00000000 , 1.00000000 , 2.00000000 , 3.00000000 } ) WITH NUMERIC result = 6027.00000000 "ft" DO
      IF ( $ "KNN_MTOM.AprJulPercentExceedanceSpringFlow" ["Dec31ofYear"( year )] * 100.00000000 <= $ "FlamingGorgeData.May1TargetElevation" [val, 1.00000000] )
      THEN
         $ "FlamingGorgeData.May1TargetElevation" [val, 2.00000000]
      ELSE
         result
      ENDIF COMMENTED_BY "Check if the inflow forecast percent exceedance is within the <br>range in the target elevation table"
   ENDFOR;

    END;

    FUNCTION       "GetMay1TargetElevation" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      $ "FlamingGorgeData.May1TargetElevation" [IF ( WHILE ( $ "KNN_MTOM.AprJulPercentExceedanceSpringFlow" [] * 100.00000000 < $ "FlamingGorgeData.May1TargetElevation" [result, 1.00000000] AND result <= 2.00000000 ) WITH NUMERIC result = 0.00000000 DO
      result + 1.00000000
   ENDWHILE == 0.00000000 )
   THEN
      0.00000000
   ELSE
      WHILE ( $ "KNN_MTOM.AprJulPercentExceedanceSpringFlow" [] * 100.00000000 < $ "FlamingGorgeData.May1TargetElevation" [result, 1.00000000] AND result <= 2.00000000 ) WITH NUMERIC result = 0.00000000 DO
         result + 1.00000000
      ENDWHILE - 1.00000000
   ENDIF, 2.00000000];

    END;

    FUNCTION       "GetNumberOfDaysAtPPC" ( NUMERIC Class )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This function bounds the days at power plant capacity to within the limts for the current hydrologic classification. -CE 6/12/13";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WITH NUMERIC DaysAtPPC = "GetNumberOfDaysAtPPCUnconstrained"( Class ) DO
      IF ( DaysAtPPC < $ "FlamingGorgeData.DaysAtPowerPlantCapacity" [Class, 0.00000000] )
      THEN
         $ "FlamingGorgeData.DaysAtPowerPlantCapacity" [Class, 0.00000000]
      ELSE
         IF ( DaysAtPPC > $ "FlamingGorgeData.DaysAtPowerPlantCapacity" [Class, 1.00000000] )
         THEN
            $ "FlamingGorgeData.DaysAtPowerPlantCapacity" [Class, 1.00000000]
         ELSE
            DaysAtPPC
         ENDIF
      ENDIF
   ENDWITH COMMENTED_BY "Ensure that the days at power plant capacity fall within the <br>limits of the current hydrolocic classification";

    END;

    FUNCTION       "GetNumberOfDaysAtPPCUnconstrained" ( NUMERIC Class )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Interpolates the number of days to have the powerplant at capacity for the current hydrologic classification based on the current exceedance percentile for the Yampa April through July volume. -CE 6/12/13";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      "Interpolate"( $ "KNN_MTOM.AprJulPercentExceedanceSpringFlow" [], $ "FlamingGorgeData.HydrologicClassPercentileLimits" [Class, 0.00000000], $ "FlamingGorgeData.HydrologicClassPercentileLimits" [Class, 1.00000000], $ "FlamingGorgeData.DaysAtPowerPlantCapacity" [Class, 1.00000000], $ "FlamingGorgeData.DaysAtPowerPlantCapacity" [Class, 0.00000000] );

    END;

    FUNCTION       "NumberOfMonthsUntilMay" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This function calculates the number of months remaining to make releases to meet the May 1 Upper Limit Drawdown Elevation (ULDE) on Flaming Gorge reservoir.<br><br>This is called by the Flaming Gorge baseflow operations. -HG 9/12/12";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      IF ( "GetMonth"( @"t" ) >= 5.00000000 )
   THEN
      ( 12.00000000 - "GetMonth"( @"t - 1" ) + 4.00000000 ) COMMENTED_BY "For May through December.<br>Calculate the remaining months of current year (current month - Dec.)<br>Add the first four months of next year (Jan.- Apr.).<br>"
   ELSE
      ( 5.00000000 - "GetMonth"( @"t" ) ) COMMENTED_BY "For January through April.<br>Calculate the remaining months to make releases before May 1, <br>includes the current month."
   ENDIF;

    END;

    FUNCTION       "PredictedFGInflow" ( DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      IF ( endDate > @"Finish Timestep" )
   THEN
      "SumFlowsToVolume"( $ "FlamingGorge.Inflow", startDate, @"Finish Timestep" ) + "SumFlowsToVolume"( $ "FlamingGorgeData.ProjectedInflow", @"Finish Timestep + 1", endDate )
   ELSE
      "SumFlowsToVolume"( $ "FlamingGorge.Inflow", startDate, endDate )
   ENDIF;

    END;

    FUNCTION       "RoundToNearestDay" ( NUMERIC numDays )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      IF ( "Fraction"( numDays, 1.00000000 "day" ) >= 0.50000000 "day" )
   THEN
      "Ceiling"( numDays, 1.00000000 "day" )
   ELSE
      "Floor"( numDays, 1.00000000 "day" )
   ENDIF;

    END;

    FUNCTION       "SpringDateAndFlowLists" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WITH NUMERIC HClass = $ "FlamingGorgeData.HClass" ["Dec31ofYear"( @"t" )] DO
      WITH NUMERIC PPC = $ "FlamingGorgeData.PowerPlantCapacity" [] DO
         WITH NUMERIC PreviousBaseflow = $ "FlamingGorge.Outflow" [@"24:00:00 April Max DayOfMonth, Current Year"] COMMENTED_BY "Set By Rule: &quot;Base Flow Operations&quot;" DO
            WITH NUMERIC Baseflow = "GetFGBaseFlowMagnitude"(  ) DO
               WITH NUMERIC BypassCapacity = $ "FlamingGorgeData.BypassCharacteristics" [0.00000000, "Bypass Capacity"] DO
                  WITH NUMERIC RampUpRate = $ "FlamingGorgeData.RampUpRate" [] DO
                     WITH NUMERIC RampDownRate = $ "FlamingGorgeData.BaseFlowDownrampRate" [HClass, 0.00000000] DO
                        WITH NUMERIC DaysAtPPC = "GetNumberOfDaysAtPPC"( HClass ) DO
                           WITH NUMERIC DaysToRampUp = "DaysToRampUp"( PPC, PreviousBaseflow, RampUpRate ) DO
                              WITH NUMERIC DaysToRampDown = "DaysToDownramp"( PPC, Baseflow, RampDownRate ) DO
                                 WITH NUMERIC DaysToBypass = "GetDaysAtBypass"( HClass ) DO
                                    WITH DATETIME RampUpStartDate = "CompletePartialDate"( "NumberToDate"( $ "FlamingGorgeData.RampUpStartDate" [0.00000000, 0.00000000] ), @"t" ) COMMENTED_BY "User Input Ramp Up Start Date, should correspond with the Yampa Peak. -HG 9/13/12" DO
                                       WITH DATETIME PPCStartDate = RampUpStartDate + DaysToRampUp DO
                                          WITH DATETIME PPCEndDate = PPCStartDate + ( DaysAtPPC - 1.00000000 "day" ) DO
                                             WITH DATETIME RampDownEndDate = PPCEndDate + DaysToRampDown DO
                                                WHILE ( ( GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) < @"24:00:00 August 1, Current Year" ) WITH LIST dateFlowList = { { @"24:00:00 April 30, Current Year" , PreviousBaseflow } } DO
                                                   WITH DATETIME date = ( GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) + 1.00000000 "day" DO
                                                      WITH NUMERIC PreviousDaysFlow = ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) DO
                                                         IF ( "GetMonth"( date ) == 6.00000000 AND "GetDayOfMonth"( date ) <= DaysToBypass )
                                                         THEN
                                                            APPEND { date , BypassCapacity } ONTO dateFlowList
                                                         ELSE
                                                            IF ( date < RampUpStartDate )
                                                            THEN
                                                               APPEND { date , PreviousBaseflow } ONTO dateFlowList
                                                            ELSE
                                                               IF ( date >= RampUpStartDate AND date < PPCStartDate )
                                                               THEN
                                                                  ( APPEND { date , "Min"( PreviousDaysFlow + RampUpRate, PPC ) } ONTO dateFlowList ) COMMENTED_BY "Limit the Ramp Up to a Maximum of the Power Plant Capacity"
                                                               ELSE
                                                                  IF ( date >= PPCStartDate AND date <= PPCEndDate )
                                                                  THEN
                                                                     APPEND { date , PPC } ONTO dateFlowList
                                                                  ELSE
                                                                     IF ( date <= RampDownEndDate )
                                                                     THEN
                                                                        APPEND { date , "Max"( PreviousDaysFlow - RampDownRate, Baseflow ) } ONTO dateFlowList
                                                                     ELSE
                                                                        APPEND { date , Baseflow } ONTO dateFlowList
                                                                     ENDIF
                                                                  ENDIF
                                                               ENDIF
                                                            ENDIF
                                                         ENDIF COMMENTED_BY "Set Daily Outflows"
                                                      ENDWITH
                                                   ENDWITH
                                                ENDWHILE COMMENTED_BY "Set Daily Outflows"
                                             ENDWITH
                                          ENDWITH
                                       ENDWITH
                                    ENDWITH COMMENTED_BY "Define Dates"
                                 ENDWITH
                              ENDWITH
                           ENDWITH
                        ENDWITH COMMENTED_BY "Determine Days At Each Rate"
                     ENDWITH
                  ENDWITH
               ENDWITH
            ENDWITH COMMENTED_BY "This is a problem. <br>We do not know what the baseflow is going to be at the end of the spring release operations. <br>The baseflow is calculated based upon the Previous Pool Elevation and we do not know that<br>when projecting forward. -HG 9/13/12"
         ENDWITH
      ENDWITH
   ENDWITH COMMENTED_BY "Define Flow Rates";

    END;

    FUNCTION       "TargetHWGivenInflowforOneMonth" ( NUMERIC elevation )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      ( ( "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorge.Pool Elevation" [@"t - 1"] ) - "ElevationToStorage"( % "FlamingGorge", elevation ) + "FlowToVolume"( $ "FlamingGorge.Inflow" [], @"t" ) ) - "EstimateEvaporation"( % "FlamingGorge", $ "FlamingGorge.Storage" [@"t - 1"], $ "FlamingGorge.Storage" [@"t - 1"], @"24:00:00 Current Month Max DayOfMonth, Current Year", @"24:00:00 Current Month Max DayOfMonth, Current Year" ) ) / 1.00000000 "month";

    END;

    FUNCTION       "YampaDaysAbove14000Old" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Determines the number of days that the Yampa River will be above 14000 cfs. If the Yampa April to July volume is greater than the bypass threshold then the number of days above 14000 cfs is determined with a linear regression equation based on data for the historical period 1923-2006. For volumes less than the bypass threshold the number of days above 14000 cfs is zero. -CE 6/12/13";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      IF ( $ "FlamingGorgeData.YampaAprJulVol" [] > $ "FlamingGorgeData.BypassCharacteristics" [0.00000000, "Bypass Threshold"] )
   THEN
      ( 0.03000000 "day/acre-ft" * ( $ "FlamingGorgeData.YampaAprJulVol" [] / 1000.00000000 ) - 25.81000000 "day" ) COMMENTED_BY "These coefficients are from a regression of Yampa Apr-July volume <br>versus days above 14000 cfs for the historical period 1923-2006"
   ELSE
      0.00000000 "day"
   ENDIF;

    END;

    FUNCTION       "YampaDaysAbove14000" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Determines the number of days that the Yampa River will be above 14000 cfs. If the Yampa April to July volume is greater than the bypass threshold then the number of days above 14000 cfs is determined with a linear regression equation based on data for the historical period 1923-2006. For volumes less than the bypass threshold the number of days above 14000 cfs is zero. -CE 6/12/13";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      "CountDaysAboveThreshold"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year" ), 14000.00000000 "cfs" );

    END;

  END;

  UTILITY_GROUP "Daily Flaming Gorge Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  BEGIN

    FUNCTION       "MakeDailyFlamingGorgeReleaseDateandFlowList" ( DATETIME startdate )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WITH LIST DateList = "GetDates"( @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year" COMMENTED_BY "Only calculates daily schedule to the end of the current month for computation efficiency.", "1 days" ) DO
      WITH LIST FlowList = WITH DATETIME YampaPeakDate = IF ( TRUE )
      THEN
         "FindYampaPeakDateForYear"(  )
      ELSE
         @"24:00:00 May 27, Current Year"
      ENDIF COMMENTED_BY "Finds the Yampa peak flow date for this year, change if to FALSE to use May 27 which matches it with the dates that the expression slot was using..." DO
         WITH NUMERIC DaysAtPPC = "Max"( "RoundToNearestDay"( "GetNumberOfDaysAtPPC"( $ "KNN_MTOM.SpringHClass" [@"t"] ) ), 1.00000000 "day" ) COMMENTED_BY "Calculate number of days that Flaming Gorge will release Power Plant Capacity (PPC), with a minimum of 1 day at PPC to meet flow recommendation, I am unsure about the minimum days in really dry years, but am using 1 for now..." DO
            WITH NUMERIC RampUpDaysToPPC = "RoundToNearestDay"( "Max"( IF ( ( $ "FlamingGorgeData.PowerPlantCapacity" [] - $ "FlamingGorge.Outflow" [@"24:00:00 Previous Month Max DayOfMonth, Current Year"] ) <= $ "KNN_MTOM.RampUpRateNoUnits" [] * 1.00000000 "cfs" )
            THEN
               0.00000000 "day"
            ELSE
               ( $ "FlamingGorgeData.PowerPlantCapacity" [] - $ "FlamingGorge.Outflow" [@"24:00:00 Previous Month Max DayOfMonth, Current Year"] ) / ( $ "KNN_MTOM.RampUpRateNoUnits" [] * 1.00000000 "cfs" / 1.00000000 "day" )
            ENDIF, 0.00000000 "day" ) ) COMMENTED_BY "Calculate the number of days that the flow will have to ramp to reach the PPC, or sets it to 0 if it can reach it in one jump." DO
               WITH NUMERIC RampUpToPPCRate = ( ( $ "FlamingGorgeData.PowerPlantCapacity" [] - $ "FlamingGorge.Outflow" [@"24:00:00 Previous Month Max DayOfMonth, Current Year"] ) / ( ( RampUpDaysToPPC / 1.00000000 "day" ) + 1.00000000 ) ) COMMENTED_BY "Calculate the up ramping rate depending on the number of days so that it evenly ramps up to PPC over those days. Will not exceed the up ramp rate limit (2000 cfs)." DO
                  WITH NUMERIC RampUpDaysToBypass = "RoundToNearestDay"( "Max"( IF ( ( $ "KNN_MTOM.BypassCapacity" [] - $ "FlamingGorge.Outflow" [@"24:00:00 Previous Month Max DayOfMonth, Current Year"] ) <= $ "KNN_MTOM.RampUpRateNoUnits" [] * 1.00000000 "cfs" )
                  THEN
                     0.00000000 "day"
                  ELSE
                     ( $ "KNN_MTOM.BypassCapacity" [] - $ "FlamingGorge.Outflow" [@"24:00:00 Previous Month Max DayOfMonth, Current Year"] ) / ( $ "KNN_MTOM.RampUpRateNoUnits" [] * 1.00000000 "cfs" / 1.00000000 "day" )
                  ENDIF, 0.00000000 "day" ) ) DO
                     WITH NUMERIC DaysToDownRamp = "RoundToNearestDay"( ( $ "FlamingGorgeData.PowerPlantCapacity" [] - 2700.00000000 "cfs" ) / ( $ "KNN_MTOM.BaseFlowDownrampRateNoUnits" [$ "KNN_MTOM.BaseFlowHClass" [@"t"], 0.00000000] * 1.00000000 "cfs" ) * 1.00000000 "day" ) DO
                        WITH NUMERIC DaysAtBypass = "RoundToNearestDay"( "GetDaysAtBypass"( $ "KNN_MTOM.SpringHClass" [] ) ) DO
                           WITH DATETIME FGSpringReleaseStartDate = "DateMax"( "DateMin"( IF ( DaysAtBypass != 0.00000000 "day" )
                           THEN
                              "FindYampa10kcfsBypassDateForYear"( DaysAtBypass, YampaPeakDate ) + $ "KNN_MTOM.FGPeakDelay" []
                           ELSE
                              "FindYampa14kcfsPPCDateForYear"( DaysAtPPC, YampaPeakDate ) + $ "KNN_MTOM.FGPeakDelay" []
                           ENDIF, @"24:00:00 August 2, Current Year" - ( DaysAtPPC + RampUpDaysToPPC + DaysToDownRamp + DaysAtBypass / 2.00000000 ) COMMENTED_BY "Estimate total spring flow days...<br>" ), @"24:00:00 April 2, Current Year" ) COMMENTED_BY "Start ramping up 3 days before Yampa Peak, but Apr 2 as a minimum to avoid breaking, and start early enough to end by July 31" DO
                              FOR ( DATETIME date IN DateList ) WITH LIST flows = {  } DO
                                 WITH NUMERIC i = ( date - @"24:00:00 April 1, Current Year" ) / 1.00000000 "day" DO
                                    APPEND IF ( date < startdate )
                                    THEN
                                       $ "FlamingGorge.Outflow" ["MaxDayOfMonth"( date )]
                                    ELSE
                                       IF ( ( date < FGSpringReleaseStartDate ) COMMENTED_BY "Before Spring Releases start continue at base flows for the ULDE in March and April that will meet ULDE on May 1" )
                                       THEN
                                          IF ( FGSpringReleaseStartDate == @"April" )
                                          THEN
                                             $ "FlamingGorge.Outflow" [@"24:00:00 March Max DayOfMonth, Current Year"]
                                          ELSE
                                             $ "FlamingGorge.Outflow" [@"24:00:00 April Max DayOfMonth, Current Year"]
                                          ENDIF
                                       ELSE
                                          IF ( ( date < FGSpringReleaseStartDate + RampUpDaysToPPC ) COMMENTED_BY "Ramping period up to Flaming Gorge PPC Release (or max release if below PPC)" )
                                          THEN
                                             "Min"( ( GET @INDEX i - 1.00000000 FROM flows ) + RampUpToPPCRate, "Max"( $ "FlamingGorgeData.PowerPlantCapacity" [], "Max"( "TargetHWGivenInflowforOneMonth"( $ "FlamingGorgeData.MaxPE" [] ), "GetFGBaseFlowMagnitude"(  ) ) ) COMMENTED_BY "Release PPC or volume necessary to stay below max PE." )
                                          ELSE
                                             IF ( "CountDaysAboveThreshold"( flows, $ "KNN_MTOM.BypassCapacity" [] ) < DaysAtBypass )
                                             THEN
                                                "Min"( ( GET @INDEX i - 1.00000000 FROM flows ) + $ "KNN_MTOM.RampUpRateNoUnits" [] * 1.00000000 "cfs", "Max"( $ "KNN_MTOM.BypassCapacity" [], "Max"( "TargetHWGivenInflowforOneMonth"( $ "FlamingGorgeData.MaxPE" [] ), "GetFGBaseFlowMagnitude"(  ) ) ) COMMENTED_BY "Release bypass capacity or volume necessary to stay below max PE." ) COMMENTED_BY "Ramps up and continues at Bypass Cap until it has been at Bypass Cap for enough days"
                                             ELSE
                                                IF ( "CountDaysAboveThreshold"( flows, $ "FlamingGorgeData.PowerPlantCapacity" [] ) < DaysAtPPC )
                                                THEN
                                                   "Max"( ( GET @INDEX i - 1.00000000 FROM flows ) - $ "KNN_MTOM.BaseFlowDownrampRateNoUnits" [$ "KNN_MTOM.BaseFlowHClass" [@"t"], 0.00000000] * 1.00000000 "cfs", "Max"( $ "FlamingGorgeData.PowerPlantCapacity" [], "TargetHWGivenInflowforOneMonth"( $ "FlamingGorgeData.MaxPE" [] ) ) COMMENTED_BY "Downramps to base flows unless inflows will increase FG above max PE.<br>Releases volume necessary to stay below max PE." ) COMMENTED_BY "Ramps down from bypass (if it was there) then continues at PPC until it has been above PPC for enough days"
                                                ELSE
                                                   "Max"( ( GET @INDEX i - 1.00000000 FROM flows ) - $ "KNN_MTOM.BaseFlowDownrampRateNoUnits" [$ "KNN_MTOM.BaseFlowHClass" [@"t"], 0.00000000] * 1.00000000 "cfs", "Max"( "GetFGBaseFlowMagnitude"(  ), "TargetHWGivenInflowforOneMonth"( $ "FlamingGorgeData.MaxPE" [] ) ) COMMENTED_BY "Releases base flows or volume necessary to stay below max PE." ) COMMENTED_BY "Ramps down from PPC and then continues at the new base flow which is newly calculated each month"
                                                ENDIF
                                             ENDIF
                                          ENDIF
                                       ENDIF
                                    ENDIF ONTO flows
                                 ENDWITH
                              ENDFOR
                           ENDWITH
                        ENDWITH
                     ENDWITH
                  ENDWITH
               ENDWITH
            ENDWITH
         ENDWITH
      ENDWITH DO
         FOR ( DATETIME date IN DateList ) WITH LIST DateFlowList = {  } DO
            APPEND { date , GET @INDEX ( date - @"24:00:00 April 1, Current Year" ) / 1.00000000 "day" FROM FlowList } ONTO DateFlowList
         ENDFOR COMMENTED_BY "This links together the date and flow in a list of 2 item lists..... e.g., &lcub;...,(5/1/12, 1200 cfs), (5/2/12, 1300 cfs), etc...&rcub;"
      ENDWITH
   ENDWITH;

    END;

    FUNCTION       "DaysAboveThreshold" ( LIST dailyFlows, NUMERIC flowThreshold )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      FOR ( NUMERIC flow IN dailyFlows ) WITH NUMERIC result = 0.00000000 "day" DO
      IF ( flow > flowThreshold )
      THEN
         1.00000000 "day"
      ELSE
         0.00000000 "day"
      ENDIF + result
   ENDFOR;

    END;

    FUNCTION       "FindYampaPeakDateForYear" (  )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WITH NUMERIC aprJulVol = FOR ( DATETIME date IN "GetDates"( @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year", "1 days" ) ) STAT_SUM
      $ "KNN_MTOM.YampaDailyDeerlodgeDepleted" [date]
   ENDFOR DO
      WITH LIST startDateList = FOR ( DATETIME stDate IN "GetDates"( @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year", "1 days" ) ) WITH LIST result = { "Null" , 0.00000000 "acre-ft/month" } DO
         WITH NUMERIC cumVol = ( GET @INDEX 1.00000000 FROM result ) + $ "KNN_MTOM.YampaDailyDeerlodgeDepleted" [stDate] DO
            IF ( cumVol / aprJulVol >= 0.50000000 )
            THEN
               { GET @INDEX 0.00000000 FROM result , cumVol }
            ELSE
               { stDate , cumVol }
            ENDIF
         ENDWITH
      ENDFOR DO
         WITH DATETIME startDate = GET @INDEX 0.00000000 FROM startDateList DO
            WITH NUMERIC yampaPeak = "MaxItem"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year" ) ) DO
               GET @INDEX FIND yampaPeak WITHIN "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year" ) FROM "GetDates"( @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year", "1 days" )
            ENDWITH
         ENDWITH
      ENDWITH
   ENDWITH;

    END;

    FUNCTION       "FindYampa10kcfsBypassDateForYear" ( NUMERIC BypassDays, DATETIME YampaPeakDate )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WITH LIST flowList = "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year" ) DO
      WITH NUMERIC DaysAbv10k = "CountDaysAboveThreshold"( flowList, 10000.00000000 "cfs" ) DO
         WITH NUMERIC DaysToRamp = "RoundToNearestDay"( ( $ "KNN_MTOM.BypassCapacity" [] - $ "FlamingGorge.Outflow" [@"24:00:00 Previous Month Max DayOfMonth, Current Year"] ) / ( $ "KNN_MTOM.RampUpRateNoUnits" [] * 1.00000000 "cfs" / 1.00000000 "day" ) ) / 1.00000000 "day" + 2.00000000 DO
            WITH NUMERIC i = LENGTH "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ) DO
               IF ( $ "KNN_MTOM.SpringHClass" [] < 4.00000000 AND $ "KNN_MTOM.SpringHClass" [] > 0.00000000 )
               THEN
                  IF ( ( DaysAbv10k >= $ "KNN_MTOM.YampaDaysAbove10000ForBypass" [$ "KNN_MTOM.SpringHClass" [], 0.00000000] OR ( $ "KNN_MTOM.SpringHClass" [] == 2.00000000 AND DaysAbv10k > 3.00000000 "day" ) ) COMMENTED_BY "Will bypass if Yampa River flows are above 10,000 cfs for days <br>necessary to meet flow targets in all hydrologic classifications or<br>in average years if Yampa River above 10,000 cfs for 3 days in <br>order to meet 18,600 cfs target 50% of the time." )
                  THEN
                     WITH NUMERIC DateIndex = FOR ( NUMERIC length IN "GetNumbers"( 0.00000000, i, 1.00000000 ) ) WITH NUMERIC result = LENGTH "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ) DO
                        IF ( ( GET @INDEX i - length FROM flowList ) >= 10000.00000000 "cfs" AND "CountDaysBelowThreshold"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", GET @INDEX IF ( i - length - 1.00000000 == - 1.00000000 )
                        THEN
                           0.00000000
                        ELSE
                           i - length - 1.00000000
                        ENDIF FROM "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ), YampaPeakDate ), 10000.00000000 "cfs" ) < 1.00000000 "day" )
                        THEN
                           i - length
                        ELSE
                           result
                        ENDIF
                     ENDFOR COMMENTED_BY "If the Yampa River is above 10,000 cfs for enough days to meet flow targets then <br>this determines the peak date of the Yampa River and returns the first date that<br>the Yampa River reaches 10,000 cfs before the peak date." DO
                        GET @INDEX IF ( DateIndex - DaysToRamp < 0.00000000 )
                        THEN
                           0.00000000
                        ELSE
                           DateIndex - DaysToRamp
                        ENDIF FROM "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" )
                     ENDWITH
                  ELSE
                     WITH NUMERIC DateIndex = FOR ( NUMERIC length IN "GetNumbers"( 0.00000000, i, 1.00000000 ) ) WITH NUMERIC result = LENGTH "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ) DO
                        IF ( ( GET @INDEX i - length FROM flowList ) >= 10000.00000000 "cfs" AND "CountDaysBelowThreshold"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", GET @INDEX IF ( i - length - 1.00000000 == - 1.00000000 )
                        THEN
                           0.00000000
                        ELSE
                           i - length - 1.00000000
                        ENDIF FROM "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ), YampaPeakDate ), 10000.00000000 "cfs" ) < 1.00000000 "day" )
                        THEN
                           i - length
                        ELSE
                           result
                        ENDIF
                     ENDFOR DO
                        GET @INDEX IF ( DateIndex - DaysToRamp < 0.00000000 )
                        THEN
                           0.00000000
                        ELSE
                           DateIndex - DaysToRamp
                        ENDIF FROM "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" )
                     ENDWITH
                  ENDIF
               ELSE
                  "DateMax"( WITH NUMERIC DateIndex = FOR ( NUMERIC length IN "GetNumbers"( 0.00000000, i, 1.00000000 ) ) WITH NUMERIC result = LENGTH "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ) DO
                     IF ( ( GET @INDEX i - length FROM flowList ) >= 10000.00000000 "cfs" AND "CountDaysBelowThreshold"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", GET @INDEX IF ( i - length - 1.00000000 == - 1.00000000 )
                     THEN
                        0.00000000
                     ELSE
                        i - length - 1.00000000
                     ENDIF FROM "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ), YampaPeakDate ), 10000.00000000 "cfs" ) < 1.00000000 "day" )
                     THEN
                        i - length
                     ELSE
                        result
                     ENDIF
                  ENDFOR DO
                     GET @INDEX IF ( DateIndex - DaysToRamp < 0.00000000 )
                     THEN
                        0.00000000
                     ELSE
                        DateIndex - DaysToRamp
                     ENDIF FROM "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" )
                  ENDWITH, @"24:00:00 April 2, Current Year" ) COMMENTED_BY "Returns the maximum of April 2 or the first day that the Yampa River <br>is above 10,000 cfs so the April-July function works."
               ENDIF
            ENDWITH
         ENDWITH
      ENDWITH COMMENTED_BY "Counts Yampa River flow days above 10,000 cfs to determine if <br>flow targets can be met."
   ENDWITH COMMENTED_BY "Determines the date to bypass if the Yampa River flows are at 10,000 cfs<br>for the length of time necessary to meet flow targets. ";

    END;

    FUNCTION       "FindYampa14kcfsPPCDateForYear" ( NUMERIC PPCDays, DATETIME YampaPeakDate )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WITH LIST flowList = "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year" ) DO
      WITH NUMERIC DaysAbv14k = "DaysAboveThreshold"( flowList, 14000.00000000 "cfs" ) COMMENTED_BY "Counts Yampa River flows above 14,000 cfs to determine if flow targets<br>can be met." DO
         WITH NUMERIC DaysToRamp = "RoundToNearestDay"( ( $ "FlamingGorgeData.PowerPlantCapacity" [] - $ "FlamingGorge.Outflow" [@"24:00:00 Previous Month Max DayOfMonth, Current Year"] ) / ( $ "KNN_MTOM.RampUpRateNoUnits" [] * 1.00000000 "cfs" / 1.00000000 "day" ) ) / 1.00000000 "day" + 1.00000000 DO
            WITH NUMERIC i = LENGTH "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ) DO
               IF ( $ "KNN_MTOM.SpringHClass" [] < 4.00000000 AND $ "KNN_MTOM.SpringHClass" [] > 0.00000000 )
               THEN
                  IF ( DaysAbv14k >= $ "KNN_MTOM.YampaDaysAbove14000ForPPC" [$ "KNN_MTOM.SpringHClass" [], 0.00000000] )
                  THEN
                     WITH NUMERIC DateIndex = FOR ( NUMERIC length IN "GetNumbers"( 0.00000000, i, 1.00000000 ) ) WITH NUMERIC result = LENGTH "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ) DO
                        IF ( ( GET @INDEX i - length FROM flowList ) >= 14000.00000000 "cfs" AND "CountDaysBelowThreshold"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", GET @INDEX i - length - 1.00000000 FROM "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ), YampaPeakDate ), 14000.00000000 "cfs" ) < 1.00000000 "day" )
                        THEN
                           i - length
                        ELSE
                           result
                        ENDIF
                     ENDFOR DO
                        GET @INDEX DateIndex - DaysToRamp FROM "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" )
                     ENDWITH COMMENTED_BY "Finds the date closest to the Yampa River peak flow date that flows are<br>14,000 cfs in order to begin ramp up to PPC."
                  ELSE
                     ( YampaPeakDate - PPCDays / 2.00000000 ) COMMENTED_BY "FG has a spring peak every year and flow targets below 18,600 cfs.  This returns<br>the date closest to the Yampa River peak with half of the PPC days determined<br>for flow targets being met in all hydrologic classifications. "
                  ENDIF
               ELSE
                  ( YampaPeakDate - PPCDays * 0.75000000 ) COMMENTED_BY "FG has a spring peak every year and flow targets below 18,600 cfs.  This returns<br>the date closest to the Yampa River peak with the PPC days determined<br>for flow targets being met in all hydrologic classifications. This returns 75% of the PPC<br>days so that ramping to PPC occurs closer to the Yampa River peak in dry years.  The wet<br>year hydrologic classification is usually targeted using the bypass functions."
               ENDIF
            ENDWITH
         ENDWITH
      ENDWITH
   ENDWITH COMMENTED_BY "Determines the date to increase to PPC if the Yampa River flows are at 14,000 cfs<br>for the length of time necessary to meet flow targets.";

    END;

    FUNCTION       "CountDaysAboveThreshold" ( LIST flows, NUMERIC minflow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      FOR ( NUMERIC flow IN flows ) WITH NUMERIC result = 0.00000000 "day" DO
      IF ( flow >= minflow )
      THEN
         result + 1.00000000 "day"
      ELSE
         result
      ENDIF
   ENDFOR;

    END;

    FUNCTION       "CountDaysBelowThreshold" ( LIST flows, NUMERIC minflow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      FOR ( NUMERIC flow IN flows ) WITH NUMERIC result = 0.00000000 "day" DO
      IF ( minflow >= flow )
      THEN
         result + 1.00000000 "day"
      ELSE
         result
      ENDIF
   ENDFOR;

    END;

    FUNCTION       "AugustDownRamp" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "When bypass releases extend through the entire A-J period to July 31st, this function downramps to base flows in August.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WITH NUMERIC RampRate = $ "KNN_MTOM.BaseFlowDownrampRateNoUnits" [$ "KNN_MTOM.BaseFlowHClass" [@"t"], 0.00000000] * 1.00000000 "cfs" DO
      WITH NUMERIC DaysToDownRamp = "RoundToNearestDay"( ( $ "KNN_MTOM.FlamingGorgeDaily" [@"24:00:00 July Max DayOfMonth, Current Year"] - $ "FlamingGorge.Outflow" [] ) / RampRate * 1.00000000 "day" ) COMMENTED_BY "Number of days needed to downramp from July 31st bypass release to August base flow." DO
         WITH LIST DateList = "GetDates"( @"24:00:00 August 1, Current Year", @"24:00:00 August 31, Current Year", "1 days" ) DO
            WITH LIST FlowList = FOR ( DATETIME date IN DateList ) WITH LIST Augflows = {  } DO
               WITH NUMERIC i = ( date - @"24:00:00 August 1, Current Year" ) / 1.00000000 "day" DO
                  APPEND IF ( date == @"24:00:00 August 1, Current Year" )
                  THEN
                     ( $ "KNN_MTOM.FlamingGorgeDaily" [@"24:00:00 July Max DayOfMonth, Current Year"] - RampRate )
                  ELSE
                     IF ( date <= @"24:00:00 August 1, Current Year" + DaysToDownRamp )
                     THEN
                        "Max"( ( GET @INDEX i - 1.00000000 FROM Augflows ) - $ "KNN_MTOM.BaseFlowDownrampRateNoUnits" [$ "KNN_MTOM.BaseFlowHClass" [@"t"], 0.00000000] * 1.00000000 "cfs", "GetFGBaseFlowMagnitude"(  ) ) COMMENTED_BY "Downramping."
                     ELSE
                        "Max"( ( GET @INDEX i - 1.00000000 FROM Augflows ), "GetFGBaseFlowMagnitude"(  ) ) COMMENTED_BY "No downramping needed, the list generates August base flows or flows<br>necessary to maintain max PE."
                     ENDIF
                  ENDIF ONTO Augflows
               ENDWITH
            ENDFOR COMMENTED_BY "Create a list for August flows whether downramping from bypass flows or not." DO
               FOR ( DATETIME date IN DateList ) WITH LIST DateFlowList = {  } DO
                  APPEND { date , GET @INDEX ( date - @"24:00:00 August 1, Current Year" ) / 1.00000000 "day" FROM FlowList } ONTO DateFlowList
               ENDFOR
            ENDWITH
         ENDWITH
      ENDWITH
   ENDWITH;

    END;

    FUNCTION       "SpringFlowA-JVolumeUpdate" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      IF ( "MonthIs"( { "January" , "February" , "March" } ) )
   THEN
      ( ( "SumFlowsToVolume"( $ "FlamingGorgeInflow.Unregulated", @"24:00:00 Current Month Max DayOfMonth, Current Year", @"24:00:00 April Max DayOfMonth, Current Year" ) / "SumSlot"( $ "KNN_MTOM.FGAverageUnregInflow", @"24:00:00 Current Month Max DayOfMonth, Current Year", @"24:00:00 April Max DayOfMonth, Current Year" ) ) * "SumSlot"( $ "KNN_MTOM.FGAverageUnregInflow", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" ) )
   ELSE
      "SumFlowsToVolume"( $ "FlamingGorgeInflow.Unregulated", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" )
   ENDIF;

    END;

    FUNCTION       "BaseFlowA-JVolumeUpdate" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      IF ( "MonthIs"( { "January" , "February" , "March" } ) )
   THEN
      ( ( "SumFlowsToVolume"( $ "FlamingGorgeInflow.Unregulated", @"24:00:00 Current Month Max DayOfMonth, Current Year", @"24:00:00 April Max DayOfMonth, Current Year" ) / "SumSlot"( $ "KNN_MTOM.FGAverageUnregInflow", @"24:00:00 Current Month Max DayOfMonth, Current Year", @"24:00:00 April Max DayOfMonth, Current Year" ) ) * "SumSlot"( $ "KNN_MTOM.FGAverageUnregInflow", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" ) ) COMMENTED_BY "January through April flows change depending on actual inflow, the forecasted unreg inflow and meeting March or May 1 elevation target."
   ELSE
      IF ( "MonthIs"( { "August" } ) )
      THEN
         "SumFlowsToVolume"( $ "FlamingGorgeInflow.Unregulated", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" )
      ELSE
         IF ( "MonthIs"( { "September" , "October" , "November" , "December" } ) )
         THEN
            "Max"( ( "SumFlowsToVolume"( $ "FlamingGorgeInflow.Unregulated", @"t - 1", @"t - 1" ) / $ "KNN_MTOM.FGAverageUnregInflow" [@"t - 1"] ) * "SumSlot"( $ "KNN_MTOM.FGAverageUnregInflow", @"24:00:00 April Max DayOfMonth, Next Year", @"24:00:00 July Max DayOfMonth, Next Year" ), 0.00000000 "acre-ft" )
         ELSE
            "SumFlowsToVolume"( $ "FlamingGorgeInflow.Unregulated", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" )
         ENDIF COMMENTED_BY "The months of September through December look at actual flows coming into the system and react if necessary to meet the March 1 elevation target."
      ENDIF COMMENTED_BY "August uses observed April through July unregulated inflow volume."
   ENDIF;

    END;

  END;

  UTILITY_GROUP "KNNFunctions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  BEGIN

    FUNCTION       "ChooseIndexYearRatio" ( NUMERIC aprRatio, NUMERIC mayRatio, NUMERIC junRatio, NUMERIC julRatio )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      GET @INDEX WHILE ( NOT $ "KNN_MTOM.randomNum" [@"24:00:00 December Max DayOfMonth, Current Year"] <= $ "KNN_MTOM.CumulativeSumW" [i, 0.00000000] ) WITH NUMERIC i = 0.00000000 DO
      i + 1.00000000
   ENDWHILE FROM "FindKNNFromRatios"( aprRatio, mayRatio, junRatio, julRatio );

    END;

    FUNCTION       "DummyTestFunction" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      0.00000000;

    END;

    FUNCTION       "FindKNNFromRatios" ( NUMERIC aprRatio, NUMERIC mayRatio, NUMERIC junRatio, NUMERIC julRatio )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WITH LIST sortedYears = "SortPairsAscending"( FOR ( LIST yrVol IN "GetYearsAndRatios"(  ) ) WITH LIST result = {  } DO
      APPEND { GET @INDEX 0.00000000 FROM yrVol , "Exp"( ( aprRatio - GET @INDEX 1.00000000 FROM yrVol ) ^ 2.00000000 + ( mayRatio - GET @INDEX 2.00000000 FROM yrVol ) ^ 2.00000000 + ( junRatio - GET @INDEX 3.00000000 FROM yrVol ) ^ 2.00000000 + ( julRatio - GET @INDEX 4.00000000 FROM yrVol ) ^ 2.00000000, 0.50000000 ) } ONTO result
   ENDFOR ) DO
      FOR ( NUMERIC val IN "GetNumbers"( 0.00000000, $ "KNN_MTOM.K" [] - 1.00000000, 1.00000000 ) ) WITH LIST result = {  } DO
         APPEND GET @INDEX val FROM sortedYears ONTO result
      ENDFOR
   ENDWITH;

    END;

    FUNCTION       "GetCurrentMonthlyNaturalInflow" ( DATETIME month )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WITH DATETIME currentMonth = "GetDate"( "GetMonthAsString"( month ) CONCAT ",current year" ) DO
      "FlowToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge" [currentMonth], currentMonth )
   ENDWITH;

    END;

    FUNCTION       "GetCurrentYearDailyList" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      "GetDates"( "GetDate"( "NumberToDate"( $ "KNN_MTOM.StartMonth" [] ) CONCAT " 1, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( @"24:00:00 December Max DayOfMonth, Current Year" ), "." ) ), "GetDate"( "NumberToDate"( $ "KNN_MTOM.EndMonth" [] ) CONCAT ( ( GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetDaysInMonth"( "GetDate"( "NumberToDate"( $ "KNN_MTOM.EndMonth" [] ) CONCAT ", current year" ) ), "." ) ) CONCAT "," ) CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( @"24:00:00 December Max DayOfMonth, Current Year" ), "." ) ), "1 days" );

    END;

    FUNCTION       "GetIndexYearDailyList" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      "GetDates"( "GetDate"( "NumberToDate"( $ "KNN_MTOM.StartMonth" [] ) CONCAT " 1, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY $ "KNN_MTOM.IndexYear" [@"24:00:00 December Max DayOfMonth, Current Year"], "." ) ), "GetDate"( "NumberToDate"( $ "KNN_MTOM.EndMonth" [] ) CONCAT ( ( GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetDaysInMonth"( "GetDate"( "NumberToDate"( $ "KNN_MTOM.EndMonth" [] ) CONCAT ", current year" ) ), "." ) ) CONCAT "," ) CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY $ "KNN_MTOM.IndexYear" [@"24:00:00 December Max DayOfMonth, Current Year"], "." ) ), "1 days" );

    END;

    FUNCTION       "GetMonthlyProportionVector" ( DATETIME month )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WITH LIST days = "GetDates"( "GetDate"( "GetMonthAsString"( month ) CONCAT "1, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY $ "KNN_MTOM.IndexYear" [@"24:00:00 December Max DayOfMonth, Current Year"], "." ) ), "GetDate"( ( "GetMonthAsString"( month ) CONCAT " " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetDaysInMonth"( month ), "." ) ) CONCAT ", " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "KNN_MTOM.IndexYear" [@"24:00:00 December Max DayOfMonth, Current Year"], "." ) ), "1 DAYS" ) DO
      WITH NUMERIC monthlyVolume = "SumFlowsToVolume"( $ "KNN_MTOM.DeerlodgeDaily", GET @INDEX 0.00000000 FROM days, GET @INDEX ( LENGTH days ) - 1.00000000 FROM days ) DO
         FOR ( DATETIME day IN days ) WITH LIST propVec = {  } DO
            APPEND ( $ "KNN_MTOM.DeerlodgeDaily" [day] * 24.00000000 "hour" ) / monthlyVolume ONTO propVec
         ENDFOR
      ENDWITH
   ENDWITH;

    END;

    FUNCTION       "GetProportionVector" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WITH NUMERIC sprVol = "SumFlowsToVolume"( $ "KNN_MTOM.DeerlodgeDaily", GET @INDEX 0.00000000 FROM "GetIndexYearDailyList"(  ), GET @INDEX ( LENGTH "GetIndexYearDailyList"(  ) ) - 1.00000000 FROM "GetIndexYearDailyList"(  ) ) DO
      FOR ( DATETIME day IN "GetIndexYearDailyList"(  ) ) WITH LIST propVec = {  } DO
         APPEND "FlowToVolume"( $ "KNN_MTOM.DeerlodgeDaily" [day], day ) / sprVol ONTO propVec
      ENDFOR
   ENDWITH;

    END;

    FUNCTION       "GetRandSeed" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns a seed for use by the RandomNormal function. <br>The seed is incremented by the trace number, as stored in the first timestep of the<br>Hydrology Increment slot. The trace number could be available as a RPL function, but would not be enough to fulfill our requirements.<br><br>In the current setup, all MRM runs will have the same set of random numbers at the same trace, but all traces will have different sets, as controlled by the Hydrology Increment slot, which is rotated with the MRM runs.<br>This also allows single trace runs to have identical random numbers generated as well, which is not possible with a RPL function.<br><br>Probably should rename the Hydrology Increment slot to Trace Number.<br><br>With Random Seed = 1, is equivalent to just using the Trace Number as the seed for each trace.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      ( $ "KNN_MTOM.Random Seed" [] + ( $ "KNN_MTOM.hydrologyIncrement" [@"Start Timestep"] - 1.00000000 ) );

    END;

    FUNCTION       "GetSecondStageProportionVector" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      FOR ( DATETIME month IN "GetDates"( @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year", "1 MONTHS" ) ) WITH LIST propVec = {  } DO
      WITH LIST monthlyProp = "GetMonthlyProportionVector"( month ) DO
         FOR ( NUMERIC dayProp IN monthlyProp ) WITH LIST result = propVec DO
            APPEND dayProp ONTO result
         ENDFOR
      ENDWITH
   ENDFOR;

    END;

    FUNCTION       "GetSpringVolume" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      "SumFlowsToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge", "GetDate"( "NumberToDate"( $ "KNN_MTOM.StartMonth" [] ) CONCAT ",current year" ), "GetDate"( "NumberToDate"( $ "KNN_MTOM.EndMonth" [] ) CONCAT ",current year" ) );

    END;

    FUNCTION       "GetYearsAndRatios" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      FOR ( NUMERIC year IN "GetNumbers"( "GetYear"( "NumberToDate"( $ "KNN_MTOM.HistoricalStartYear" [] ) ), "GetYear"( "NumberToDate"( $ "KNN_MTOM.HistoricalEndYear" [] ) ), 1.00000000 ) ) WITH LIST result = {  } DO
      WITH NUMERIC seasonalVol = "SumFlowsToVolume"( $ "KNN_MTOM.DeerlodgeMonthly", "GetDate"( "April, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) ), "GetDate"( "July, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) ) ) DO
         APPEND { year , "FlowToVolume"( $ "KNN_MTOM.DeerlodgeMonthly" ["GetDate"( "April, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) )], "GetDate"( "April, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) ) ) / seasonalVol , "FlowToVolume"( $ "KNN_MTOM.DeerlodgeMonthly" ["GetDate"( "May, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) )], "GetDate"( "May, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) ) ) / seasonalVol , "FlowToVolume"( $ "KNN_MTOM.DeerlodgeMonthly" ["GetDate"( "June, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) )], "GetDate"( "June, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) ) ) / seasonalVol , "FlowToVolume"( $ "KNN_MTOM.DeerlodgeMonthly" ["GetDate"( "July, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) )], "GetDate"( "July, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) ) ) / seasonalVol } ONTO result
      ENDWITH
   ENDFOR;

    END;

  END;

  UTILITY_GROUP "Fontenelle Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  BEGIN

    FUNCTION       "SolvePoolElevation" ( OBJECT obj, NUMERIC outflow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      "StorageToElevation"( obj, "SolveStorage"( obj, "MyGetSlot"( obj, "Inflow" ) [], outflow, "MyGetSlot"( obj, "Storage" ) [@"t - 1"], @"t" ) ) COMMENTED_BY "Solves for end of time step storage given an object and its outflow";

    END;

    FUNCTION       "FontenelleTargetFlow" ( NUMERIC Elevation )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Determines the target outflow for Frontenelle. The outflow is either the maximum possible outflow given the inflow, or the release needed to meet the target elevation, whichever is less assuming the flow meets the power plant capacity. - ce 6/6/13";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    MIN_CONSTRAINT $ "FontenelleData.MinFlow" [];
    BEGIN

      "Min"( "GetMaxOutflowGivenInflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], @"t" ) COMMENTED_BY "Maximum possible release from the res", "SolveOutflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], "ElevationToStorage"( % "Fontenelle", Elevation ), "ElevationToStorage"( % "Fontenelle", $ "Fontenelle.Pool Elevation" [@"t - 1"] ), @"t" ) COMMENTED_BY "Release to meet target elevation" );

    END;

  END;

  UTILITY_GROUP "ICSAccountingFunctions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  BEGIN

    FUNCTION       "DeliveryAndCreationCAICS" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH NUMERIC nevadaBankingToCA = IF ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 )
   THEN
      0.00000000 "acre-ft"
   ELSE
      $ "ICS Credits.AnnualNVBankedinCA" ["Dec31ofYear"( @"t" )] COMMENTED_BY "This value is calculated in the &quot;Nevada Banking&quot; rule, logic for the portion to CA <br>can be edited in that rule. "
   ENDIF DO
      WITH NUMERIC creationOfCACEICS = IF ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 )
      THEN
         0.00000000 "acre-ft"
      ELSE
         - "Min"( NaNToZero ( $ "LowerBasinDemandVariability.MWDLBDVDifference" ["Dec31ofYear"( @"t" )] ), 0.00000000 "acre-ft" )
      ENDIF DO
         WITH NUMERIC totalDeliveryOfCAICS = IF ( ( GET @INDEX 0.00000000 FROM "TotalDeliveryOfCaliforniaICS"( creationOfCACEICS, nevadaBankingToCA ) ) < 0.00000000 "acre-ft" AND ( GET @INDEX 1.00000000 FROM "TotalDeliveryOfCaliforniaICS"( creationOfCACEICS, nevadaBankingToCA ) ) == 0.00000000 )
         THEN
            0.00000000 "acre-ft"
         ELSE
            GET @INDEX 0.00000000 FROM "TotalDeliveryOfCaliforniaICS"( creationOfCACEICS, nevadaBankingToCA )
         ENDIF DO
            WITH NUMERIC lbdvValue = NaNToZero ( $ "LowerBasinDemandVariability.MWDLBDVDifference" ["Dec31ofYear"( @"t" )] ) DO
               WITH NUMERIC revisedCAICSDeliveryLBDV = IF ( ( ( GET @INDEX 1.00000000 FROM "TotalDeliveryOfCaliforniaICS"( creationOfCACEICS, nevadaBankingToCA ) ) == 0.00000000 AND totalDeliveryOfCAICS > 0.00000000 "acre-ft" ) COMMENTED_BY "If the local inflows above Powell are between the 25th and 75th percentile and if there is a calculated delivery of ICS water for California." )
               THEN
                  ( totalDeliveryOfCAICS + "Max"( NaNToZero ( $ "LowerBasinDemandVariability.MWDLBDVDifference" ["Dec31ofYear"( @"t" )] ), 0.00000000 "acre-ft" ) ) COMMENTED_BY "Increase the delivery amount by the additional water released by LBDV to CA (MWD)"
               ELSE
                  totalDeliveryOfCAICS
               ENDIF DO
                  WITH NUMERIC revisedCACEICSCreationLBDV = IF ( ( ( GET @INDEX 1.00000000 FROM "TotalDeliveryOfCaliforniaICS"( creationOfCACEICS, nevadaBankingToCA ) ) == 0.00000000 AND ( GET @INDEX 0.00000000 FROM "TotalDeliveryOfCaliforniaICS"( creationOfCACEICS, nevadaBankingToCA ) ) < 0.00000000 "acre-ft" ) COMMENTED_BY "If the local inflows to Powell are between the 25th and 75th percentile and a creation of ics has been determined <br>(negative delivery) then then subtract the LBDV that was Released for a dry year from<br> the amount of water being created for ICS. " )
                  THEN
                     "Max"( creationOfCACEICS - GET @INDEX 0.00000000 FROM "TotalDeliveryOfCaliforniaICS"( creationOfCACEICS, nevadaBankingToCA ), 0.00000000 "acre-ft" )
                  ELSE
                     creationOfCACEICS
                  ENDIF DO
                     { revisedCAICSDeliveryLBDV , revisedCACEICSCreationLBDV }
                  ENDWITH
               ENDWITH
            ENDWITH
         ENDWITH
      ENDWITH
   ENDWITH;

    END;

    FUNCTION       "FloodControlECICSBalance" ( NUMERIC fcvolume )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "This function takes the passed in flood control volume and uses the resulting EC ICS volumes for each state to determine the balance for each state. Then determines a reduction ratio which is the flood control volume divided by the total EC ICS volume.  If this value is greater than 1, the flood control volume is greater than the total EC ICS volume and the resulting EC Volumes need to be set to 0 AF. If the ratio is less than one, then the EC ICS volumes need to be reduced by the ratio proportional to the volume for each state.  The function returns the volumes for each state in AF. in the order<br>&lcub;CAECBalance, NVECBalance, AZECBalance, CATotalICS, NVTotalICS, AZTotalICS&rcub; - TP 11/4/2014";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WITH NUMERIC caECICS = $ "ICS Credits.ExtraordinaryConservationICS_CA" ["Dec31ofYear"( @"t" )] DO
      WITH NUMERIC nvECICS = $ "ICS Credits.ExtraordinaryConservationICS_NV" ["Dec31ofYear"( @"t" )] DO
         WITH NUMERIC azECICS = $ "ICS Credits.ExtraordinaryConservationICS_AZ" ["Dec31ofYear"( @"t" )] DO
            WITH NUMERIC totalECICS = caECICS + nvECICS + azECICS DO
               WITH NUMERIC caECICSDel = NaNToZero ( $ "ICS Credits.AnnualDeliveryEC_CA" ["Dec31ofYear"( @"t" )] ) DO
                  WITH NUMERIC nvECICSDel = NaNToZero ( $ "ICS Credits.AnnualDeliveryEC_NV" ["Dec31ofYear"( @"t" )] ) DO
                     WITH NUMERIC azECICSDel = NaNToZero ( $ "ICS Credits.AnnualDeliveryEC_AZ" ["Dec31ofYear"( @"t" )] ) DO
                        WITH NUMERIC totalECICSDel = caECICSDel + nvECICSDel + azECICSDel DO
                           WITH NUMERIC caOtherICS = $ "ICS Credits.TotalICS_CA" ["Dec31ofYear"( @"t" )] - caECICS DO
                              WITH NUMERIC nvOtherICS = $ "ICS Credits.TotalICS_NV" ["Dec31ofYear"( @"t" )] - nvECICS DO
                                 WITH NUMERIC azOtherICS = $ "ICS Credits.TotalICS_AZ" ["Dec31ofYear"( @"t" )] - azECICS DO
                                    IF ( fcvolume < totalECICSDel )
                                    THEN
                                       WITH NUMERIC delRatio = fcvolume / totalECICSDel DO
                                          { caECICSDel * delRatio , nvECICSDel * delRatio , azECICSDel * delRatio , caECICS , nvECICS , azECICS , caOtherICS , nvOtherICS , azOtherICS }
                                       ENDWITH
                                    ELSE
                                       IF ( fcvolume < totalECICSDel + totalECICS )
                                       THEN
                                          WITH NUMERIC volRatio = ( fcvolume - totalECICSDel ) / totalECICS DO
                                             WITH LIST stateECBalLista = { volRatio * caECICS , volRatio * nvECICS , volRatio * azECICS } DO
                                                WITH LIST totalECBalList = { caOtherICS + GET @INDEX 0.00000000 FROM stateECBalLista , nvOtherICS + GET @INDEX 1.00000000 FROM stateECBalLista , azOtherICS + GET @INDEX 2.00000000 FROM stateECBalLista } DO
                                                   { 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , GET @INDEX 0.00000000 FROM stateECBalLista , GET @INDEX 1.00000000 FROM stateECBalLista , GET @INDEX 2.00000000 FROM stateECBalLista , GET @INDEX 0.00000000 FROM totalECBalList , GET @INDEX 1.00000000 FROM totalECBalList , GET @INDEX 2.00000000 FROM totalECBalList }
                                                ENDWITH
                                             ENDWITH
                                          ENDWITH
                                       ELSE
                                          { 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , caOtherICS , nvOtherICS , azOtherICS } COMMENTED_BY "if the FC volume is greater than the EC ICS total delivery volume and EC ICS volume, then reduce the state values for delivery and volume to 0 AF and the total ICS volume for each state <br>will be equal to the other ICS Volumes in the system. "
                                       ENDIF COMMENTED_BY "If the Flood Control is greater than the delivery volume, but less than the total EC ICS volume plus the EC ICS Delivery, reduce the state EC ICS volume by the amount<br>of the Flood Control volume less the EC ICS total delivery volume. Reduce the current EC ICS volumes for each state by the ratio derived and reduce the Total ICS Volume <br>for each state by the difference each state volume of EC ICS "
                                    ENDIF COMMENTED_BY "If the Flood Control is less than the delivery volume, reduce the delivery volume by the amount<br>of the Flood Control volume. Keep the current EC ICS volumes for each state constant and the<br>Total ICS Volume should not change for each state"
                                 ENDWITH
                              ENDWITH
                           ENDWITH COMMENTED_BY "Get the Total ICS Volume for each stat minuse the EC water"
                        ENDWITH
                     ENDWITH
                  ENDWITH
               ENDWITH COMMENTED_BY "Get the Total EC Delivery Volume for each state "
            ENDWITH
         ENDWITH
      ENDWITH
   ENDWITH COMMENTED_BY "Get the EC ICS Volumes for each state and compute <br>the total volume. ";

    END;

    FUNCTION       "ICSAccountingForAZ" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "This function uses the input slots for the creation of the ICS categories Extraordinary Conservation (EC), System Efficiency (SE), and Bi-National (BiNat)<br>and determines the delivery of each category of ICS and the resulting amount of ICS Storage for each category as well as the Total Arizona ICS Volume. <br>The function returns a list of each of these values for the Rule to assign to the appropriate slots.  TP 9/10/2014<br><br>For the delivery of AZ ICS: <br>If the projected January Lake Mead elevation is 1,100 ft or higher, then set the ICS delivery to the Total ICS Created / 10. <br> In the case that the Lower Basin is in Surplus, CAP would take delivery of 1/10 ICS Created in addition to any Surplus entitlement. <br> In cases where the projected January Lake Mead elevation is under 1,100 ft, set the delivery volume to 0 af, regardless of Normal or Shortage condition. ";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WITH NUMERIC creationOfEC = IF ( NaNToZero ( $ "Surplus.Quantified Surplus Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 )
   THEN
      0.00000000 "acre-ft"
   ELSE
      $ "ICS Credits.AnnualCreationEC_AZ" ["Dec31ofYear"( @"t" )]
   ENDIF DO
      WITH NUMERIC creationOfSE = IF ( NaNToZero ( $ "Surplus.Quantified Surplus Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 )
      THEN
         0.00000000 "acre-ft"
      ELSE
         $ "ICS Credits.AnnualCreationSysEff_AZ" ["Dec31ofYear"( @"t" )]
      ENDIF DO
         WITH NUMERIC creationOfBiNat = IF ( NaNToZero ( $ "Surplus.Quantified Surplus Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 )
         THEN
            0.00000000 "acre-ft"
         ELSE
            $ "ICS Credits.AnnualCreationBiNat_AZ" ["Dec31ofYear"( @"t" )]
         ENDIF DO
            WITH NUMERIC deliveryOfAZICS = IF ( ( $ "Mead.Pool Elevation" [@"24:00:00 December 31, Previous Year"] >= 1100.00000000 "ft" ) COMMENTED_BY "If the Projected January Lake Mead Elevation is to be greater than 1,100 ft or the Lower<br>Basin is in Surplus, then set the ICS delivery to Total ICS Created/10. If Lake Mead is below <br>1,100 do not allow any delivery of ICS. The logic only needs to know if Lake Mead is above<br>1,110 ft and the delivery will be added to any allocation already set by the Surplus logic. " )
            THEN
               0.10000000 * $ "ICS Credits.SystemEfficiencyICS_AZ" ["Dec31ofYear"( @"24:00:00 December 31, 2014" )] COMMENTED_BY "System Efficiency ICS AZ 103,500 AF (10% of this volume over 10 year)"
            ELSE
               0.00000000 "acre-ft"
            ENDIF DO
               WITH NUMERIC deliveryChargedToEC = "Min"( deliveryOfAZICS, $ "ICS Credits.ExtraordinaryConservationICS_AZ" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.AnnualCreationEC_AZ" ["Dec31ofYear"( @"t" )] ) DO
                  WITH NUMERIC deliveryChargedToSE = "Min"( deliveryOfAZICS - deliveryChargedToEC, $ "ICS Credits.SystemEfficiencyICS_AZ" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.AnnualCreationSysEff_AZ" ["Dec31ofYear"( @"t" )] ) DO
                     WITH NUMERIC deliveryChargedToBiNat = "Min"( deliveryOfAZICS - deliveryChargedToEC - deliveryChargedToSE, $ "ICS Credits.BiNationalICS_AZ" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.AnnualCreationBiNat_AZ" ["Dec31ofYear"( @"t" )] ) DO
                        WITH NUMERIC SysECAZ = IF ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 )
                        THEN
                           $ "ICS Credits.ExtraordinaryConservationICS_AZ" [@"24:00:00 December Max DayOfMonth, Previous Year"] + creationOfEC * 0.95000000 - deliveryChargedToEC
                        ELSE
                           ( $ "ICS Credits.ExtraordinaryConservationICS_AZ" [@"24:00:00 December Max DayOfMonth, Previous Year"] - deliveryChargedToEC ) * 0.97000000 + creationOfEC * 0.95000000
                        ENDIF COMMENTED_BY "Resulting ExtraOrdinaryConservation ICS " DO
                           WITH NUMERIC SysSEAZ = ( $ "ICS Credits.SystemEfficiencyICS_AZ" [@"24:00:00 December Max DayOfMonth, Previous Year"] + creationOfSE - deliveryChargedToSE ) COMMENTED_BY "Resulting System Efficiency ICS " DO
                              WITH NUMERIC SysBiNatAZ = ( $ "ICS Credits.BiNationalICS_AZ" [@"24:00:00 December Max DayOfMonth, Previous Year"] + creationOfBiNat - deliveryChargedToBiNat ) COMMENTED_BY "Resulting Bi National ICS " DO
                                 WITH NUMERIC totalICSAZ = ( SysECAZ + SysSEAZ + SysBiNatAZ ) COMMENTED_BY "Total ICS" DO
                                    WITH NUMERIC totalICSAZDelivery = deliveryChargedToEC + deliveryChargedToSE + deliveryChargedToBiNat DO
                                       WITH NUMERIC totalICSAZCreation = creationOfEC + creationOfSE + creationOfBiNat DO
                                          { deliveryChargedToEC , deliveryChargedToSE , deliveryChargedToBiNat , SysECAZ , SysSEAZ , SysBiNatAZ , totalICSAZ , totalICSAZDelivery , totalICSAZCreation }
                                       ENDWITH
                                    ENDWITH
                                 ENDWITH
                              ENDWITH
                           ENDWITH
                        ENDWITH
                     ENDWITH
                  ENDWITH
               ENDWITH
            ENDWITH
         ENDWITH
      ENDWITH
   ENDWITH;

    END;

    FUNCTION       "ICSAccountingForCA" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "This function uses the input slots for the creation of the ICS categories Extraordinary Conservation (EC), System Efficiency (SE), and Bi-National (BiNat)<br>and determines the delivery of each category of ICS and the resulting amount of ICS Storage for each category as well as the Total California ICS Volume. <br>The function returns a list of each of these values for the Rule to assign to the appropriate slots.  TP 9/10/2014<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH NUMERIC totalDeliveryOfCAICS = IF ( NaNToZero ( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 )
   THEN
      0.00000000 "acre-ft"
   ELSE
      GET @INDEX 0.00000000 FROM "DeliveryAndCreationCAICS"(  )
   ENDIF COMMENTED_BY "In shortage years no delivery of ICS is possible" DO
      WITH NUMERIC creationOfCACEICS = IF ( NaNToZero ( $ "Surplus.Domestic Surplus Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 )
      THEN
         0.50000000 * $ "Surplus Volume Entitlements.MWD Domestic" ["Dec31ofYear"( @"t" )]
      ELSE
         IF ( NaNToZero ( $ "Surplus.Quantified Surplus Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 OR NaNToZero ( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 )
         THEN
            0.00000000 "acre-ft"
         ELSE
            GET @INDEX 1.00000000 FROM "DeliveryAndCreationCAICS"(  )
         ENDIF COMMENTED_BY "If the LB Condition is Quantified Surplus or shortage, do not create any ICS water"
      ENDIF COMMENTED_BY "If Domestic Surplus is the LB Condition, create 1/2 of the MWD<br>Domestic Volume Entitlement." DO
         WITH NUMERIC creationSE = IF ( NaNToZero ( $ "Surplus.Quantified Surplus Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 OR NaNToZero ( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 )
         THEN
            0.00000000 "acre-ft"
         ELSE
            $ "ICS Credits.AnnualCreationSysEff_CA" ["Dec31ofYear"( @"t" )]
         ENDIF COMMENTED_BY "If the LB Condition is Quantified Surplus or shortage, do not create any ICS water" DO
            WITH NUMERIC creationBiNat = IF ( NaNToZero ( $ "Surplus.Quantified Surplus Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 OR NaNToZero ( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 )
            THEN
               0.00000000 "acre-ft"
            ELSE
               $ "ICS Credits.AnnualCreationBiNat_CA" ["Dec31ofYear"( @"t" )]
            ENDIF COMMENTED_BY "If the LB Condition is Quantified Surplus or shortage, do not create any ICS water" DO
               WITH NUMERIC deliveryChargedToEC = "Min"( totalDeliveryOfCAICS, $ "ICS Credits.ExtraordinaryConservationICS_CA" [@"24:00:00 December Max DayOfMonth, Previous Year"] + creationOfCACEICS * 0.95000000 ) DO
                  WITH NUMERIC deliveryChargedToSE = "Min"( totalDeliveryOfCAICS - deliveryChargedToEC, $ "ICS Credits.SystemEfficiencyICS_CA" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.AnnualCreationSysEff_CA" ["Dec31ofYear"( @"t" )] ) DO
                     WITH NUMERIC deliveryChargedToBiNat = "Min"( totalDeliveryOfCAICS - deliveryChargedToEC - deliveryChargedToSE, $ "ICS Credits.BiNationalICS_CA" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.AnnualCreationBiNat_CA" ["Dec31ofYear"( @"t" )] ) DO
                        WITH NUMERIC mwdDiversionReduction = "Max"( totalDeliveryOfCAICS - deliveryChargedToEC - deliveryChargedToSE - deliveryChargedToBiNat, 0.00000000 "acre-ft" ) DO
                           WITH NUMERIC SysECCA = IF ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 )
                           THEN
                              $ "ICS Credits.ExtraordinaryConservationICS_CA" [@"24:00:00 December Max DayOfMonth, Previous Year"] + creationOfCACEICS * 0.95000000 - deliveryChargedToEC
                           ELSE
                              ( $ "ICS Credits.ExtraordinaryConservationICS_CA" [@"24:00:00 December Max DayOfMonth, Previous Year"] - deliveryChargedToEC ) * 0.97000000 + creationOfCACEICS * 0.95000000
                           ENDIF COMMENTED_BY "Resulting ExtraOrdinaryConservation ICS " DO
                              WITH NUMERIC SysSECA = ( $ "ICS Credits.SystemEfficiencyICS_CA" [@"24:00:00 December Max DayOfMonth, Previous Year"] + creationSE - deliveryChargedToSE ) COMMENTED_BY "Resulting System Efficiency ICS " DO
                                 WITH NUMERIC SysBiNatCA = ( $ "ICS Credits.BiNationalICS_CA" [@"24:00:00 December Max DayOfMonth, Previous Year"] + creationBiNat - deliveryChargedToBiNat ) COMMENTED_BY "Resulting Bi National ICS " DO
                                    WITH NUMERIC totalICSCA = ( SysECCA + SysSECA + SysBiNatCA ) COMMENTED_BY "Total ICS" DO
                                       WITH NUMERIC totalCAICSDelivery = deliveryChargedToEC + deliveryChargedToSE + deliveryChargedToBiNat DO
                                          WITH NUMERIC totalCAICSCreation = IF ( NaNToZero ( $ "Surplus.Domestic Surplus Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 )
                                          THEN
                                             0.00000000 "acre-ft"
                                          ELSE
                                             creationOfCACEICS
                                          ENDIF COMMENTED_BY "?!?!?!?!?!?!? Should this be zero if only half of the release has been made already?" + creationSE + creationBiNat DO
                                             { deliveryChargedToEC , deliveryChargedToSE , deliveryChargedToBiNat , creationOfCACEICS , SysECCA , SysSECA , SysBiNatCA , totalICSCA , totalCAICSDelivery , totalCAICSCreation , mwdDiversionReduction }
                                          ENDWITH
                                       ENDWITH
                                    ENDWITH
                                 ENDWITH
                              ENDWITH
                           ENDWITH
                        ENDWITH
                     ENDWITH
                  ENDWITH
               ENDWITH
            ENDWITH
         ENDWITH
      ENDWITH
   ENDWITH;

    END;

    FUNCTION       "ICSAccountingForNV" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "This function uses the input slots for the creation of the ICS categories Tributary, Imported, Extraordinary Conservation (EC), System Efficiency (SE), and Bi-National (BiNat), Tributary DSS, Imported DSS<br>and determines the delivery of each category of ICS and the resulting amount of ICS Storage for each category as well as the Total Nevada ICS Volume. <br>The function returns a list of each of these values for the Rule to assign to the appropriate slots.  TP 9/10/2014<br><br>For the delivery of NV ICS: <br>The delivery values of NV ICS are all input and if logic is needed to determine the delivery of NV ICS, then the logic would go into this function. ";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WITH NUMERIC creationTribICS_NV = IF ( NaNToZero ( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 )
   THEN
      0.00000000 "acre-ft"
   ELSE
      $ "ICS Credits.AnnualCreationTrib_NV" ["Dec31ofYear"( @"t" )]
   ENDIF DO
      WITH NUMERIC creationIMPICS_NV = IF ( NaNToZero ( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 )
      THEN
         0.00000000 "acre-ft"
      ELSE
         $ "ICS Credits.AnnualCreationImp_NV" ["Dec31ofYear"( @"t" )]
      ENDIF DO
         WITH NUMERIC creationTribDSS_NV = IF ( NaNToZero ( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 )
         THEN
            $ "ICS Credits.AnnualCreationTrib_NV" ["Dec31ofYear"( @"t" )]
         ELSE
            0.00000000 "acre-ft"
         ENDIF DO
            WITH NUMERIC creationImpDSS_NV = IF ( NaNToZero ( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 )
            THEN
               $ "ICS Credits.AnnualCreationImp_NV" ["Dec31ofYear"( @"t" )]
            ELSE
               0.00000000 "acre-ft"
            ENDIF DO
               WITH NUMERIC deliveryTribDSS_NV = creationTribDSS_NV * 0.95000000 DO
                  WITH NUMERIC deliveryImpDSS_NV = creationImpDSS_NV * 0.95000000 DO
                     WITH NUMERIC creationEC = IF ( NaNToZero ( $ "Surplus.Quantified Surplus Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 )
                     THEN
                        0.00000000 "acre-ft"
                     ELSE
                        $ "ICS Credits.AnnualCreationEC_NV" ["Dec31ofYear"( @"t" )]
                     ENDIF DO
                        WITH NUMERIC creationSE = IF ( NaNToZero ( $ "Surplus.Quantified Surplus Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 )
                        THEN
                           0.00000000 "acre-ft"
                        ELSE
                           $ "ICS Credits.AnnualCreationSysEff_NV" ["Dec31ofYear"( @"t" )]
                        ENDIF DO
                           WITH NUMERIC creationBiNat = IF ( NaNToZero ( $ "Surplus.Quantified Surplus Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 )
                           THEN
                              0.00000000 "acre-ft"
                           ELSE
                              $ "ICS Credits.AnnualCreationBiNat_NV" ["Dec31ofYear"( @"t" )]
                           ENDIF DO
                              WITH NUMERIC tribICSNV = creationTribICS_NV * 0.95000000 - $ "ICS Credits.AnnualDeliveryTrib_NV" ["Dec31ofYear"( @"t" )] DO
                                 WITH NUMERIC impICSNV = creationIMPICS_NV * 0.95000000 - $ "ICS Credits.AnnualDeliveryImp_NV" ["Dec31ofYear"( @"t" )] DO
                                    WITH NUMERIC tribDSSICSNV = creationTribDSS_NV * 0.95000000 - deliveryTribDSS_NV DO
                                       WITH NUMERIC impDSSICSNV = creationImpDSS_NV * 0.95000000 - deliveryImpDSS_NV DO
                                          WITH NUMERIC SysECNV = IF ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 )
                                          THEN
                                             $ "ICS Credits.ExtraordinaryConservationICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] + tribICSNV + impICSNV - $ "ICS Credits.AnnualDeliveryEC_NV" ["Dec31ofYear"( @"t" )] + creationEC * 0.95000000
                                          ELSE
                                             ( $ "ICS Credits.ExtraordinaryConservationICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] + tribICSNV + impICSNV - $ "ICS Credits.AnnualDeliveryEC_NV" ["Dec31ofYear"( @"t" )] ) * 0.97000000 + creationEC * 0.95000000
                                          ENDIF COMMENTED_BY "Resulting ExtraOrdinaryConservation ICS " DO
                                             WITH NUMERIC SysSENV = ( $ "ICS Credits.SystemEfficiencyICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] + creationSE - $ "ICS Credits.AnnualDeliverySysEff_NV" ["Dec31ofYear"( @"t" )] ) COMMENTED_BY "Resulting System Efficiency ICS " DO
                                                WITH NUMERIC SysBiNatNV = ( $ "ICS Credits.BiNationalICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] + creationBiNat - $ "ICS Credits.AnnualDeliveryBiNat_NV" ["Dec31ofYear"( @"t" )] ) COMMENTED_BY "Resulting Bi National ICS " DO
                                                   WITH NUMERIC totalICSNV = ( tribICSNV + impICSNV + SysECNV + SysSENV + SysBiNatNV ) COMMENTED_BY "Total ICS" DO
                                                      WITH NUMERIC nvICSCreated = creationTribICS_NV + creationIMPICS_NV + creationTribDSS_NV + creationImpDSS_NV + $ "ICS Credits.AnnualCreationEC_NV" ["Dec31ofYear"( @"t" )] + $ "ICS Credits.AnnualCreationSysEff_NV" ["Dec31ofYear"( @"t" )] + $ "ICS Credits.AnnualCreationBiNat_NV" ["Dec31ofYear"( @"t" )] DO
                                                         WITH NUMERIC nvICSDelivered = $ "ICS Credits.AnnualDeliveryTrib_NV" ["Dec31ofYear"( @"t" )] + $ "ICS Credits.AnnualDeliveryImp_NV" ["Dec31ofYear"( @"t" )] + deliveryTribDSS_NV + deliveryImpDSS_NV + $ "ICS Credits.AnnualDeliveryEC_NV" ["Dec31ofYear"( @"t" )] + $ "ICS Credits.AnnualDeliverySysEff_NV" ["Dec31ofYear"( @"t" )] + $ "ICS Credits.AnnualDeliveryBiNat_NV" ["Dec31ofYear"( @"t" )] DO
                                                            { creationTribICS_NV , creationTribDSS_NV , SysSENV , SysECNV , tribDSSICSNV , impDSSICSNV , SysBiNatNV , totalICSNV , deliveryTribDSS_NV , deliveryImpDSS_NV , creationIMPICS_NV , creationImpDSS_NV , impICSNV , tribICSNV }
                                                         ENDWITH
                                                      ENDWITH
                                                   ENDWITH
                                                ENDWITH
                                             ENDWITH
                                          ENDWITH
                                       ENDWITH
                                    ENDWITH
                                 ENDWITH
                              ENDWITH
                           ENDWITH
                        ENDWITH
                     ENDWITH
                  ENDWITH
               ENDWITH
            ENDWITH
         ENDWITH
      ENDWITH
   ENDWITH;

    END;

    FUNCTION       "TotalCreationOfCaliforniaICS" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WITH NUMERIC baseSchedule = "FlowToVolume"( "SumSlot"( $ "MWDDiversion:MWD.Diversion Requested", "OffsetDate"( "Dec31ofYear"( @"t" ), - 11.00000000, "1 Months" ), "Dec31ofYear"( @"t" ) ), "Dec31ofYear"( @"t" ) ) COMMENTED_BY "Values are input by Reclamation and The sum of these three values is <br>equal to the Quantification Settlement Agreement Volume. <br>!?!?!?!?!?! Is this the correct way to calculate QSA? TP" DO
      WITH NUMERIC currentCACEICSBalance = $ "ICS Credits.ExtraordinaryConservationICS_CA" [@"24:00:00 December Max DayOfMonth, Previous Year"] DO
         WITH NUMERIC unregToPowellTrigger = IF ( NOT IsNaN $ "LowerBasinDemandVariability.PowellUnregulatedInflowTrigger" ["Dec31ofYear"( @"t" )] AND ( $ "LowerBasinDemandVariability.PowellUnregulatedInflowTrigger" ["Dec31ofYear"( @"t" )] > $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "PowellUnregInflow75"] ) )
         THEN
            1.00000000
         ELSE
            IF ( NOT IsNaN $ "LowerBasinDemandVariability.PowellUnregulatedInflowTrigger" ["Dec31ofYear"( @"t" )] AND ( $ "LowerBasinDemandVariability.PowellUnregulatedInflowTrigger" ["Dec31ofYear"( @"t" )] < $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "PowellUnregInflow25"] ) )
            THEN
               - 1.00000000
            ELSE
               0.00000000
            ENDIF
         ENDIF DO
            WITH NUMERIC volCACEICStobeCreated = IF ( ( unregToPowellTrigger == 1.00000000 ) COMMENTED_BY "If the Unregulated Inflow to Lake Powell is greater than the <br>75th percentile of Historic (1981-2000) flows, then create<br>the maximum of the Base Schedule - 700,000 AF up to <br>200,000 af or up to the max total EC ICS balance of <br>1.5 MAF" )
            THEN
               "Max"( "MinItem"( { 1500000.00000000 "acre-ft" - currentCACEICSBalance , "Min"( baseSchedule - 700000.00000000 "acre-ft", 200000.00000000 "acre-ft" ) } ), 0.00000000 "acre-ft" )
            ELSE
               IF ( ( unregToPowellTrigger == - 1.00000000 ) COMMENTED_BY "If the Unregulated Inflow to Lake Powell is less than the <br>25th percentile of Historic (1981-2000) flows, then deliver<br>the minimum of 1,100 KAF - Base Schedule and the current<br>CA ICS Balance up to 400 KAF of California ICS Water." )
               THEN
                  0.00000000 "acre-ft"
               ELSE
                  WITH NUMERIC icsBalanceCA = ( $ "AnnualWaterUse.California_Apportionment" ["Dec31ofYear"( @"t" )] - "FlowToVolume"( FOR ( DATETIME date IN "DateMax"( @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 January Max DayOfMonth, Current Year" ) TO @"24:00:00 December Max DayOfMonth, Current Year" ) STAT_SUM
                     FOR ( OBJECT diversionSite IN "ListSubbasin"( "California nonMWD WaterUsers" ) ) STAT_SUM
                        IF ( diversionSite == % "PaloVerde" )
                        THEN
                           diversionSite & "Total Diversion Requested" [date]
                        ELSE
                           diversionSite & "Diversion Requested" [date]
                        ENDIF
                     ENDFOR + $ "MWDDiversion:MWD.Diversion Requested" [date] + $ "OthersBlwImp:YumaIsland.Diversion Requested" [date] COMMENTED_BY "?!?!?!?!?!Should Yuma Iland be included in the diversions for California, it is not<br>on the Californica nonMWD WaterUsers sub basin. TP"
                  ENDFOR, "Dec31ofYear"( @"t" ) ) ) COMMENTED_BY "This equation determines if the scheduled diversions for California are greater or less than<br>the California Apportionment for the given year.  If the value is positive, then the function<br>will return a positive creation value. " DO
                     "Max"( icsBalanceCA, 0.00000000 "acre-ft" )
                  ENDWITH
               ENDIF
            ENDIF DO
               volCACEICStobeCreated
            ENDWITH
         ENDWITH
      ENDWITH
   ENDWITH;

    END;

    FUNCTION       "TotalDeliveryOfCaliforniaICS" ( NUMERIC creationOfCASysEffICS, NUMERIC nvBankingToCA )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH NUMERIC baseSchedule = $ "AnnualWaterUse.MWDDiversion_OutyearVolume" ["Dec31ofYear"( @"t" )] + $ "AnnualWaterUse.IID_OutyearVolume" ["Dec31ofYear"( @"t" )] + $ "AnnualWaterUse.Coachella_OutyearVolume" ["Dec31ofYear"( @"t" )] DO
      WITH NUMERIC currentCAICSBalance = creationOfCASysEffICS * 0.95000000 + $ "ICS Credits.AnnualCreationSysEff_CA" ["Dec31ofYear"( @"t" )] + $ "ICS Credits.AnnualCreationBiNat_CA" ["Dec31ofYear"( @"t" )] + $ "ICS Credits.TotalICS_CA" [@"24:00:00 December Max DayOfMonth, Previous Year"] DO
         WITH NUMERIC unregToPowellTrigger = IF ( NOT IsNaN $ "LowerBasinDemandVariability.PowellUnregulatedInflowTrigger" ["Dec31ofYear"( @"t" )] AND ( $ "LowerBasinDemandVariability.PowellUnregulatedInflowTrigger" ["Dec31ofYear"( @"t" )] > $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "PowellUnregInflow75"] ) )
         THEN
            1.00000000
         ELSE
            IF ( NOT IsNaN $ "LowerBasinDemandVariability.PowellUnregulatedInflowTrigger" ["Dec31ofYear"( @"t" )] AND ( $ "LowerBasinDemandVariability.PowellUnregulatedInflowTrigger" ["Dec31ofYear"( @"t" )] < $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "PowellUnregInflow25"] ) )
            THEN
               - 1.00000000
            ELSE
               0.00000000
            ENDIF
         ENDIF DO
            WITH NUMERIC volCAICStobeDelivered = IF ( ( unregToPowellTrigger == 1.00000000 ) COMMENTED_BY "If the Unregulated Inflow to Lake Powell is greater than the <br>75th percentile of Historic (1981-2000) flows, then deliver<br>no California ICS Water." )
            THEN
               0.00000000 "acre-ft"
            ELSE
               IF ( ( unregToPowellTrigger == - 1.00000000 ) COMMENTED_BY "If the Unregulated Inflow to Lake Powell is less than the <br>25th percentile of Historic (1981-2000) flows, then deliver<br>the minimum of 1,100 KAF - Base Schedule and the current<br>CA ICS Balance up to 400 KAF of California ICS Water." )
               THEN
                  "Max"( "MinItem"( { 400000.00000000 "acre-ft" , NaNToZero ( $ "LowerBasinDemandVariability.MWDLBDVDifference" ["Dec31ofYear"( @"t" )] ) , currentCAICSBalance } ), 0.00000000 "acre-ft" )
               ELSE
                  WITH NUMERIC icsBalanceCA = ( FOR ( DATETIME date IN "DateMax"( @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 January Max DayOfMonth, Current Year" ) TO @"24:00:00 December Max DayOfMonth, Current Year" ) STAT_SUM
                     FOR ( OBJECT diversionSite IN "ListSubbasin"( "California nonMWD WaterUsers" ) ) STAT_SUM
                        IF ( diversionSite == % "PaloVerde" )
                        THEN
                           "FlowToVolume"( diversionSite & "Total Diversion Requested" [date], date )
                        ELSE
                           "FlowToVolume"( diversionSite & "Diversion Requested" [date], date )
                        ENDIF
                     ENDFOR
                  ENDFOR COMMENTED_BY "Non MWD California Diversion" + FOR ( DATETIME date IN "DateMax"( @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 January Max DayOfMonth, Current Year" ) TO @"24:00:00 December Max DayOfMonth, Current Year" ) STAT_SUM
                     "FlowToVolume"( $ "MWDDiversion:MWD.Diversion Requested" [date], date ) - $ "California_CU_Schedules.MWDReturns" [date]
                  ENDFOR COMMENTED_BY "MWD Diversion" - nvBankingToCA + $ "ICSProjectionData.California_EstimatedPayback" ["Dec31ofYear"( @"t" )] + $ "ICSProjectionData.California_ECICSCreationIID" ["Dec31ofYear"( @"t" )] - $ "ICSProjectionData.California_BasicApportionment" [] ) COMMENTED_BY "This equation determines if the scheduled diversions for California are greater or less than<br>the basic California Apportionment for the given year.  If the value is positive, then deliveries of <br>ICS will need to be made as more diversion has been scheduled than apportionment, if the<br>value is negative, then creation of ICS will be done. TP 2/27/2015 - after discussion with LC Reclmation" DO
                     icsBalanceCA
                  ENDWITH
               ENDIF
            ENDIF DO
               { volCAICStobeDelivered , unregToPowellTrigger }
            ENDWITH
         ENDWITH
      ENDWITH
   ENDWITH;

    END;

  END;

  UTILITY_GROUP "Midterm Model General Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  BEGIN

    FUNCTION       "AlreadyUsedWater" ( OBJECT obj, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      "SumFlowsToVolume"( obj & "Total Depletion", @"24:00:00 January Max DayOfMonth, Current Year", @"t - 1" );

    END;

    FUNCTION       "AnnualRequestedWater" ( STRING user, STRING type, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      "SumFlowsToVolume"( "GetSlot"( user CONCAT ".Total " CONCAT type CONCAT " Requested" ), "OffsetDate"( date, - ( "GetMonth"( date ) - 1.00000000 ) COMMENTED_BY "The number to subtract from date to go to January of the year in Date", "1 MONTHS" ) COMMENTED_BY "Evaluates to January of the year found in 'date'", "OffsetDate"( date, ( 12.00000000 - "GetMonth"( date ) ) COMMENTED_BY "The number to add to date to go to December of the year in Date", "1 MONTHS" ) COMMENTED_BY "Evaluates to December of year found in 'date'" ) COMMENTED_BY "Calculated annual requested water (either depletion or diversion which is <br>specified by 'type') and expects the user to be on the San Juan River";

    END;

    FUNCTION       "April30ofYear" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "Determines the day of the year for April 30 making corrections for leap years if necessary. -CE 6/11/13";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      IF ( "LeapYear"( date ) )
   THEN
      "OffsetDate"( date, "Units NONE"( 121.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
   ELSE
      "OffsetDate"( date, "Units NONE"( 120.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
   ENDIF;

    END;

    FUNCTION       "CurrentYear" (  )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      @"24:00:00 December Max DayOfMonth, Current Year";

    END;

    FUNCTION       "DateToCheckEOWYElevation" ( DATETIME date, BOOLEAN startYear )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      IF ( date >= @"October 31" OR ( date == @"August 31" AND NOT startYear ) OR ( date == @"September 30" AND NOT startYear ) )
   THEN
      @"24:00:00 September 30, Next Year"
   ELSE
      @"24:00:00 September 30, Current Year"
   ENDIF;

    END;

    FUNCTION       "DateToCheckJan1Elevation" ( DATETIME date, BOOLEAN startYear )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      IF ( date >= @"October 31" OR ( date == @"August 31" AND NOT startYear ) )
   THEN
      "Dec31ofYear"( date )
   ELSE
      "Dec31ofYear"( date - 1.00000000 "year" )
   ENDIF;

    END;

    FUNCTION       "Dec31ofYear" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "Determines the day of the year for December 31 making corrections for leap years if necessary. -CE 6/11/13";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      IF ( "LeapYear"( date ) )
   THEN
      "OffsetDate"( date, "Units NONE"( 366.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
   ELSE
      "OffsetDate"( date, "Units NONE"( 365.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
   ENDIF;

    END;

    FUNCTION       "DetermineMonthlyDistribution" ( STRING slot2check, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      ( "FlowToVolume"( "GetSlot"( slot2check ) [date], date ) / "SumFlowsToVolume"( "GetSlot"( slot2check ), "OffsetDate"( date, - ( "GetMonth"( date ) - 1.00000000 ) COMMENTED_BY "The number to subtract from date to go to January of the year in Date", "1 MONTHS" ) COMMENTED_BY "Evaluates to January of the year in date", "OffsetDate"( date, ( 12.00000000 - "GetMonth"( date ) ) COMMENTED_BY "The number to add to date to go to December of the year in Date", "1 MONTHS" ) COMMENTED_BY "Evaluates to December of the year in date" ) ) COMMENTED_BY "Determines the monthly distribution of any slot.  Returns the poriton of demand/flow of <br>the date passed to the function for the slot passed to the function";

    END;

    FUNCTION       "ECDF" ( LIST Data, NUMERIC num )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      FOR ( NUMERIC val IN Data ) WITH NUMERIC result = 0.00000000 DO
      IF ( val <= num )
      THEN
         result + 1.00000000
      ELSE
         result
      ENDIF
   ENDFOR / LENGTH Data;

    END;

    FUNCTION       "EnsureReleaseLimits" ( NUMERIC release, NUMERIC lowerLimit, NUMERIC upperLimit )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    MIN_CONSTRAINT lowerLimit;
    MAX_CONSTRAINT upperLimit;
    BEGIN

      release;

    END;

    FUNCTION       "EqLevel" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "ft";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH STRING waterYear = IF ( date >= @"October 31" )
   THEN
      "GetYearAsString"( "OffsetDate"( date, 1.00000000, "1 years" ) )
   ELSE
      "GetYearAsString"( date )
   ENDIF DO
      $ "PowellData.EqualizationElevationTable" [waterYear, 0.00000000]
   ENDWITH;

    END;

    FUNCTION       "EstimateBankStorage" ( OBJECT res, NUMERIC startStorage, NUMERIC endStorage, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      ( endStorage - "EstimateEvap"( res, startStorage, endStorage, startDate, endDate ) - startStorage ) COMMENTED_BY "Available volume to contibute to bank storage" * res & "Bank Storage Coefficient" [0.00000000, 0.00000000] COMMENTED_BY "proportion of volume available for bank storage <br>that actually becomes bank storage";

    END;

    FUNCTION       "EstimateDeltaStorageEOWY" ( OBJECT res )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      "RuleCurveStorage"( res, "RelativeEOWYDate"( @"t" ) ) - "PrevStorage"( res );

    END;

    FUNCTION       "EstimateDeltaStorageOND" ( OBJECT res )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      "RuleCurveStorage"( res, @"24:00:00 December Max DayOfMonth, Current Year" ) - "RuleCurveStorage"( res, @"24:00:00 October Max DayOfMonth, Current Year" );

    END;

    FUNCTION       "EstimateEvap" ( OBJECT res, NUMERIC startStorage, NUMERIC endStorage, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      "FlowToVolume"( ( "StorageToArea"( res, startStorage ) + "StorageToArea"( res, endStorage ) ) / 2.00000000 * "SumEvapCoeffCRSS"( res, "GetMonth"( startDate ) - 1.00000000, "GetMonth"( endDate ) - 1.00000000 ), endDate );

    END;

    FUNCTION       "EstimateEvaporation" ( OBJECT reservoir, NUMERIC startStorage, NUMERIC endStorage, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      IF ( ( STRINGIFY reservoir ) == "Starvation" OR ( STRINGIFY reservoir ) == "TaylorPark" )
   THEN
      0.00000000 "acre-ft"
   ELSE
      "FlowToVolume"( ( "StorageToArea"( reservoir, startStorage ) + "StorageToArea"( reservoir, endStorage ) ) / 2.00000000 * "SumEvapCoeffCRSS"( reservoir, "GetMonth"( startDate ) - 1.00000000, "GetMonth"( endDate ) - 1.00000000 ), endDate )
   ENDIF;

    END;

    FUNCTION       "GetElement" ( LIST list, NUMERIC i )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      GET @INDEX i FROM list;

    END;

    FUNCTION       "HasAnyRuleFired" ( LIST rules )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      FOR ( STRING rule IN rules ) WITH BOOLEAN fired = FALSE DO
      IF ( "HasRuleFiredSuccessfully"( rule ) AND NOT fired )
      THEN
         TRUE
      ELSE
         fired
      ENDIF
   ENDFOR;

    END;

    FUNCTION       "Interpolate" ( NUMERIC x, NUMERIC x0, NUMERIC x1, NUMERIC y0, NUMERIC y1 )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This function does a linear interpolation of values in a table. -CE 6/12/13";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      y0 + ( x - x0 ) / ( x1 - x0 ) * ( y1 - y0 );

    END;

    FUNCTION       "IsYearDemandVariabilityAndRunCycle4" ( DATETIME date )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      IF ( "GetRunCycleIndex"(  ) == 4.00000000 AND ( NaNToZero ( $ "LowerBasinDemandVariability.AbvHooverTriggerSet" ["Dec31ofYear"( date )] ) == 1.00000000 OR NaNToZero ( $ "LowerBasinDemandVariability.AbvHooverTriggerSet" ["Dec31ofYear"( date )] ) == - 1.00000000 OR NaNToZero ( $ "LowerBasinDemandVariability.PowellUnregTrigSet" ["Dec31ofYear"( date )] ) == 1.00000000 OR NaNToZero ( $ "LowerBasinDemandVariability.PowellUnregTrigSet" ["Dec31ofYear"( date )] ) == - 1.00000000 ) )
   THEN
      TRUE
   ELSE
      FALSE
   ENDIF;

    END;

    FUNCTION       "IsSpringPeakMonth" ( OBJECT res, DATETIME date )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      IF ( res == % "Navajo" )
   THEN
      IF ( date >= @"24:00:00 April 31, Current Year" AND date <= @"24:00:00 June 30, Current Year" )
      THEN
         TRUE
      ELSE
         FALSE
      ENDIF
   ELSE
      STOP_RUN "Invalid reservoir passed to IsSpringPeakMonth"
   ENDIF;

    END;

    FUNCTION       "July31ofYear" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "Determines the day of the year for July 31 making corrections for leap years if necessary. -CE 6/11/13";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      IF ( "LeapYear"( date ) )
   THEN
      "OffsetDate"( date, "Units NONE"( 213.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
   ELSE
      "OffsetDate"( date, "Units NONE"( 212.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
   ENDIF;

    END;

    FUNCTION       "MeadPumpingDemandVariabilityFactor" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This function checks the lower basin demand threshhold for the Local Inflows above Hoover and applies the changes to Mead pumping where necessary.  The function takes a date and checks the conditions for the year of that date then returns a factor for increased or decreased pumping from Mead. TP 3/12/2013";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      IF ( "IsMRM"(  ) AND NOT "IsSurplusOrShortage"(  ) )
   THEN
      IF ( $ "LowerBasinDemandVariability.LocalInflowAboveHooverTrigger" ["Dec31ofYear"( date )] > $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "SideInflowAboveHoover90"] )
      THEN
         0.95000000
      ELSE
         IF ( $ "LowerBasinDemandVariability.LocalInflowAboveHooverTrigger" ["Dec31ofYear"( date )] < $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "SideInflowAboveHoover10"] )
         THEN
            1.05000000
         ELSE
            1.00000000
         ENDIF
      ENDIF
   ELSE
      1.00000000
   ENDIF;

    END;

    FUNCTION       "AgUsersBelowParkerDemandVariabilityFactor" ( DATETIME date, STRING AgUser )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This function checks the lower basin demand threshhold for the Local Inflows above Hoover and applies the changes to Mead pumping where necessary.  The function takes a date and checks the conditions for the year of that date then returns a factor for increased or decreased pumping from Mead. TP 3/12/2013";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      IF ( "IsMRM"(  ) AND NOT "IsSurplusOrShortage"(  ) )
   THEN
      IF ( $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["Dec31ofYear"( date )] > $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "SideInflowBelowParker90"] )
      THEN
         0.90000000
      ELSE
         IF ( $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["Dec31ofYear"( date )] < $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "SideInflowBelowParker10"] )
         THEN
            IF ( AgUser == "IID" OR AgUser == "CVWD" OR AgUser == "YMIDD" OR AgUser == "WMIDD" )
            THEN
               1.00000000
            ELSE
               1.05000000
            ENDIF
         ELSE
            1.00000000
         ENDIF
      ENDIF
   ELSE
      1.00000000
   ENDIF;

    END;

    FUNCTION       "CAPDemandVariabilityFactor" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This function checks the lower basin demand threshhold for the Local Inflows above Hoover and applies the changes to Mead pumping where necessary.  The function takes a date and checks the conditions for the year of that date then returns a factor for increased or decreased pumping from Mead. TP 3/12/2013";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      IF ( "IsMRM"(  ) AND NOT "IsSurplusOrShortage"(  ) )
   THEN
      IF ( $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["Dec31ofYear"( date )] > $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "SideInflowBelowParker90"] )
      THEN
         0.90000000
      ELSE
         IF ( $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["Dec31ofYear"( date )] < $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "SideInflowBelowParker10"] )
         THEN
            WITH NUMERIC volOfAZAgScheduled = FOR ( DATETIME dateSum IN "GetDates"( "OffsetDate"( "Dec31ofYear"( date ), - 11.00000000, "1 Months" ), "Dec31ofYear"( date ), "1 Months" ) ) STAT_SUM
               FOR ( OBJECT azNonCapWaterUser IN "ListSubbasin"( "ArizonaNonCAPWaterUsers" ) ) STAT_SUM
                  "FlowToVolume"( azNonCapWaterUser & "Diversion Requested" [dateSum], dateSum )
               ENDFOR
            ENDFOR DO
               WITH NUMERIC diffVolAgDivAZ = $ "AnnualWaterUse.Arizona_Apportionment" ["Dec31ofYear"( date )] - volOfAZAgScheduled DO
                  WITH NUMERIC volOfScheduledCAPDiv = "SumSlot"( $ "Arizona_CU_Schedules.CAP", "OffsetDate"( "Dec31ofYear"( date ), - 11.00000000, "1 Months" ), "Dec31ofYear"( date ) ) DO
                     WITH NUMERIC ratioFullAllocToAgDiv = diffVolAgDivAZ / volOfScheduledCAPDiv DO
                        IF ( ratioFullAllocToAgDiv > 1.00000000 )
                        THEN
                           ratioFullAllocToAgDiv
                        ELSE
                           ratioFullAllocToAgDiv
                        ENDIF
                     ENDWITH
                  ENDWITH
               ENDWITH
            ENDWITH COMMENTED_BY "This needs to be changed to take into account All ofthe Ag Diversions for Arizona below Parker Dam <br>so that the total diversion does not exceede 2.8 MAF for the given year. All of the ag diversions are not included here. TP 3/12/2013<br>Added a new Sub Basin called ArizonaNonCAPWaterUsers and now this issue is resolved TP 1/28/2015"
         ELSE
            1.00000000
         ENDIF
      ENDIF
   ELSE
      1.00000000
   ENDIF;

    END;

    FUNCTION       "IsMRM" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "This Function will determine if the model is in a deterministic mode or an MRM mode.  Right now, the deterministic run is as high as 32 months and the MRM is as short as 60 months. so anything over 3 years difference between the year of the finish timestep and the year of the start timestep will be an MRM run. The function returns True if the model is in an MRM run and False if the model is not. If the MRM is only run for the deterministic period, this function does not apply. Other methods of determining an MRM run should be implemented here if they are known. TP 3/13/2013<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      IF ( IsNaN $ "LowerBasinDemandVariability.DetermCheck" [@"Start Timestep"] OR $ "LowerBasinDemandVariability.DetermCheck" [@"Start Timestep"] == 1.00000000 )
   THEN
      FALSE
   ELSE
      TRUE
   ENDIF;

    END;

    FUNCTION       "IsSurplusOrShortage" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "This Function checks the two limits of Shortage or Surplus and returns a boolean statement saying if the water year is in surplus or shortage. This is being used in the LC Demand Variability Logic. TP 4/18/2013<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      IF ( $ "Mead.Pool Elevation" [@"24:00:00 December 31, Previous Year"] <= $ "Shortage.Mead Shortage Elevations" [0.00000000, 0.00000000] )
   THEN
      TRUE
   ELSE
      IF ( $ "Mead.Pool Elevation" [@"24:00:00 December 31, Previous Year"] >= $ "Surplus.Domestic Surplus Trigger Elevation" [] )
      THEN
         TRUE
      ELSE
         FALSE
      ENDIF
   ENDIF;

    END;

    FUNCTION       "MonthIs" ( LIST months )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns True if the current timestep is in the list months and False if it is not. - CE 6/11/13";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      "GetMonthAsString"( @"t" ) IN months;

    END;

    FUNCTION       "MyGetSlot" ( OBJECT obj, STRING slot )
    RETURN_TYPE    SLOT;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      "GetSlot"( ( STRINGIFY obj ) CONCAT ( "." CONCAT slot ) );

    END;

    FUNCTION       "MyPercentRank" ( LIST Data, NUMERIC num )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      1.00000000;

    END;

    FUNCTION       "OND" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      @"24:00:00 October Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year";

    END;

    FUNCTION       "PrevStorage" ( OBJECT res )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-ft";
    DESCRIPTION    "Returns the storage of the argument object for the previous timestep. -CE 6/11/13";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      res & "Storage" [@"t - 1"];

    END;

    FUNCTION       "Quantile" ( LIST Data, NUMERIC prob )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      GET @INDEX 1.00000000 FROM Data;

    END;

    FUNCTION       "RelativeEOWYDate" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns the datetime at the end of the water year relative the the current timestep. e.g. if the month is June, the function would return @&quot;t+4&quot;";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      "OffsetDate"( date, "MonthsUntilEOWY"( date ), "1 months" );

    END;

    FUNCTION       "RuleCurveStorage" ( OBJECT res, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      $ "UBRuleCurveData.BaseRuleCurves" [STRINGIFY res, "GetMonthAsString"( date )];

    END;

    FUNCTION       "StartMonthIsSeptember" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      @"t" == @"Start Timestep" AND "MonthIs"( { "September" } );

    END;

    FUNCTION       "StartYear" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns True if the timestep is the start timestep, and False otherwise. -CE 6/11/13";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      "GetYearAsString"( @"t" ) == "GetYearAsString"( @"Start Timestep" );

    END;

    FUNCTION       "SumEvapCoeffCRSS" ( OBJECT res, NUMERIC startRow, NUMERIC endRow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      "SumTableColumn"( res & "Evaporation Coefficients", 0.00000000, startRow, endRow );

    END;

    FUNCTION       "Units NONE" ( NUMERIC number )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Removes the &quot;day&quot; units from a value. - CE 6/11/13";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      number / 1.00000000 "day";

    END;

  END;

  UTILITY_GROUP "Headwater Reservoir Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  BEGIN

    FUNCTION       "GetEOMTargetElevation" ( OBJECT res, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "ft";
    DESCRIPTION    "This function takes a reservoir object and a date, and then returns the end of month target elevation for that reservoir on that date.  This function requires that the reservoirs data object be named &quot;[reservoir]Data&quot; and that the guide slot that holds the target elevations be named &quot;[reservoir]Guide&quot;.  - sc 12/16/10";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH OBJECT resDataObj = "GetObject"( ( STRINGIFY res ) CONCAT "Data" ) DO
      WITH STRING guideSlotName = ( STRINGIFY res ) CONCAT "Guide" DO
         resDataObj & guideSlotName [date, "Target Elevation"]
      ENDWITH
   ENDWITH;

    END;

    FUNCTION       "GetReservoirMinConstraint_OLD" ( OBJECT reservoir, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This function takes a reservoir and a date and returns the minimum constraint to the outflow allowed from that reservoir on that date. - sc 12/16/10";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      IF ( reservoir == % "TaylorPark" )
   THEN
      "TaylorParkMinReleaseConstraint"( date )
   ELSE
      IF ( reservoir == % "Vallecito" )
      THEN
         "VallecitoMinReleaseConstraint"( date )
      ELSE
         STOP_RUN "No such Reservoir"
      ENDIF
   ENDIF;

    END;

    FUNCTION       "GetReservoirMinConstraint" ( OBJECT reservoir, DATETIME date, NUMERIC prevElev )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This function takes a reservoir and a date and returns the minimum constraint to the outflow allowed from that reservoir on that date. - sc 12/16/10";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      IF ( reservoir == % "TaylorPark" )
   THEN
      "Min"( "TaylorParkMinReleaseConstraint"( date ) COMMENTED_BY "Minimum flow requirements", "SolveOutflow"( % "TaylorPark", $ "TaylorPark.Inflow" [date], "ElevationToStorage"( % "TaylorPark", 9183.00000000 "ft" ), "ElevationToStorage"( % "TaylorPark", prevElev ), date ) COMMENTED_BY "Maximum possible release from reservoir to dead pool. -tv 8.1.12" )
   ELSE
      IF ( reservoir == % "Vallecito" )
      THEN
         "VallecitoMinReleaseConstraint"( date )
      ELSE
         STOP_RUN "No such Reservoir"
      ENDIF
   ENDIF;

    END;

    FUNCTION       "GetOneMonthReservoirEvapVolume" ( OBJECT reservoir, DATETIME date, NUMERIC previousPoolElevation, NUMERIC previousStorage )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-ft";
    DESCRIPTION    "This function takes a reservoir object, a datetime, a pool elevation and storage at the end of the timestep previous to the passed-in date.  It returns the volume of water evaporated from the passed-in reservoir during the passed-in date timestep. - sc 12/19/10";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH NUMERIC evapHeight = reservoir & "Evaporation Coefficients" ["GetMonth"( date ) - 1.00000000, 0.00000000] * "GetDaysInMonth"( date ) DO
      WITH NUMERIC elevationAfterEvap = previousPoolElevation - evapHeight DO
         WITH NUMERIC storageAfterEvap = "TableInterpolation"( reservoir & "Elevation Volume Table", 0.00000000, 1.00000000, elevationAfterEvap, date ) DO
            previousStorage - storageAfterEvap
         ENDWITH
      ENDWITH
   ENDWITH;

    END;

    FUNCTION       "GetReservoirMaxConstraint" ( OBJECT reservoir, DATETIME date, NUMERIC prevElev )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This function takes a reservoir and a date and returns the maximum constraint to the outflow allowed from that reservoir on that date. - sc 12/16/10";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      IF ( reservoir == % "TaylorPark" )
   THEN
      "TaylorParkMaxReleaseConstraint"( date, prevElev )
   ELSE
      IF ( reservoir == % "Vallecito" )
      THEN
         "VallecitoMaxReleaseConstraint"( date, prevElev )
      ELSE
         STOP_RUN "No such Reservoir"
      ENDIF
   ENDIF;

    END;

    FUNCTION       "SolveConstrainedOutflow" ( OBJECT reservoir, NUMERIC elevationTarget, NUMERIC previousPoolElev, NUMERIC minConstraint, NUMERIC maxConstraint, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "This function takes a reservoir object, an end-of-timestep elevation target, a previous timestep elevation, a minimum release constraint, a maximum release constraint, and a datetime.  It returns a release value for the passed in reservoir on the passed in date that hits the elevation target, or gets as close as possible within the passed in constraints.  Note the min and max constraints are imposed in the Post-Execution checks and do not appear in the body of the function. - sc 12/14/10";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    MAX_CONSTRAINT maxConstraint;
    MIN_CONSTRAINT minConstraint;
    BEGIN

      WITH NUMERIC releaseToMeetGuideElevation = "SolveOutflow"( reservoir, reservoir & "Inflow" [date], "ElevationToStorage"( reservoir, elevationTarget ), "ElevationToStorage"( reservoir, previousPoolElev ), date ) DO
      releaseToMeetGuideElevation
   ENDWITH;

    END;

    FUNCTION       "SimulateHeadwaterRes_OLD" ( OBJECT reservoir )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "This function takes a reservoir object and returns a list of three-item lists, each sub-list of the form &lcub;date, outflow, end-of-month pool elevation&rcub;. There is one sublist for each timestep in the run.<br>The function operates the passed-in reservoir basically according to a guide curve specified on the reservoirs data object.  A minimum constraint and maximum constraint to the outflow are calculated for each timestep that provides a floor and ceiling to the outflow that can be initiated to hit the elevation target prescribed by the guide curve.  A water balance calculation is performed at each timestep to determine the pool elevation at the end of the timestep. Then it steps forward one timestep does another water balance calculation, and continues doing this until it reaches the last timestep of the run.  The water balance equation used here is:<br><br>[Previous End of Month Storage] + [Reservoir Inflow] - [Reservoir Outflow] - [Reservoir Evaporation] = [End of Month Storage].  - sc 12/20/10";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      FOR ( DATETIME date IN @"Start Timestep" TO @"Finish Timestep" ) WITH LIST result = {  } DO
      WITH NUMERIC previousPoolElevation = IF ( date == @"Start Timestep" )
      THEN
         reservoir & "Pool Elevation" [@"t - 1"]
      ELSE
         GET @INDEX 2.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result
      ENDIF DO
         WITH NUMERIC resOutflow = WITH NUMERIC elevationTarget = "GetEOMTargetElevation"( reservoir, date ) DO
            WITH NUMERIC minConstraint = "GetReservoirMinConstraint"( reservoir, date ) DO
               WITH NUMERIC maxConstraint = "GetReservoirMaxConstraint"( reservoir, date, previousPoolElevation ) DO
                  "SolveConstrainedOutflow"( reservoir, elevationTarget, previousPoolElevation, minConstraint, maxConstraint, date )
               ENDWITH
            ENDWITH
         ENDWITH DO
            WITH NUMERIC PreviousStorage = "TableInterpolation"( reservoir & "Elevation Volume Table", 0.00000000, 1.00000000, previousPoolElevation, date ) DO
               WITH NUMERIC releaseVolume = resOutflow * "GetDaysInMonth"( date ) DO
                  WITH NUMERIC inflowVolume = reservoir & "Inflow" [date] * "GetDaysInMonth"( date ) DO
                     WITH NUMERIC evapVolume = "GetOneMonthReservoirEvapVolume"( reservoir, date, previousPoolElevation, PreviousStorage ) DO
                        WITH NUMERIC newStorage = PreviousStorage + inflowVolume - releaseVolume - evapVolume DO
                           WITH NUMERIC EOMPoolElevation = "TableInterpolation"( reservoir & "Elevation Volume Table", 1.00000000, 0.00000000, newStorage, date ) DO
                              APPEND { date , resOutflow , EOMPoolElevation } ONTO result
                           ENDWITH
                        ENDWITH
                     ENDWITH
                  ENDWITH
               ENDWITH
            ENDWITH
         ENDWITH
      ENDWITH
   ENDFOR;

    END;

    FUNCTION       "SimulateHeadwaterRes" ( OBJECT reservoir )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "This function takes a reservoir object and returns a list of three-item lists, each sub-list of the form &lcub;date, outflow, end-of-month pool elevation&rcub;. There is one sublist for each timestep in the run.<br>The function operates the passed-in reservoir basically according to a guide curve specified on the reservoirs data object.  A minimum constraint and maximum constraint to the outflow are calculated for each timestep that provides a floor and ceiling to the outflow that can be initiated to hit the elevation target prescribed by the guide curve.  A water balance calculation is performed at each timestep to determine the pool elevation at the end of the timestep. Then it steps forward one timestep does another water balance calculation, and continues doing this until it reaches the last timestep of the run.  The water balance equation used here is:<br><br>[Previous End of Month Storage] + [Reservoir Inflow] - [Reservoir Outflow] - [Reservoir Evaporation] = [End of Month Storage].  - sc 12/20/10";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      FOR ( DATETIME date IN @"Start Timestep" TO @"Finish Timestep" ) WITH LIST result = {  } DO
      WITH NUMERIC previousPoolElevation = IF ( date == @"Start Timestep" )
      THEN
         reservoir & "Pool Elevation" [@"t - 1"]
      ELSE
         GET @INDEX 2.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result
      ENDIF DO
         WITH NUMERIC resOutflow = WITH NUMERIC elevationTarget = "GetEOMTargetElevation"( reservoir, date ) DO
            WITH NUMERIC minConstraint = "GetReservoirMinConstraint"( reservoir, date, previousPoolElevation ) COMMENTED_BY "Added additional argument (previous pool elevation) required by changes to the GetReservoirMinConstraint function. -tv 8.1.12" DO
               WITH NUMERIC maxConstraint = "GetReservoirMaxConstraint"( reservoir, date, previousPoolElevation ) DO
                  "SolveConstrainedOutflow"( reservoir, elevationTarget, previousPoolElevation, minConstraint, maxConstraint, date )
               ENDWITH
            ENDWITH
         ENDWITH DO
            WITH NUMERIC PreviousStorage = "TableInterpolation"( reservoir & "Elevation Volume Table", 0.00000000, 1.00000000, previousPoolElevation, date ) DO
               WITH NUMERIC releaseVolume = resOutflow * "GetDaysInMonth"( date ) DO
                  WITH NUMERIC inflowVolume = reservoir & "Inflow" [date] * "GetDaysInMonth"( date ) DO
                     WITH NUMERIC evapVolume = "GetOneMonthReservoirEvapVolume"( reservoir, date, previousPoolElevation, PreviousStorage ) DO
                        WITH NUMERIC newStorage = PreviousStorage + inflowVolume - releaseVolume - evapVolume DO
                           WITH NUMERIC EOMPoolElevation = "TableInterpolation"( reservoir & "Elevation Volume Table", 1.00000000, 0.00000000, newStorage, date ) DO
                              APPEND { date , resOutflow , EOMPoolElevation } ONTO result
                           ENDWITH
                        ENDWITH
                     ENDWITH
                  ENDWITH
               ENDWITH
            ENDWITH
         ENDWITH
      ENDWITH
   ENDFOR;

    END;

  END;

  UTILITY_GROUP "Aspinal/Gunnison Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  BEGIN

    FUNCTION       "BlueMesaEOMElevationTarget" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "ft";
    DESCRIPTION    "This function takes a date and returns the end-of-month elevation target for Blue Mesa Reservoir.  It does this by reading the appropriate row from the BlueMesaData.BlueMesaGuide slot.  The only exception is that if the reservoir did not fill in June, then in July the function will return the June entry in the table. - sc 12/28/10";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      IF ( "GetMonthAsString"( date ) IN { "June" , "July" } )
   THEN
      IF ( "MaxItem"( "GetSlotVals"( $ "BlueMesa.Pool Elevation", @"t - 2", @"t - 1" ) ) >= $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 June 30, Current Year", "Target Elevation"] )
      THEN
         $ "BlueMesaData.BlueMesaGuide" [@"t", "Target Elevation"]
      ELSE
         $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 June 30, Current Year", "Target Elevation"]
      ENDIF
   ELSE
      $ "BlueMesaData.BlueMesaGuide" [@"t", "Target Elevation"]
   ENDIF;

    END;

    FUNCTION       "BlueMesaReleaseMAXConstraintByMonth_OLD" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "This function takes a date.  It returns the maximum constraint (ceiling) for the Blue Mesa release on the passed-in date.  The max constraint will not necessarily be the release, just provide an upper bound for that months release. - sc 12/28/10";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      IF ( "GetMonthAsString"( date ) IN { "December" , "January" , "February" , "March" , "April" , "August" , "September" } )
   THEN
      "Max"( "SolveBlueMesaReleaseForCrystalReleaseTarget"( 2100.00000000 "cfs", @"t" ), "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7515.00000000 "ft" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date ) )
   ELSE
      IF ( "GetMonthAsString"( date ) IN { "October" , "November" } )
      THEN
         "SolveBlueMesaReleaseForCrystalReleaseTarget"( 1200.00000000 "cfs", @"t" )
      ELSE
         IF ( "GetMonthAsString"( date ) IN { "June" , "July" } )
         THEN
            "Max"( "SolveBlueMesaReleaseForCrystalReleaseTarget"( 3000.00000000 "cfs", @"t" ), "VolumeToFlow"( "PrevStorage"( % "BlueMesa" ), @"t" ) + $ "BlueMesa.Inflow" [] - "VolumeToFlow"( "ElevationToStorage"( % "BlueMesa", 7519.00000000 "ft" ), @"t" ) )
         ELSE
            9999999.00000000 "cfs"
         ENDIF
      ENDIF
   ENDIF;

    END;

    FUNCTION       "BlueMesaReleaseMAXConstraintByMonth" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "This function takes a date.  It returns the maximum constraint (ceiling) for the Blue Mesa release on the passed-in date.  The max constraint will not necessarily be the release, just provide an upper bound for that months release. - sc 12/28/10";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      IF ( "GetMonthAsString"( date ) IN { "December" , "January" , "February" , "March" , "April" , "August" , "September" , "October" COMMENTED_BY "Move october and november to 2100 limit, per Paul D. - tv 7.26.12" , "November" } )
   THEN
      "Max"( "SolveBlueMesaReleaseForCrystalReleaseTarget"( 2100.00000000 "cfs", @"t" ), "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7516.40000000 "ft" COMMENTED_BY "change to 7516.4 ft, per Paul D. - tv 7.26.12" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date ) )
   ELSE
      IF ( "GetMonthAsString"( date ) IN { "June" , "July" } )
      THEN
         "Max"( "SolveBlueMesaReleaseForCrystalReleaseTarget"( 4150.00000000 "cfs" COMMENTED_BY "Max at 4150 cfs, per Paul D. - tv 7.26.12", @"t" ), "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7519.40000000 "ft" COMMENTED_BY "change to 7519.4 ft, per Paul D. - tv 7.26.12" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date ) COMMENTED_BY "Changed from mass balance to SolveOutflow function - tv 7.26.12" )
      ELSE
         9999999.00000000 "cfs"
      ENDIF
   ENDIF;

    END;

    FUNCTION       "BlueMesaReleaseMINConstraintByMonth_OLD" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "This function takes a date.  It returns the minimum constraint (floor) for the Blue Mesa release on the passed-in date.  The min constraint will not necessarily be the release, just provide an upper bound for that month's release. - sc 12/28/10";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH NUMERIC DownstreamFlowBasedConstraint = "BlueMesaReleaseMINConstraint_DownstreamFlow"( @"t" ) DO
      WITH NUMERIC ReservoirElevationBasedConstraint = "BlueMesaReleaseMINConstraint_ResElevation"( @"t" ) DO
         "Max"( DownstreamFlowBasedConstraint, ReservoirElevationBasedConstraint )
      ENDWITH
   ENDWITH;

    END;

    FUNCTION       "BlueMesaReleaseMINConstraintByMonth" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "This function takes a date.  It returns the minimum constraint (floor) for the Blue Mesa release on the passed-in date.  The min constraint will not necessarily be the release, just provide an upper bound for that month's release. - sc 12/28/10";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH NUMERIC DownstreamFlowBasedConstraint = "BlueMesaReleaseMINConstraint_DownstreamFlow"( @"t" ) DO
      WITH NUMERIC ReservoirElevationBasedConstraint = "BlueMesaReleaseMINConstraint_ResElevation"( @"t" ) DO
         "Min"( "Max"( DownstreamFlowBasedConstraint, ReservoirElevationBasedConstraint ), "SolveOutflow"( % "BlueMesa", $ "BlueMesa.Inflow" [@"t"], "ElevationToStorage"( % "BlueMesa", 7358.01000000 "ft" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), @"t" ) COMMENTED_BY "The maximum that the reservoir can release to the bottom of outlets at 7358 ft. Added 8/1/12 - tv" )
      ENDWITH
   ENDWITH;

    END;

    FUNCTION       "BlueMesaReleaseMINConstraint_ResElevation_OLD" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "This function takes a date.  It returns the minimum constraint (floor) for the Blue Mesa release on the passed-in date.  The min constraint will not necessarily be the release, just provide an upper bound for that month's release. - sc 12/28/10";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      IF ( "GetMonthAsString"( date ) IN { "January" , "February" } )
   THEN
      WITH NUMERIC MayReleaseVolume = $ "BlueMesaData.MayReleaseVolume" [@"24:00:00 December 31, Current Year"] DO
         WITH NUMERIC totalInflowVolumeThruJuly = "SumFlowsToVolume"( $ "BlueMesa.Inflow", date, @"24:00:00 July 31, Current Year" ) DO
            WITH NUMERIC RemainingVolumeAfterFill = "PrevStorage"( % "BlueMesa" ) + totalInflowVolumeThruJuly - "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 June 30, Current Year", "Target Elevation"] ) - MayReleaseVolume DO
               "VolumeToFlow"( RemainingVolumeAfterFill * 0.15000000, date )
            ENDWITH
         ENDWITH
      ENDWITH
   ELSE
      IF ( "GetMonthAsString"( date ) IN { "February" } )
      THEN
         WITH NUMERIC MayReleaseVolume = $ "BlueMesaData.MayReleaseVolume" [@"24:00:00 December 31, Current Year"] DO
            WITH NUMERIC totalInflowVolumeThruJuly = "SumFlowsToVolume"( $ "BlueMesa.Inflow", date, @"24:00:00 July 31, Current Year" ) DO
               WITH NUMERIC RemainingVolumeAfterFill = "PrevStorage"( % "BlueMesa" ) + totalInflowVolumeThruJuly - "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 June 30, Current Year", "Target Elevation"] ) - MayReleaseVolume DO
                  "VolumeToFlow"( RemainingVolumeAfterFill * 0.20000000, date )
               ENDWITH
            ENDWITH
         ENDWITH
      ELSE
         IF ( "GetMonthAsString"( date ) IN { "March" } )
         THEN
            WITH NUMERIC MayReleaseVolume = $ "BlueMesaData.MayReleaseVolume" [@"24:00:00 December 31, Current Year"] DO
               WITH NUMERIC totalInflowVolumeThruJuly = "SumFlowsToVolume"( $ "BlueMesa.Inflow", date, @"24:00:00 July 31, Current Year" ) DO
                  WITH NUMERIC RemainingVolumeAfterFill = "PrevStorage"( % "BlueMesa" ) + totalInflowVolumeThruJuly - "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 June 30, Current Year", "Target Elevation"] ) - MayReleaseVolume DO
                     "VolumeToFlow"( RemainingVolumeAfterFill * 0.20000000, date )
                  ENDWITH
               ENDWITH
            ENDWITH
         ELSE
            IF ( "GetMonthAsString"( date ) IN { "April" } )
            THEN
               WITH NUMERIC MayReleaseVolume = $ "BlueMesaData.MayReleaseVolume" [@"24:00:00 December 31, Current Year"] DO
                  WITH NUMERIC totalInflowVolumeThruJuly = "SumFlowsToVolume"( $ "BlueMesa.Inflow", date, @"24:00:00 July 31, Current Year" ) DO
                     WITH NUMERIC RemainingVolumeAfterFill = "PrevStorage"( % "BlueMesa" ) + totalInflowVolumeThruJuly - "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 June 30, Current Year", "Target Elevation"] ) - MayReleaseVolume DO
                        "VolumeToFlow"( RemainingVolumeAfterFill * 0.35000000, date )
                     ENDWITH
                  ENDWITH
               ENDWITH
            ELSE
               IF ( "GetMonthAsString"( date ) IN { "June" } )
               THEN
                  WITH NUMERIC MayReleaseVolume = $ "BlueMesaData.MayReleaseVolume" [@"24:00:00 December 31, Current Year"] DO
                     WITH NUMERIC totalInflowVolumeThruJuly = "SumFlowsToVolume"( $ "BlueMesa.Inflow", date, @"24:00:00 July 31, Current Year" ) DO
                        WITH NUMERIC RemainingVolumeAfterFill = "PrevStorage"( % "BlueMesa" ) + totalInflowVolumeThruJuly - "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 June 30, Current Year", "Target Elevation"] ) - MayReleaseVolume DO
                           "VolumeToFlow"( RemainingVolumeAfterFill * 0.50000000, date )
                        ENDWITH
                     ENDWITH
                  ENDWITH
               ELSE
                  IF ( "GetMonthAsString"( date ) IN { "July" } )
                  THEN
                     "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7519.00000000 "ft" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date )
                  ELSE
                     IF ( "GetMonthAsString"( date ) IN { "August" } )
                     THEN
                        "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7515.00000000 "ft" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date )
                     ELSE
                        IF ( "GetMonthAsString"( date ) IN { "September" } )
                        THEN
                           0.00000000 "cfs"
                        ELSE
                           IF ( "GetMonthAsString"( date ) IN { "October" } )
                           THEN
                              0.00000000 "cfs"
                           ELSE
                              IF ( "GetMonthAsString"( date ) IN { "November" } )
                              THEN
                                 0.00000000 "cfs"
                              ELSE
                                 0.00000000 "cfs"
                              ENDIF
                           ENDIF
                        ENDIF
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDIF
   ENDIF;

    END;

    FUNCTION       "BlueMesaReleaseMINConstraint_ResElevation" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "This function takes a date.  It returns the minimum constraint (floor) for the Blue Mesa release on the passed-in date.  The min constraint will not necessarily be the release, just provide an upper bound for that month's release. - sc 12/28/10";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      IF ( "GetMonthAsString"( date ) IN { "January" } )
   THEN
      WITH NUMERIC MayReleaseVolume = $ "BlueMesaData.MayReleaseVolume" [@"24:00:00 December 31, Current Year"] DO
         WITH NUMERIC totalInflowVolumeThruJuly = "SumFlowsToVolume"( $ "BlueMesa.Inflow", date, @"24:00:00 July 31, Current Year" ) DO
            WITH NUMERIC RemainingVolumeAfterFill = "PrevStorage"( % "BlueMesa" ) + totalInflowVolumeThruJuly - "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 July 31, Current Year", "Target Elevation"] ) - MayReleaseVolume DO
               "SolveBlueMesaReleaseForBlackCanyonTarget"( "VolumeToFlow"( RemainingVolumeAfterFill * 0.17000000 COMMENTED_BY "Changed this ratio. -tv 8.1.12", date ), date )
            ENDWITH
         ENDWITH
      ENDWITH
   ELSE
      IF ( "GetMonthAsString"( date ) IN { "February" } )
      THEN
         WITH NUMERIC MayReleaseVolume = $ "BlueMesaData.MayReleaseVolume" [@"24:00:00 December 31, Current Year"] DO
            WITH NUMERIC totalInflowVolumeThruJuly = "SumFlowsToVolume"( $ "BlueMesa.Inflow", date, @"24:00:00 July 31, Current Year" ) DO
               WITH NUMERIC RemainingVolumeAfterFill = "PrevStorage"( % "BlueMesa" ) + totalInflowVolumeThruJuly - "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 July 31, Current Year", "Target Elevation"] ) - MayReleaseVolume DO
                  "SolveBlueMesaReleaseForBlackCanyonTarget"( "VolumeToFlow"( RemainingVolumeAfterFill * 0.15000000 COMMENTED_BY "Changed this ratio. -tv 8.1.12", date ), date )
               ENDWITH
            ENDWITH
         ENDWITH
      ELSE
         IF ( "GetMonthAsString"( date ) IN { "March" } )
         THEN
            WITH NUMERIC MayReleaseVolume = $ "BlueMesaData.MayReleaseVolume" [@"24:00:00 December 31, Current Year"] DO
               WITH NUMERIC totalInflowVolumeThruJuly = "SumFlowsToVolume"( $ "BlueMesa.Inflow", date, @"24:00:00 July 31, Current Year" ) DO
                  WITH NUMERIC RemainingVolumeAfterFill = "PrevStorage"( % "BlueMesa" ) + totalInflowVolumeThruJuly - "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 July 31, Current Year", "Target Elevation"] ) - MayReleaseVolume DO
                     "SolveBlueMesaReleaseForBlackCanyonTarget"( "VolumeToFlow"( RemainingVolumeAfterFill * 0.15000000 COMMENTED_BY "Changed this ratio. -tv 8.1.12", date ), date )
                  ENDWITH
               ENDWITH
            ENDWITH
         ELSE
            IF ( "GetMonthAsString"( date ) IN { "April" } )
            THEN
               WITH NUMERIC MayReleaseVolume = $ "BlueMesaData.MayReleaseVolume" [@"24:00:00 December 31, Current Year"] DO
                  WITH NUMERIC totalInflowVolumeThruJuly = "SumFlowsToVolume"( $ "BlueMesa.Inflow", date, @"24:00:00 July 31, Current Year" ) DO
                     WITH NUMERIC RemainingVolumeAfterFill = "PrevStorage"( % "BlueMesa" ) + totalInflowVolumeThruJuly - "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 June 30, Current Year", "Target Elevation"] ) - MayReleaseVolume DO
                        "SolveBlueMesaReleaseForBlackCanyonTarget"( "VolumeToFlow"( RemainingVolumeAfterFill * 0.20000000 COMMENTED_BY "Changed this ratio. -tv 8.1.12", date ), date )
                     ENDWITH
                  ENDWITH
               ENDWITH
            ELSE
               IF ( "GetMonthAsString"( date ) IN { "June" } )
               THEN
                  WITH NUMERIC MayReleaseVolume = $ "BlueMesaData.MayReleaseVolume" [@"24:00:00 December 31, Current Year"] DO
                     WITH NUMERIC totalInflowVolumeThruJuly = "SumFlowsToVolume"( $ "BlueMesa.Inflow", date, @"24:00:00 July 31, Current Year" ) DO
                        WITH NUMERIC RemainingVolumeAfterFill = "PrevStorage"( % "BlueMesa" ) + totalInflowVolumeThruJuly - "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 July 31, Current Year", "Target Elevation"] ) DO
                           "SolveBlueMesaReleaseForBlackCanyonTarget"( "VolumeToFlow"( RemainingVolumeAfterFill * 0.33000000, date ), date )
                        ENDWITH
                     ENDWITH
                  ENDWITH
               ELSE
                  IF ( "GetMonthAsString"( date ) IN { "July" } )
                  THEN
                     "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7519.40000000 "ft" COMMENTED_BY "Changed to 7519.4 ft, per Paul D. - tv 7.26.12" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date )
                  ELSE
                     IF ( "GetMonthAsString"( date ) IN { "August" } )
                     THEN
                        "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7516.40000000 "ft" COMMENTED_BY "Changed to 7516.4 ft, per Paul D. - tv 7.26.12" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date )
                     ELSE
                        IF ( "GetMonthAsString"( date ) IN { "September" } )
                        THEN
                           "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7516.40000000 "ft" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date )
                        ELSE
                           IF ( "GetMonthAsString"( date ) IN { "October" } )
                           THEN
                              "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7516.40000000 "ft" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date )
                           ELSE
                              IF ( "GetMonthAsString"( date ) IN { "November" } )
                              THEN
                                 "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7516.40000000 "ft" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date )
                              ELSE
                                 "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7516.40000000 "ft" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date )
                              ENDIF
                           ENDIF
                        ENDIF
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDIF
   ENDIF;

    END;

    FUNCTION       "BlueMesaReleaseMINConstraint_DownstreamFlow_OLD" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "This function takes a date.  It returns the minimum constraint (floor) for the Blue Mesa release on the passed-in date.  The min constraint will not necessarily be the release, just provide an upper bound for that month's release. - sc 12/28/10";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      IF ( "GetMonthAsString"( date ) IN { "January" } )
   THEN
      "Min"( "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "TunnelReturnFlow.Inflow" [@"t - 1"], @"t" ), "SolveBlueMesaReleaseForCrystalReleaseTarget"( 1000.00000000 "cfs", @"t" ) )
   ELSE
      IF ( "GetMonthAsString"( date ) IN { "February" } )
      THEN
         "Min"( "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "TunnelReturnFlow.Inflow" [@"t - 1"], @"t" ), "SolveBlueMesaReleaseForCrystalReleaseTarget"( 2100.00000000 "cfs", @"t" ) )
      ELSE
         IF ( "GetMonthAsString"( date ) IN { "March" } )
         THEN
            "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinCanyonFlow" [], @"t" )
         ELSE
            IF ( "GetMonthAsString"( date ) IN { "April" } )
            THEN
               "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinCanyonFlow" [], @"t" )
            ELSE
               IF ( "GetMonthAsString"( date ) IN { "June" } )
               THEN
                  "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.ShoulderFlowTarget" [@"24:00:00 December 31, Current Year"], @"t" )
               ELSE
                  IF ( "GetMonthAsString"( date ) IN { "July" } )
                  THEN
                     "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.ShoulderFlowTarget" [@"24:00:00 December 31, Current Year"], @"t" )
                  ELSE
                     IF ( "GetMonthAsString"( date ) IN { "August" } )
                     THEN
                        "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinCanyonFlow" [], @"t" )
                     ELSE
                        IF ( "GetMonthAsString"( date ) IN { "September" } )
                        THEN
                           "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinCanyonFlow" [], @"t" )
                        ELSE
                           IF ( "GetMonthAsString"( date ) IN { "October" } )
                           THEN
                              "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinCanyonFlow" [], @"t" )
                           ELSE
                              IF ( "GetMonthAsString"( date ) IN { "November" } )
                              THEN
                                 "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinCanyonFlow" [], @"t" )
                              ELSE
                                 "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "TunnelReturnFlow.Inflow" [@"t - 1"], @"t" )
                              ENDIF
                           ENDIF
                        ENDIF
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDIF
   ENDIF;

    END;

    FUNCTION       "BlueMesaReleaseMINConstraint_DownstreamFlow" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "This function takes a date.  It returns the minimum constraint (floor) for the Blue Mesa release on the passed-in date.  The min constraint will not necessarily be the release, just provide an upper bound for that month's release. - sc 12/28/10";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH NUMERIC flowLevel = $ "BlueMesaData.MayPeakFlowLevel" ["Dec31ofYear"( @"24:00:00 April 1, Current Year" )] DO
      IF ( "GetMonthAsString"( date ) IN { "January" } )
      THEN
         "Min"( "SolveBlueMesaReleaseForBlackCanyonTarget"( "Max"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], $ "TunnelReturnFlow.Inflow" [@"t - 1"] ), @"t" ), "SolveBlueMesaReleaseForCrystalReleaseTarget"( 1000.00000000 "cfs", @"t" ) )
      ELSE
         IF ( "GetMonthAsString"( date ) IN { "February" } )
         THEN
            "Min"( "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], @"t" ), "SolveBlueMesaReleaseForCrystalReleaseTarget"( 1000.00000000 "cfs", @"t" ) )
         ELSE
            IF ( "GetMonthAsString"( date ) IN { "March" } )
            THEN
               "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], @"t" )
            ELSE
               IF ( "GetMonthAsString"( date ) IN { "April" } )
               THEN
                  "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], @"t" )
               ELSE
                  IF ( "GetMonthAsString"( date ) IN { "June" } )
                  THEN
                     "SolveBlueMesaReleaseForBlackCanyonTarget"( "Max"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], $ "BlueMesaData.BaseCanyonTargetFlows" [date, flowLevel] ), @"t" )
                  ELSE
                     IF ( "GetMonthAsString"( date ) IN { "July" } )
                     THEN
                        "SolveBlueMesaReleaseForBlackCanyonTarget"( "Max"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], $ "BlueMesaData.BaseCanyonTargetFlows" [date, flowLevel] ), @"t" )
                     ELSE
                        IF ( "GetMonthAsString"( date ) IN { "August" } )
                        THEN
                           "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], @"t" )
                        ELSE
                           IF ( "GetMonthAsString"( date ) IN { "September" } )
                           THEN
                              "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], @"t" )
                           ELSE
                              IF ( "GetMonthAsString"( date ) IN { "October" } )
                              THEN
                                 "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], @"t" )
                              ELSE
                                 IF ( "GetMonthAsString"( date ) IN { "November" } )
                                 THEN
                                    "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], @"t" )
                                 ELSE
                                    "SolveBlueMesaReleaseForBlackCanyonTarget"( "Max"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], $ "TunnelReturnFlow.Inflow" [@"t - 1"] ), @"t" )
                                 ENDIF
                              ENDIF
                           ENDIF
                        ENDIF
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDIF
   ENDWITH;

    END;

    FUNCTION       "BlueMesaReleaseMINConstraintByMonthOLD_OLD" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "This function takes a date.  It returns the minimum constraint (floor) for the Blue Mesa release on the passed-in date.  The min constraint will not necessarily be the release, just provide an upper bound for that month's release. - sc 12/28/10";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WITH NUMERIC nextFourMonthsInflowVolume = "SumFlowsToVolume"( $ "BlueMesa.Inflow", @"t", "DateMin"( @"t + 4", @"Finish Timestep" ) ) DO
      IF ( "GetMonthAsString"( date ) IN { "August" , "September" , "October" , "November" } )
      THEN
         "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinCanyonFlow" [], @"t" )
      ELSE
         IF ( "GetMonthAsString"( date ) IN { "December" , "January" , "February" } )
         THEN
            "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "TunnelReturnFlow.Inflow" [@"t - 1"], @"t" )
         ELSE
            IF ( "GetMonthAsString"( date ) IN { "June" , "July" } )
            THEN
               "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.ShoulderFlowTarget" [@"24:00:00 December 31, Current Year"], @"t" )
            ELSE
               IF ( "GetMonthAsString"( date ) IN { "March" , "April" } )
               THEN
                  WITH NUMERIC ExcessInflow = "Max"( "PrevStorage"( % "BlueMesa" ) + nextFourMonthsInflowVolume - "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 June 30, Current Year", "Target Elevation"] ), 0.00000000 "acre-feet" ) DO
                     "Max"( "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinCanyonFlow" [], @"t" ), ExcessInflow / 6.00000000 "month" )
                  ENDWITH
               ELSE
                  9999999.00000000 "cfs"
               ENDIF
            ENDIF
         ENDIF
      ENDIF
   ENDWITH;

    END;

    FUNCTION       "BlueMesaReleaseMINConstraintByMonthOLD" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "This function takes a date.  It returns the minimum constraint (floor) for the Blue Mesa release on the passed-in date.  The min constraint will not necessarily be the release, just provide an upper bound for that month's release. - sc 12/28/10";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WITH NUMERIC nextFourMonthsInflowVolume = "SumFlowsToVolume"( $ "BlueMesa.Inflow", @"t", "DateMin"( @"t + 4", @"Finish Timestep" ) ) DO
      IF ( "GetMonthAsString"( date ) IN { "August" , "September" , "October" , "November" } )
      THEN
         "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinimumBlackCanyonFlow" [], @"t" )
      ELSE
         IF ( "GetMonthAsString"( date ) IN { "December" , "January" , "February" } )
         THEN
            "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "TunnelReturnFlow.Inflow" [@"t - 1"], @"t" )
         ELSE
            IF ( "GetMonthAsString"( date ) IN { "June" , "July" } )
            THEN
               "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.ShoulderFlowTarget" [@"24:00:00 December 31, Current Year"], @"t" )
            ELSE
               IF ( "GetMonthAsString"( date ) IN { "March" , "April" } )
               THEN
                  WITH NUMERIC ExcessInflow = "Max"( "PrevStorage"( % "BlueMesa" ) + nextFourMonthsInflowVolume - "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 June 30, Current Year", "Target Elevation"] ), 0.00000000 "acre-feet" ) DO
                     "Max"( "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinimumBlackCanyonFlow" [], @"t" ), ExcessInflow / 6.00000000 "month" )
                  ENDWITH
               ELSE
                  9999999.00000000 "cfs"
               ENDIF
            ENDIF
         ENDIF
      ENDIF
   ENDWITH;

    END;

    FUNCTION       "CalcGunnisonPeakFlowTarget" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "This function returns the one-day peak flow target for the Black Canyon portion of the Gunnison River.  The calculation is taken from Paul Davidson's &quot;Black Canyon Logic&quot; spreadsheet which references the releavant section of the Decree.  The peak flow is a function of the official April-July forecast for unregulated inflow to Blue Mesa Reservoir.  There are six regions, each having its own linear calculation for the peak flow.  First the function determines which region, or level, the forecast fits into, and then calculates using the linear equation associated with that region, the appropriate peak flow target for May of the current year. - sc 12/22/10";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH NUMERIC currentForecast = "SumFlowsToVolume"( $ "BlueMesaInflow.Unregulated", @"24:00:00 April 30, Current Year", @"24:00:00 July 31, Current Year" ) DO
      WITH STRING forecastLevel = FOR ( STRING level IN { "Level 1" , "Level 2" , "Level 3" , "Level 4" , "Level 5" , "Level 6" } ) WITH STRING result = "Level 1" DO
         IF ( currentForecast > $ "BlueMesaData.PeakFlowCalcData" [level, "Lower Limit"] )
         THEN
            level
         ELSE
            result
         ENDIF
      ENDFOR DO
         $ "BlueMesaData.PeakFlowCalcData" [forecastLevel, "Parameter A"] * ( currentForecast / 1000.00000000 "acre-feet" ) + $ "BlueMesaData.PeakFlowCalcData" [forecastLevel, "Parameter B"]
      ENDWITH
   ENDWITH;

    END;

    FUNCTION       "CalcGunnisonPeakFlowLevel" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "This function returns the one-day peak flow target for the Black Canyon portion of the Gunnison River.  The calculation is taken from Paul Davidson's &quot;Black Canyon Logic&quot; spreadsheet which references the releavant section of the Decree.  The peak flow is a function of the official April-July forecast for unregulated inflow to Blue Mesa Reservoir.  There are six regions, each having its own linear calculation for the peak flow.  First the function determines which region, or level, the forecast fits into, and then calculates using the linear equation associated with that region, the appropriate peak flow target for May of the current year. - sc 12/22/10";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH NUMERIC currentForecast = "SumFlowsToVolume"( $ "BlueMesaInflow.Unregulated", @"24:00:00 April 30, Current Year", @"24:00:00 July 31, Current Year" ) - "SumFlowsToVolume"( $ "TaylorPark.Inflow", @"24:00:00 April 30, Current Year", @"24:00:00 July 31, Current Year" ) DO
      WITH STRING forecastLevel = FOR ( STRING level IN { "Level 1" , "Level 2" , "Level 3" , "Level 4" , "Level 5" , "Level 6" } ) WITH STRING result = "Level 1" DO
         IF ( currentForecast > $ "BlueMesaData.PeakFlowCalcData" [level, "Lower Limit"] )
         THEN
            level
         ELSE
            result
         ENDIF
      ENDFOR DO
         IF ( forecastLevel == "Level 1" )
         THEN
            0.00000000
         ELSE
            IF ( forecastLevel == "Level 2" )
            THEN
               1.00000000
            ELSE
               IF ( forecastLevel == "Level 3" )
               THEN
                  2.00000000
               ELSE
                  IF ( forecastLevel == "Level 4" )
                  THEN
                     3.00000000
                  ELSE
                     IF ( forecastLevel == "Level 5" )
                     THEN
                        4.00000000
                     ELSE
                        5.00000000
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDWITH
   ENDWITH;

    END;

    FUNCTION       "CalcGunnisonShoulderFlowTarget" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "This function returns the shoulder flow target for the Black Canyon portion of the Gunnison River.  The calculation is taken from Paul Davidson's &quot;Black Canyon Logic&quot; spreadsheet which references the releavant section of the Decree.  The shoulder flow is a function of the official April-July forecast for unregulated inflow to Blue Mesa Reservoir.  There are four regions, each having its own linear calculation for the peak flow.  First the function determines which region, or level, the forecast fits into, and then calculates using the linear equation associated with that region, the appropriate shoulder flow target for the current year. - sc 12/22/10";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH NUMERIC currentForecast = "SumFlowsToVolume"( $ "BlueMesaInflow.Unregulated", @"24:00:00 April 30, Current Year", @"24:00:00 July 31, Current Year" ) DO
      WITH STRING forecastLevel = FOR ( STRING level IN { "Level 1" , "Level 2" , "Level 3" , "Level 4" } ) WITH STRING result = "Level 1" DO
         IF ( currentForecast > $ "BlueMesaData.ShoulderFlowCalcData" [level, "Lower Limit"] )
         THEN
            level
         ELSE
            result
         ENDIF
      ENDFOR DO
         $ "BlueMesaData.ShoulderFlowCalcData" [forecastLevel, "Parameter A"] * ( currentForecast / 1000.00000000 "acre-feet" ) + $ "BlueMesaData.ShoulderFlowCalcData" [forecastLevel, "Parameter B"]
      ENDWITH
   ENDWITH;

    END;

    FUNCTION       "RampUpDateAndFlowLists_OLD" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "This function returns a list of two-item lists, each sublist of the form &lcub;date, flow target&rcub;.  The function does this by starting at the peak flow date and the peak flow value and then going backward one day at a time and calculating the new flow target until it gets down to the shoulder flow which is already set on the slot by the previous rule (April Through July Daily Canyon Flows).  The liimitations in the ramp up daily rate are no more than 500cfs and no more than 25% of the previous day's flow. - sc 12/22/10";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WHILE ( ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) > $ "BlueMesaData.MayThruJulyDaily" [GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList] OR ( LENGTH dateFlowList ) == 1.00000000 ) WITH LIST dateFlowList = { { "PartialToFull"( "NumberToDate"( $ "BlueMesaData.MayPeakFlowDate" [@"24:00:00 December 31, Current Year"] ) ) , $ "BlueMesaData.MayPeakFlowTarget" [@"24:00:00 December 31, Current Year"] } } DO
      WITH DATETIME previousDaysDate = ( GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) - 1.00000000 "day" DO
         WITH NUMERIC previousDaysFlow = "MaxItem"( { ( ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) * ( 1.00000000 / ( 1.00000000 + 0.25000000 COMMENTED_BY "If Paul says that the ramp up rate needs to be user-controlled, <br>put the slot reference here. - sc 12/22/10" ) ) ) , $ "BlueMesaData.MayThruJulyDaily" [previousDaysDate] , ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) - 500.00000000 "cfs" } ) DO
            APPEND { previousDaysDate , previousDaysFlow } ONTO dateFlowList
         ENDWITH
      ENDWITH
   ENDWHILE;

    END;

    FUNCTION       "RampUpDateAndFlowLists" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "This function returns a list of two-item lists, each sublist of the form &lcub;date, flow target&rcub;.  The function does this by starting at the peak flow date and the peak flow value and then going backward one day at a time and calculating the new flow target until it gets down to the shoulder flow which is already set on the slot by the previous rule (April Through July Daily Canyon Flows).  The liimitations in the ramp up daily rate are no more than 500cfs and no more than 25% of the previous day's flow. - sc 12/22/10";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH NUMERIC peakLevel = $ "BlueMesaData.MayPeakFlowLevel" [@"24:00:00 December 31, Current Year"] DO
      WITH DATETIME peakDate = "PartialToFull"( "NumberToDate"( $ "BlueMesaData.MayPeakFlowDate" [@"24:00:00 December 31, Current Year"] ) ) DO
         WITH NUMERIC peakFlowTarget = "Max"( $ "BlueMesaData.MayPeakFlowTarget" [@"24:00:00 December 31, Current Year"], $ "BlueMesaData.MayThruJulyDaily" [peakDate] ) DO
            WITH NUMERIC daysAtPeak = $ "BlueMesaData.SpringPeakAndDurationCanyonTargets" [peakLevel, "Duration of Half Bank Days"] DO
               WITH DATETIME dateToCheckRamp = peakDate - "Floor"( daysAtPeak / 2.00000000, 1.00000000 "day" ) DO
                  WHILE ( ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) > $ "BlueMesaData.MayThruJulyDaily" [GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList] OR ( LENGTH dateFlowList ) == 1.00000000 ) WITH LIST dateFlowList = { { dateToCheckRamp , peakFlowTarget } } DO
                     WITH DATETIME previousDaysDate = ( GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) - 1.00000000 "day" DO
                        WITH NUMERIC previousDaysFlow = "Max"( "Min"( ( ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) * ( 1.00000000 / ( 1.00000000 + 0.25000000 COMMENTED_BY "If Paul says that the ramp up rate needs to be user-controlled, <br>put the slot reference here. - sc 12/22/10" ) ) ), ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) - 500.00000000 "cfs" ), $ "BlueMesaData.MayThruJulyDaily" [previousDaysDate] ) DO
                           APPEND { previousDaysDate , previousDaysFlow } ONTO dateFlowList
                        ENDWITH
                     ENDWITH
                  ENDWHILE
               ENDWITH
            ENDWITH
         ENDWITH
      ENDWITH
   ENDWITH;

    END;

    FUNCTION       "RampDownDateAndFlowLists_OLD" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "This function returns a list of two-item lists, each sublist of the form &lcub;date, flow target&rcub;.  The function does this by starting at the peak flow date and the peak flow value and then going forward one day at a time and calculating the new flow target until it gets down to the shoulder flow which is already set on the slot by the previous rule (April Through July Daily Canyon Flows).  The liimitations in the ramp down daily rate are no more than 400cfs and no more than15% of the previous day's flow. - sc 12/22/10";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WHILE ( ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) > $ "BlueMesaData.MayThruJulyDaily" [GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList] OR ( LENGTH dateFlowList ) == 1.00000000 ) WITH LIST dateFlowList = { { "PartialToFull"( "NumberToDate"( $ "BlueMesaData.MayPeakFlowDate" [@"24:00:00 December 31, Current Year"] ) ) , $ "BlueMesaData.MayPeakFlowTarget" [@"24:00:00 December 31, Current Year"] } } DO
      WITH DATETIME nextDaysDate = ( GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) + 1.00000000 "day" DO
         WITH NUMERIC nextDaysFlow = "MaxItem"( { ( ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) * ( 1.00000000 / ( 1.00000000 + 0.15000000 COMMENTED_BY "If Paul says that the ramp down rate needs to be user- controlled, <br>put the slot reference here. - sc 12/22/10" ) ) ) , $ "BlueMesaData.MayThruJulyDaily" [nextDaysDate] , ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) - 400.00000000 "cfs" } ) DO
            APPEND { nextDaysDate , nextDaysFlow } ONTO dateFlowList
         ENDWITH
      ENDWITH
   ENDWHILE;

    END;

    FUNCTION       "RampDownDateAndFlowLists" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "This function returns a list of two-item lists, each sublist of the form &lcub;date, flow target&rcub;.  The function does this by starting at the peak flow date and the peak flow value and then going forward one day at a time and calculating the new flow target until it gets down to the shoulder flow which is already set on the slot by the previous rule (April Through July Daily Canyon Flows).  The liimitations in the ramp down daily rate are no more than 400cfs and no more than15% of the previous day's flow. - sc 12/22/10";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH NUMERIC peakLevel = $ "BlueMesaData.MayPeakFlowLevel" [@"24:00:00 December 31, Current Year"] DO
      WITH DATETIME peakDate = "PartialToFull"( "NumberToDate"( $ "BlueMesaData.MayPeakFlowDate" [@"24:00:00 December 31, Current Year"] ) ) DO
         WITH NUMERIC peakFlowTarget = "Max"( $ "BlueMesaData.MayPeakFlowTarget" [@"24:00:00 December 31, Current Year"], $ "BlueMesaData.MayThruJulyDaily" [peakDate] ) DO
            WITH NUMERIC daysAtPeak = $ "BlueMesaData.SpringPeakAndDurationCanyonTargets" [peakLevel, "Duration At Peak Flow"] DO
               WITH DATETIME dateToCheckRamp = peakDate + ( "Floor"( daysAtPeak / 2.00000000, 1.00000000 "day" ) - IF ( daysAtPeak == 0.00000000 "day" )
               THEN
                  0.00000000 "day"
               ELSE
                  1.00000000 "day"
               ENDIF ) DO
                  WHILE ( ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) > $ "BlueMesaData.MayThruJulyDaily" [GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList] OR ( LENGTH dateFlowList ) == 1.00000000 ) WITH LIST dateFlowList = { { dateToCheckRamp , peakFlowTarget } } DO
                     WITH DATETIME nextDaysDate = ( GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) + 1.00000000 "day" DO
                        WITH NUMERIC nextDaysFlow = "Max"( "Min"( ( ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) * ( 1.00000000 - 0.15000000 COMMENTED_BY "If Paul says that the ramp down rate needs to be user- controlled, <br>put the slot reference here. - sc 12/22/10" ) ), ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) - 400.00000000 "cfs" ), $ "BlueMesaData.MayThruJulyDaily" [nextDaysDate] ) DO
                           APPEND { nextDaysDate , nextDaysFlow } ONTO dateFlowList
                        ENDWITH
                     ENDWITH
                  ENDWHILE
               ENDWITH
            ENDWITH
         ENDWITH
      ENDWITH
   ENDWITH;

    END;

    FUNCTION       "SolveBlueMesaReleaseForBlackCanyonTarget" ( NUMERIC TargetCanyonFlow, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "This function takes a numeric flow target and a date.  It returns the value of the release from Blue Mesa Reservoir that is necessary to hit the passed-in flow target in the Black Canyon section of the Gunnison River which is the &quot;Tunnel Return Flow&quot; object on the workspace.  The function does this by doing a water balance in the reach of the river between Blue Mesa and the Black Canyon and solving for the release from Blue Mesa. - sc 12/28/10";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      "Max"( TargetCanyonFlow + $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" [date] - $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [date] - $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [date], $ "BlueMesaData.BlueMesaMinRelease" [] );

    END;

    FUNCTION       "SolveBlueMesaReleaseForWhitewaterTarget" ( NUMERIC TargetCanyonFlow, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "This function takes a numeric flow target and a date.  It returns the value of the release from Blue Mesa Reservoir that is necessary to hit the passed-in flow target in the Black Canyon section of the Gunnison River which is the &quot;Tunnel Return Flow&quot; object on the workspace.  The function does this by doing a water balance in the reach of the river between Blue Mesa and the Black Canyon and solving for the release from Blue Mesa. - sc 12/28/10";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      "Max"( TargetCanyonFlow + $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" [date] - $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [date] - $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [date] - $ "NorthForkRiverInflow.NorthFork_at_Somerset" [date], $ "BlueMesaData.MinimumBlackCanyonFlow" [date] );

    END;

    FUNCTION       "SolveBlwBlueMesaInterveningFlows" ( LIST dates )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "This function takes a list of dates and sums the intervening flows from Below Blue Mesa.  Usually May has already been solved for so we do not include it in this calculation. <br>TP 2/13/2014<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      FOR ( DATETIME date IN dates ) STAT_SUM
      "FlowToVolume"( $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [date], date ) + "FlowToVolume"( $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [date], date )
   ENDFOR;

    END;

    FUNCTION       "SolveBlueMesaReleaseForCrystalReleaseTarget" ( NUMERIC TargetCrystalRelease, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "This function takes a numeric telease target and a date.  It returns the value of the release from Blue Mesa Reservoir that is necessary to hit the passed-in release target for Crystal Reservoir  The function does this by doing a water balance in the reach of the river between Blue Mesa and Crystal Res and solving for the release from Crystal Res. - sc 12/28/10";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      "Max"( TargetCrystalRelease - $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [date] - $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [date], $ "BlueMesaData.BlueMesaMinRelease" [] );

    END;

    FUNCTION       "TaylorParkMinReleaseConstraint" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "This function takes a datetime and returns the minimum release permitted on that date from Taylor Park Reservoir.  Currently it is just the &quot;MinFlow&quot; slot on the &quot;TaylorParkData&quot; object.  It is expected that this function will get more detailed as the development of the model continues and may have unique calculations for each month of the year. - sc 12/16/10";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      $ "TaylorParkData.TaylorParkMinFlow" [date];

    END;

    FUNCTION       "TaylorParkMaxReleaseConstraint" ( DATETIME date, NUMERIC prevElev )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "This function takes a datetime and a previous elevation value and returns the maximum allowable release from Taylor Park Reservoir on that date.  Currently it is calculated as the appropriate value on the &quot;Max Release&quot; table of the reservoir.  It is expected that this function will get more detailed as the model is developed and will likely have unique calculations for each month of the year.  - sc 12/17/10";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      "TableInterpolation"( $ "TaylorPark.Max Release", 0.00000000, 1.00000000, prevElev, @"t" );

    END;

  END;

  UTILITY_GROUP "Vallecito Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  BEGIN

    FUNCTION       "VallecitoMinReleaseConstraint" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "This function takes a datetime and returns the minimum release permitted on that date from Vallecito Reservoir.  Currently it is just the &quot;MinFlow&quot; slot on the VallecitoData object.  It is expected that this function will get more detail as the development of the model continues and may have unique calculations for each month of the year. - sc 12/16/10";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      $ "VallecitoData.MinFlow" [];

    END;

    FUNCTION       "VallecitoMaxReleaseConstraint" ( DATETIME date, NUMERIC prevElev )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "This function takes a datetime and a previous elevation value and returns the maximum allowable release from Vallecito Reservoir on that date.  Currently it is calculated as the appropriate value on the &quot;Max Release&quot; table of the reservoir.  It is expected that this function will get more detailed as the model is developed and will likely have unique calculations for each month of the year.  - sc 12/17/10";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      "TableInterpolation"( $ "Vallecito.Max Release", 0.00000000, 1.00000000, prevElev, @"t" );

    END;

    FUNCTION       "VallecitoMaxBankReleaseConstraint" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "This is the max bank flow for the Pinos River below Vallacito. The value is 2000 cfs and is the recommended max flow from Vallacito by the USBR operations guidelines to prevent damage downstream of Vallacito in Normal Operations.  - TP 10/8/2012";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      $ "VallecitoData.NoDamageMaxBankFlow" [];

    END;

  END;

  UTILITY_GROUP "Flood Control Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  BEGIN

    FUNCTION       "AvailableSpace" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      "GetLiveCapacity"( reservoir ) - reservoir & "Storage" [@"t - 1"];

    END;

    FUNCTION       "ComputeMinimumSpace" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      "GetLiveCapacity"( reservoir ) - "GetMininumSpace"( reservoir );

    END;

    FUNCTION       "ComputeTargetStorageRelease" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet/month";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      IF ( "ComputeOutflowAtGivenStorageForSpaceBuilding"( % "Mead", "SpaceBuilding"(  ) ) > $ "MeadFloodControlData.MaxRelease" [0.00000000, 0.00000000] )
   THEN
      $ "MeadFloodControlData.MaxRelease" [0.00000000, 0.00000000]
   ELSE
      "Max"( "ComputeOutflowAtGivenStorageForSpaceBuilding"( % "Mead", "SpaceBuilding"(  ) ), 0.00000000 "acre-feet/month" )
   ENDIF;

    END;

    FUNCTION       "ComputeTargetStorage" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      IF ( "ComputeOutflowAtGivenStorage"( % "Mead", "SpaceBuilding"(  ) ) > $ "MeadFloodControlData.MaxRelease" [0.00000000, 0.00000000] )
   THEN
      "ComputeStorageWithGivenOutflow"( % "Mead", $ "MeadFloodControlData.MaxRelease" [0.00000000, 0.00000000] )
   ELSE
      "SpaceBuilding"(  )
   ENDIF;

    END;

    FUNCTION       "CurrentAvailableSpace" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      "GetLiveCapacity"( reservoir ) - reservoir & "Storage" [];

    END;

    FUNCTION       "FloodControlEvap" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      "StorageToArea"( reservoir, "GetLiveCapacity"( reservoir ) - "AvailableSpace"( reservoir ) / 2.00000000 ) * "SumEvapCoeff"( reservoir );

    END;

    FUNCTION       "DeltaBankStorage" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] * ( "AvailableSpace"( % "Mead" ) - $ "MeadFloodControlData.MinSpace" [0.00000000, 0.00000000] ) + $ "Powell.Bank Storage Coefficient" [0.00000000, 0.00000000] * "AvailableSpace"( % "Powell" );

    END;

    FUNCTION       "ForecastMeadInflow" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This function computes the inflow forcast for Mead in for the flood control release.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      "SumSlotVolume"( $ "Mead.Inflow", "GetMonthlyDatelist"( @"t", @"24:00:00 July Max DayOfMonth, Current Year" ) );

    END;

    FUNCTION       "ForecastMeadInflowOld" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This function computes the inflow forcast for Mead in for the flood control release.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      "SumSlotVolume"( $ "PowellInflow.Unregulated", "GetMonthlyDatelist"( @"t", @"24:00:00 July Max DayOfMonth, Current Year" ) ) + "SumGainsBelowVolume"( % "Powell", @"t", @"24:00:00 July Max DayOfMonth, Current Year" ) + $ "MeadFloodControlData.Forcmax" ["Forcmax", "GetMonthAsString"( @"t" )] - $ "FloodControlOutput.UBEffective" [];

    END;

    FUNCTION       "SouthernNevConsumed" ( LIST dates )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      "SumSlotVolume"( $ "PumpingFromLakeMead:SNWP.Diversion Requested", dates );

    END;

    FUNCTION       "ForecastRunoffSeason " (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WHILE ( "VolumeToFlow"( "ComputeMinMeadFloodRelease"( ( GET @INDEX 1.00000000 FROM results ) ), @"t" ) > $ "MeadFloodControlData.Levels" [0.00000000, ( GET @INDEX 1.00000000 FROM results )] AND ( GET @INDEX 1.00000000 FROM results ) <= 5.00000000 ) WITH LIST results = { "Max"( "VolumeToFlow"( "ComputeMinMeadFloodRelease"( 0.00000000 ), @"t" ), 0.00000000 "acre-feet/month" ) , 0.00000000 } DO
      IF ( "VolumeToFlow"( "ComputeMinMeadFloodRelease"( ( GET @INDEX 1.00000000 FROM results ) + 1.00000000 ), @"t" ) <= $ "MeadFloodControlData.Levels" [0.00000000, ( GET @INDEX 1.00000000 FROM results )] )
      THEN
         INSERT $ "MeadFloodControlData.Levels" [0.00000000, ( GET @INDEX 1.00000000 FROM results )] INTO INSERT ( GET @INDEX 1.00000000 FROM results ) + 1.00000000 INTO results
      ELSE
         INSERT "Max"( "VolumeToFlow"( "ComputeMinMeadFloodRelease"( ( GET @INDEX 1.00000000 FROM results ) + 1.00000000 ), @"t" ), 0.00000000 "acre-feet/month" ) INTO INSERT ( GET @INDEX 1.00000000 FROM results ) + 1.00000000 INTO results
      ENDIF
   ENDWHILE;

    END;

    FUNCTION       "ComputeMinMeadFloodRelease" ( NUMERIC index )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      $ "FloodControlOutput.Withoutrel" [] - "FloodControlLevelVolume"( "GetMonthlyDatelist"( @"t + 1", @"24:00:00 July Max DayOfMonth, Current Year" ), index );

    END;

    FUNCTION       "FloodControlLevelVolume" ( LIST dateList, NUMERIC index )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      FOR ( DATETIME date IN dateList ) WITH NUMERIC result = 0.00000000 "acre-feet" DO
      result + "FlowToVolume"( $ "MeadFloodControlData.Levels" [0.00000000, index], date )
   ENDFOR;

    END;

    FUNCTION       "ComputeDeltaTargetStorage" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      "GetTargetStorage"( reservoir, @"t" ) - reservoir & "Storage" [@"t - 1"];

    END;

    FUNCTION       "UBCreditableSpace" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This function sums the flood control creditable space for  Powell, Flaming Gorge, Navajo, and Blue Mesa   These are the upper basin reservoir<br>with flood control functions.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      FOR ( OBJECT reservoir IN "ListSubbasin"( "UBFloodControlReservoirs" ) ) WITH NUMERIC sum = 0.00000000 "acre-feet" DO
      IF ( ( STRINGIFY reservoir ) == "FlamingGorge" )
      THEN
         sum + "Min"( "CurrentAvailableSpace"( % "FlamingGorge" ) + "CurrentAvailableSpace"( % "Fontenelle" ), "GetMaxCreditableSpace"( % "FlamingGorge" ) )
      ELSE
         sum + "Min"( "CurrentAvailableSpace"( reservoir ), "GetMaxCreditableSpace"( reservoir ) )
      ENDIF
   ENDFOR;

    END;

    FUNCTION       "SpaceBuilding" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      IF ( "CurrentAvailableSpace"( % "Mead" ) + "UBCreditableSpace"(  ) > "SystemSpace"(  ) )
   THEN
      "ComputeMinimumSpace"( % "Mead" )
   ELSE
      "GetLiveCapacity"( % "Mead" ) - "SystemSpace"(  ) + "UBCreditableSpace"(  )
   ENDIF;

    END;

    FUNCTION       "SumEvapCoeff" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This function sums up all the evaporation coefficients for the specified reservoir until <br>July.<br>During the sum, the coefficient values are adjusted to deal with the unit conversion issue<br>between the current month and the months for which the values were entered, and converted<br>into 31 day months. ";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      FOR ( DATETIME date IN "GetMonthlyDatelist"( @"t", @"24:00:00 July Max DayOfMonth, Current Year" ) ) WITH NUMERIC result = 0.00000000 "ft" DO
      result + reservoir & "Evaporation Coefficients" ["GetMonth"( date ) - 1.00000000, 0.00000000] * 1.00000000 "month"
   ENDFOR;

    END;

  END;

  UTILITY_GROUP "24 Month General Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  BEGIN

    FUNCTION       "AcreFeetPrint" ( NUMERIC value )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      value;

    END;

    FUNCTION       "SlotToString" ( OBJECT obj )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "This function starts out with a data object. It gets a list of slots in the object by using the GetSeriesSlots predefined function. It then uses the MAPLIST palette button to convert the list of slots into a list of strings.<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      MAPLIST ( SLOT slotname IN "GetSeriesSlots"( obj ) ) DO
      "GetSlotName"( slotname )
   ENDMAPLIST;

    END;

    FUNCTION       "AcreFeetPerMonthPrint" ( NUMERIC value )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet/month]";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      value;

    END;

    FUNCTION       "CFSPrint" ( NUMERIC value )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      value;

    END;

    FUNCTION       "CheckResPhysicalConstraint" ( OBJECT res, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      WITH DATETIME dateBefore = "OffsetDate"( date, - 1.00000000, "1 months" ) DO
      "VolumeToFlow"( res & "Storage" [dateBefore], date ) + res & "Inflow" [date] - 50000.00000000 "acre-ft/month"
   ENDWITH;

    END;

    FUNCTION       "GetMonthlyDatelist" ( DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "makes a monthly datelist from the current month to the given month.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      IF ( startDate >= endDate )
   THEN
      { endDate }
   ELSE
      WHILE ( ( GET @INDEX 0.00000000 FROM dateList ) > startDate ) WITH LIST dateList = { endDate } DO
         INSERT ( GET @INDEX 0.00000000 FROM dateList ) - "GetDaysInMonth"( ( GET @INDEX 0.00000000 FROM dateList ) - 1.00000000 "day" ) INTO dateList
      ENDWHILE
   ENDIF;

    END;

    FUNCTION       "SumGainsBelow" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet/month";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      "SumObjectsAggregatedOverTime"( "Below" CONCAT STRINGIFY reservoir, "Local Inflow", "SUM", "INPUT", FALSE, @"t", @"t" );

    END;

    FUNCTION       "SumGainsBelowVolume" ( OBJECT reservoir, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      "SumObjectsAggregatedOverTime"( "Below" CONCAT STRINGIFY reservoir, "Local Inflow", "SUM", "ALL", TRUE, startDate, endDate );

    END;

    FUNCTION       "SumAllGainsBelowVolume" ( OBJECT reservoir, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      "SumObjectsAggregatedOverTime"( "Below" CONCAT STRINGIFY reservoir, "Local Inflow", "SUM", "ALL", TRUE, startDate, endDate );

    END;

    FUNCTION       "SumDiversionsBelow" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet/month";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      "SumObjectsAggregatedOverTime"( "Below" CONCAT STRINGIFY reservoir, "Total Diversion Requested", "SUM", "INPUT", FALSE, @"t", @"t" );

    END;

    FUNCTION       "SumDiversionsBelowVolume" ( OBJECT reservoir, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      "SumObjectsAggregatedOverTime"( "Below" CONCAT STRINGIFY reservoir, "Total Diversion Requested", "SUM", "INPUT", TRUE, startDate, endDate );

    END;

    FUNCTION       "SumAllDiversionsBelowVolume" ( OBJECT reservoir, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      "SumObjectsAggregatedOverTime"( "Below" CONCAT STRINGIFY reservoir, "Total Diversion Requested", "SUM", "ALL", TRUE, startDate, endDate );

    END;

    FUNCTION       "SumSlotVolume" ( SLOT slot, LIST dates )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      FOR ( DATETIME date IN dates ) WITH NUMERIC sum = 0.00000000 "acre-feet" DO
      sum + "FlowToVolume"( slot [date], date )
   ENDFOR;

    END;

    FUNCTION       "Compute Head as a Function of Turbine Release" ( NUMERIC turbineRelease )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      ( $ "Mohave.Pool Elevation" [] + $ "Mohave.Pool Elevation" [@"t - 1"] ) / 2.00000000 - "TableInterpolation"( $ "Mohave.Tailwater Table", 0.00000000, 1.00000000, turbineRelease, @"t" );

    END;

    FUNCTION       "Annual Volume" ( SLOT slot )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Find the sum of a given slot over the calendar year<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      "SumFlowsToVolume"( slot, @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year" );

    END;

    FUNCTION       "AnnualVolumeSlot" ( SLOT slot )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Find the sum of a given slot over the calendar year<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      "SumSlot"( slot, @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year" );

    END;

    FUNCTION       "SumSlotList" ( OBJECT obj )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This functions starts out with a data object. It gets a list of slots in the object by using the GetSeriesSlots predefined function. It then sums the values of all the slots in the object over the current timestep.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      FOR ( SLOT slotname IN "GetSeriesSlots"( obj ) ) WITH NUMERIC result = 0.00000000 "acre-ft" DO
      result + slotname []
   ENDFOR;

    END;

    FUNCTION       "SumSlotListDates" ( OBJECT obj, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This functions starts out with a data object. It gets a list of slots in the object by using the GetSeriesSlots predefined function. It then sums the values of all the slots in the object over the current timestep.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      FOR ( SLOT slotname IN "GetSeriesSlots"( obj ) ) WITH NUMERIC result = 0.00000000 "acre-ft" DO
      result + slotname [date]
   ENDFOR;

    END;

    FUNCTION       "GetLastDate" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      IF ( "GetMonth"( date ) > 1.00000000 )
   THEN
      "Dec31ofYear"( @"Finish Timestep" )
   ELSE
      "Dec31ofYear"( @"Finish Timestep" )
   ENDIF;

    END;

    FUNCTION       "GetFirstDate" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "This function is used in rules that set monthly values in outyears. If the start timestep is December, we want the rule to skip the 1st 2 timesteps and set values Feb - Dec (11 total), otherwise set values Jan-Dec (12 total). ";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      IF ( date == @"Start Timestep + 1" )
   THEN
      @"24:00:00 February Max DayOfMonth, Current Year"
   ELSE
      @"24:00:00 January Max DayOfMonth, Current Year"
   ENDIF;

    END;

    FUNCTION       "GetDaysBasedOnFirstDate" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This function is used in rules that set monthly values in outyears. If the start timestep is December, we want the rule to skip the 1st 2 timesteps and set values Feb - Dec (11 total), otherwise set values Jan-Dec (12 total). ";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      IF ( date == @"Start Timestep + 1" )
   THEN
      11.00000000
   ELSE
      12.00000000
   ENDIF;

    END;

    FUNCTION       "PartialToFull" ( DATETIME MonthDay )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WHILE ( result < MonthDay ) WITH DATETIME result = @"24:00:00 January 1, Current Year" DO
      result + 1.00000000 "day"
   ENDWHILE;

    END;

  END;

  UTILITY_GROUP "Rule Curve Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  BEGIN

    FUNCTION       "ComputeOutflowAtGivenStorage" ( OBJECT reservoir, NUMERIC storage )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    MIN_CONSTRAINT "GetMinRelease"( reservoir );
    MAX_CONSTRAINT "GetMaxRelease"( reservoir );
    BEGIN

      "SolveOutflow"( reservoir, reservoir & "Inflow" [@"t"], storage, reservoir & "Storage" [@"t - 1"], @"t" );

    END;

    FUNCTION       "ComputeOutflowAtGivenStorageForSpaceBuilding" ( OBJECT reservoir, NUMERIC storage )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet/month";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      "SolveOutflow"( reservoir, reservoir & "Inflow" [], storage, reservoir & "Storage" [@"t - 1"], @"t" );

    END;

    FUNCTION       "ComputeStorageWithGivenOutflow" ( OBJECT reservoir, NUMERIC outflow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    MIN_CONSTRAINT "GetInactiveCapacity"( reservoir );
    MAX_CONSTRAINT "GetLiveCapacity"( reservoir );
    BEGIN

      "SolveStorage"( reservoir, reservoir & "Inflow" [], outflow, reservoir & "Storage" [@"t - 1"], @"t" );

    END;

  END;

  UTILITY_GROUP "Get Data Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  BEGIN

    FUNCTION       "GetMaxRelease" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      $ "UBRuleCurveData.ReservoirData" [STRINGIFY reservoir, "maxRelease"];

    END;

    FUNCTION       "GetMinRelease" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      $ "UBRuleCurveData.ReservoirData" [STRINGIFY reservoir, "minRelease"];

    END;

    FUNCTION       "GetMininumSpace" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      $ "MeadFloodControlData.MinSpace" [STRINGIFY reservoir, "Min Space"];

    END;

    FUNCTION       "GetMaxCreditableSpace" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      $ "MeadFloodControlData.CredSpace" ["Credit. Space", STRINGIFY reservoir];

    END;

    FUNCTION       "GetInactiveCapacity" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      $ "UBRuleCurveData.ReservoirData" [STRINGIFY reservoir, "inactiveCapacityStorage"];

    END;

    FUNCTION       "GetLiveCapacity" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      $ "UBRuleCurveData.ReservoirData" [STRINGIFY reservoir, "liveCapacityStorage"];

    END;

    FUNCTION       "GetRuleCurveStorage" ( OBJECT reservoir, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      $ "UBRuleCurveData.BaseRuleCurves" [STRINGIFY reservoir, "GetMonthAsString"( date )];

    END;

    FUNCTION       "GetTargetStorage" ( OBJECT reservoir, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      "LBRuleCurveData." CONCAT ( STRINGIFY reservoir ) CONCAT " Target Storage" [date];

    END;

    FUNCTION       "SystemSpace" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      $ "MeadFloodControlData.Space" [0.00000000, "GetMonthAsString"( @"t" )];

    END;

    FUNCTION       "MaxRelease" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      reservoir & "Maximum Controlled Release" [0.00000000, 0.00000000];

    END;

    FUNCTION       "InactiveCapacity" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      $ "UBRuleCurveData.ReservoirData" [STRINGIFY reservoir, "inactiveCapacityStorage"];

    END;

    FUNCTION       "LiveCapacity" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      $ "UBRuleCurveData.ReservoirData" [STRINGIFY reservoir, "liveCapacityStorage"];

    END;

    FUNCTION       "GetEndDayOfMonth" (  )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      @"24:00:00 Current Month Max DayOfMonth, Current Year";

    END;

    FUNCTION       "GetStartDayOfMonth" (  )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      @"24:00:00 Current Month Min DayOfMonth, Current Year";

    END;

    FUNCTION       "RepeatAnnualPreviousYearSlots" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      { $ "AnnualWaterUse.Arizona_Apportionment" , $ "AnnualWaterUse.California_Apportionment" , $ "AnnualWaterUse.Nevada_Apportionment" , $ "Surplus Volume Entitlements.AzPumpersBlwImp" , $ "Surplus Volume Entitlements.CAP FC" , $ "Surplus Volume Entitlements.CaPumpersAbvImp" , $ "Surplus Volume Entitlements.CibolaValleyIID" , $ "Surplus Volume Entitlements.City of Parker" , $ "Surplus Volume Entitlements.Gila Monster Farms" , $ "Surplus Volume Entitlements.Mexico" , $ "Surplus Volume Entitlements.Needles" , $ "Surplus Volume Entitlements.SNWA Domestic" , $ "Surplus Volume Entitlements.SNWA Quantified and FC" };

    END;

    FUNCTION       "CalcMonthlyDiversionsList" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      { "SaltonSea" , "IID" , "Coachella" , "MWDDiversion" , "SNWP" , "Mexico" };

    END;

    FUNCTION       "RepeatMonthlyPreviousYearSlots" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      { $ "BelowImperialDam:GainsImpToNIB.Local Inflow" , $ "BelowImperialDam:Gila River.Local Inflow" , $ "CoRivMeadToMohave:GainsAboveDavis.Local Inflow" , $ "HavasuToImperial:GainsPkrToImp.Local Inflow" , $ "LBRuleCurveData.Havasu Target Storage" , $ "LBRuleCurveData.Mohave Target Storage" , $ "MWDAndCAPReach:GainsAboveParker.Local Inflow" , $ "PowellToMead:GainsAboveHoover.Local Inflow" , $ "PowellToMead:GainsGrandCanyon.Local Inflow" , $ "PowellToMead:PariaRiver.Local Inflow" , $ "Azotea Tunnel.Diversion Requested" , $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" , $ "BlueMesa.Power Plant Cap Fraction" , $ "Crystal.Power Plant Cap Fraction" , $ "FlamingGorge.Power Plant Cap Fraction" , $ "Fontenelle.Power Plant Cap Fraction" , $ "Havasu.Power Plant Cap Fraction" , $ "Mead.Power Plant Cap Fraction" , $ "Mohave.Power Plant Cap Fraction" , $ "MorrowPoint.Power Plant Cap Fraction" , $ "Powell.Power Plant Cap Fraction" };

    END;

    FUNCTION       "RepeatMonthlyLB_CU_PreviousYearSlots" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      { $ "Arizona_CU_Schedules.AzPumpersAbvImp" , $ "Arizona_CU_Schedules.AzPumpersBlwImp" , $ "Arizona_CU_Schedules.AzPumpersDvsToPkr" , $ "Arizona_CU_Schedules.BrookeWater" , $ "Arizona_CU_Schedules.BullheadCity" , $ "Arizona_CU_Schedules.CAP" , $ "Arizona_CU_Schedules.CibolaNWR" , $ "Arizona_CU_Schedules.CibolaValleyIID" , $ "Arizona_CU_Schedules.City of Parker" , $ "Arizona_CU_Schedules.City of Yuma" , $ "Arizona_CU_Schedules.Cocopah Indian Res" , $ "Arizona_CU_Schedules.CRIRAz" , $ "Arizona_CU_Schedules.DavisDamProject" , $ "Arizona_CU_Schedules.DesertLawnMemorial" , $ "Arizona_CU_Schedules.Ehrenberg" , $ "Arizona_CU_Schedules.Ft Yuma" , $ "Arizona_CU_Schedules.FtMohaveAz" , $ "Arizona_CU_Schedules.Gila Monster Farms" , $ "Arizona_CU_Schedules.GoldenShores" , $ "Arizona_CU_Schedules.HavasuNWR" , $ "Arizona_CU_Schedules.ImperialNWR" , $ "Arizona_CU_Schedules.LakeHavasuCity" , $ "Arizona_CU_Schedules.LMNRA Az Mead" , $ "Arizona_CU_Schedules.LMNRA Az Mohave" , $ "Arizona_CU_Schedules.MCAirStation" , $ "Arizona_CU_Schedules.MohaveValleyIID" , $ "Arizona_CU_Schedules.MohaveWaterConsDist" , $ "Arizona_CU_Schedules.NGVIDD" , $ "Arizona_CU_Schedules.SouthernPacific" , $ "Arizona_CU_Schedules.UnitB" , $ "Arizona_CU_Schedules.UofA" , $ "Arizona_CU_Schedules.WMIDD" , $ "Arizona_CU_Schedules.YAO" , $ "Arizona_CU_Schedules.YCWUA" , $ "Arizona_CU_Schedules.YID" , $ "Arizona_CU_Schedules.YMIDD" , $ "Arizona_CU_Schedules.YumaProvingGround" , $ "Arizona_CU_Schedules.YumaUnionHighScl" , $ "California_CU_Schedules.CaPumpersAbvImp" , $ "California_CU_Schedules.Chemehuevi" , $ "California_CU_Schedules.Coachella" , $ "California_CU_Schedules.CRIRCa" , $ "California_CU_Schedules.FtMohaveCa" , $ "California_CU_Schedules.IID" , $ "California_CU_Schedules.MWDDiversion" , $ "California_CU_Schedules.Needles" , $ "California_CU_Schedules.OtherLCWSP" , $ "California_CU_Schedules.PaloVerde" , $ "California_CU_Schedules.Ranch5" , $ "California_CU_Schedules.SaltonSea" , $ "California_CU_Schedules.Winterhaven" , $ "California_CU_Schedules.YumaIsland" , $ "California_CU_Schedules.YumaProject" , $ "Mexico_CU_Schedules.MexicoBypass" , $ "Mexico_CU_Schedules.MexicoExcess" , $ "Mexico_CU_Schedules.MexicoSched" , $ "Mexico_CU_Schedules.MexicoTJ" , $ "Nevada_CU_Schedules.BasicManagement" , $ "Nevada_CU_Schedules.BigBend" , $ "Nevada_CU_Schedules.BoulderCanyonProject" , $ "Nevada_CU_Schedules.City of Henderson" , $ "Nevada_CU_Schedules.FtMohaveNv" , $ "Nevada_CU_Schedules.LMNRA Mead" , $ "Nevada_CU_Schedules.LMNRA Mohave" , $ "Nevada_CU_Schedules.LVWashReturns" , $ "Nevada_CU_Schedules.NvDeptFishGame" , $ "Nevada_CU_Schedules.PacificCoastBuilding" , $ "Nevada_CU_Schedules.SCE" , $ "Nevada_CU_Schedules.SNWADiversion" };

    END;

  END;

  UTILITY_GROUP "Shortage Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  BEGIN

    FUNCTION       "GetStringTier" ( NUMERIC indextier )
    RETURN_TYPE    STRING;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      IF ( indextier == 0.00000000 )
   THEN
      "1075"
   ELSE
      IF ( indextier == 1.00000000 )
      THEN
         "1050"
      ELSE
         "1025"
      ENDIF
   ENDIF;

    END;

    FUNCTION       "Arizona Shortage Depletion" ( STRING user, NUMERIC indextier, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-ft/month";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH STRING short_elev = "GetStringTier"( indextier ) DO
      "VolumeToFlow"( % "Arizona_CU_Schedules" & user [date] - "GetObject"( ( "Arizona_Shortage" CONCAT short_elev ) CONCAT "_Schedules" ) & user ["Dec31ofYear"( date )] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "Average"], date )
   ENDWITH;

    END;

    FUNCTION       "CAP Shortage Depletion" ( NUMERIC indextier, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      "Max"( "VolumeToFlow"( $ "Arizona_CU_Schedules.CAP" [date] - "GetAnnualCAPShortage"( indextier ) * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "Equal"], date ), 0.00000000 "acre-ft/month" );

    END;

    FUNCTION       "GetAnnualCAPShortage" ( NUMERIC indextier )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "The annual CAP shortage amount is the Arizona shortage amount minus the sum of the non-CAP shortage amounts";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      WITH STRING short_elev = "GetStringTier"( indextier ) DO
      $ "Shortage.State Shortage Volumes" [indextier, "Arizona"] - "SumSlotListDates"( "GetObject"( ( "Arizona_Shortage" CONCAT short_elev ) CONCAT "_Schedules" ), @"24:00:00 December 31, Current Year" )
   ENDWITH;

    END;

  END;

  UTILITY_GROUP "Surplus Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  BEGIN

    FUNCTION       "SumLBDemands" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "Calculates the Lower Basin demands as defined in the Interim Guidelines ROD. <br>Created as part of the Quantified Surplus logic. -HMG 8/2/11";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      "Normal_LBDemands"(  ) + ( $ "Surplus.Average Annual Evaporation" [0.00000000, "Mead"] + $ "Surplus.Average Annual Evaporation" [0.00000000, "Mohave"] + $ "Surplus.Average Annual Evaporation" [0.00000000, "Havasu"] ) - ( "SumGainsBelowVolume"( % "Powell", @"24:00:00 January 31, Current Year", @"24:00:00 December 31, Current Year" ) + "SumGainsBelowVolume"( % "Mead", @"24:00:00 January 31, Current Year", @"24:00:00 December 31, Current Year" ) + "SumGainsBelowVolume"( % "Havasu", @"24:00:00 January 31, Current Year", @"24:00:00 December 31, Current Year" ) );

    END;

    FUNCTION       "Normal_LBDemands" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Calculates Lower Basin water use under Normal Conditions.<br>Created as part of the Quantified Surplus logic. -HMG 8/2/11";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      "Min"( 7500000.00000000 "acre-ft", "Annual Volume"( $ "PumpingFromLakeMead.Total Diversion Requested" ) + "Annual Volume"( $ "OthersMeadToMohave.Total Diversion Requested" ) + "Annual Volume"( $ "NvDvsToPkr.Total Diversion Requested" ) + "Annual Volume"( $ "CaDvsToPkr.Total Diversion Requested" ) + "Annual Volume"( $ "AzDvsToPkr.Total Diversion Requested" ) + "Annual Volume"( $ "FtMohaveIndRes.Total Diversion Requested" ) + "Annual Volume"( $ "MWDDiversion.Total Diversion Requested" ) + "Annual Volume"( $ "CAPDiversion.Total Diversion Requested" ) + "Annual Volume"( $ "PaloVerde.Total Diversion Requested" ) + "Annual Volume"( $ "CRIR.Total Diversion Requested" ) + "Annual Volume"( $ "CaPkrToImp.Total Diversion Requested" ) + "Annual Volume"( $ "AzPkrToImp.Total Diversion Requested" ) + "Annual Volume"( $ "AAC.Total Diversion Requested" ) + "Annual Volume"( $ "GilaGravityMainCanal.Total Diversion Requested" ) + "Annual Volume"( $ "GilaAndYumaUsers.Total Diversion Requested" ) + "Annual Volume"( $ "MexicanTreatyDelivery.Total Diversion Requested" ) + "Annual Volume"( $ "OthersBlwImp.Total Diversion Requested" ) );

    END;

    FUNCTION       "SumPreviousYearICScredits" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "Calculates the Lower Basin states' total cumulative ICS credits for the previous calendar year.<br>Created as part of the Quantified Surplus logic. -HMG 8/2/11 ";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      $ "ICS Credits.TotalICS_AZ" [@"24:00:00 December 31, Previous Year"] + $ "ICS Credits.TotalICS_CA" [@"24:00:00 December 31, Previous Year"] + $ "ICS Credits.TotalICS_NV" [@"24:00:00 December 31, Previous Year"];

    END;

    FUNCTION       "Normal_LBDemands - Include Mexico" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Calculates Lower Basin water use under Normal Conditions.<br>Created as part of the Quantified Surplus logic. -HMG 8/2/11";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      "Min"( 7500000.00000000 "acre-ft" + "Annual Volume"( $ "MexicanTreatyDelivery.Total Diversion Requested" ), "Annual Volume"( $ "PumpingFromLakeMead.Total Diversion Requested" ) + "Annual Volume"( $ "OthersMeadToMohave.Total Diversion Requested" ) + "Annual Volume"( $ "NvDvsToPkr.Total Diversion Requested" ) + "Annual Volume"( $ "CaDvsToPkr.Total Diversion Requested" ) + "Annual Volume"( $ "AzDvsToPkr.Total Diversion Requested" ) + "Annual Volume"( $ "FtMohaveIndRes.Total Diversion Requested" ) + "Annual Volume"( $ "MWDDiversion.Total Diversion Requested" ) + "Annual Volume"( $ "CAPDiversion.Total Diversion Requested" ) + "Annual Volume"( $ "PaloVerde.Total Diversion Requested" ) + "Annual Volume"( $ "CRIR.Total Diversion Requested" ) + "Annual Volume"( $ "CaPkrToImp.Total Diversion Requested" ) + "Annual Volume"( $ "AzPkrToImp.Total Diversion Requested" ) + "Annual Volume"( $ "AAC.Total Diversion Requested" ) + "Annual Volume"( $ "GilaGravityMainCanal.Total Diversion Requested" ) + "Annual Volume"( $ "GilaAndYumaUsers.Total Diversion Requested" ) + "Annual Volume"( $ "MexicanTreatyDelivery.Total Diversion Requested" ) + "Annual Volume"( $ "OthersBlwImp.Total Diversion Requested" ) );

    END;

    FUNCTION       "SumLBDemands - Include Mexico" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "Calculates the Lower Basin demands as defined in the Interim Guidelines ROD. <br>Created as part of the Quantified Surplus logic. -HMG 8/2/11";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    BEGIN

      "Normal_LBDemands - Include Mexico"(  ) + ( $ "Surplus.Average Annual Evaporation" [0.00000000, "Mead"] + $ "Surplus.Average Annual Evaporation" [0.00000000, "Mohave"] + $ "Surplus.Average Annual Evaporation" [0.00000000, "Havasu"] ) - ( "SumGainsBelowVolume"( % "Powell", @"24:00:00 January 31, Current Year", @"24:00:00 December 31, Current Year" ) + "SumGainsBelowVolume"( % "Mead", @"24:00:00 January 31, Current Year", @"24:00:00 December 31, Current Year" ) + "SumGainsBelowVolume"( % "Havasu", @"24:00:00 January 31, Current Year", @"24:00:00 December 31, Current Year" ) );

    END;

    FUNCTION       "Set Monthly Surplus Schedule" ( DATETIME date, STRING user )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Calculates the monthly surplus volume from the annual volume.<br>This function was created as part of the Domestic and Quantified Surplus logic. -HMG 8/2/11<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      % "Surplus Total Annual Schedules" & user [@"24:00:00 December 31, Current Year"] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "Equal"];

    END;

    FUNCTION       "Set Monthly Surplus Schedule- FC" ( DATETIME date, STRING user )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Calculates the monthly Flood Control Surplus volume from the annual volume. This function varies from the &quot;Set Monthly Surplus Schedule&quot; function in that it can be applied to any starting month instead of being limited to January. This is because a Flood Surplus can be declared at any point within the year. Once a Flood Control Surplus is declared it will continue through to the end of the current calendar year.  <br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    BEGIN

      % "Surplus Total Annual Schedules" & user [@"24:00:00 December 31, Current Year"] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "Equal"];

    END;

  END;

  PREDEFINED_GROUP "Numeric / Math";
  DESCRIPTION   "Predefined functions which perform generic numerical computations.";
  ACTIVE        TRUE;
  BEGIN

    PREDEFINED_FUNCTION "Max" ( NUMERIC arg0, NUMERIC arg1 )
    SCALE_UNITS    "1000 acre-ft/month";
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "Min" ( NUMERIC arg0, NUMERIC arg1 )
    SCALE_UNITS    "";
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "MinItem" ( LIST arg0 )
    SCALE_UNITS    "acre-ft";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "Sum" ( LIST arg0 )
    SCALE_UNITS    "";
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
;

  END;

  PREDEFINED_GROUP "Date / Time";
  DESCRIPTION   "Predefined functions which access and manipulate date/times.";
  ACTIVE        TRUE;
  BEGIN

    PREDEFINED_FUNCTION "OffsetDate" ( DATETIME arg0, NUMERIC arg1, STRING arg2 )
    SCALE_UNITS    "";
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
;

  END;

  PREDEFINED_GROUP "Engineering";
  DESCRIPTION   "Predefined functions similar to methods on objects.";
  ACTIVE        TRUE;
  BEGIN

    PREDEFINED_FUNCTION "SolveOutflow" ( OBJECT arg0, NUMERIC arg1, NUMERIC arg2, NUMERIC arg3, DATETIME arg4 )
    SCALE_UNITS    "acre-ft/month";
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
;

  END;

  PREDEFINED_GROUP "Workspace";
  DESCRIPTION   "Predefined functions which access information on slots and objects.";
  ACTIVE        TRUE;
  BEGIN

    PREDEFINED_FUNCTION "TableInterpolation" ( SLOT arg0, NUMERIC arg1, NUMERIC arg2, NUMERIC arg3, DATETIME arg4 )
    SCALE_UNITS    "";
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
;

  END;

END
